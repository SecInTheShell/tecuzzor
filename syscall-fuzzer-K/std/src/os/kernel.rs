/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const __llvm__: u32 = 1;
pub const __clang__: u32 = 1;
pub const __clang_major__: u32 = 6;
pub const __clang_minor__: u32 = 0;
pub const __clang_patchlevel__: u32 = 0;
pub const __clang_version__: &'static [u8; 31usize] = b"6.0.0 (tags/RELEASE_600/final)\0";
pub const __GNUC_MINOR__: u32 = 2;
pub const __GNUC_PATCHLEVEL__: u32 = 1;
pub const __GNUC__: u32 = 4;
pub const __GXX_ABI_VERSION: u32 = 1002;
pub const __ATOMIC_RELAXED: u32 = 0;
pub const __ATOMIC_CONSUME: u32 = 1;
pub const __ATOMIC_ACQUIRE: u32 = 2;
pub const __ATOMIC_RELEASE: u32 = 3;
pub const __ATOMIC_ACQ_REL: u32 = 4;
pub const __ATOMIC_SEQ_CST: u32 = 5;
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM: u32 = 0;
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP: u32 = 1;
pub const __OPENCL_MEMORY_SCOPE_DEVICE: u32 = 2;
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES: u32 = 3;
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP: u32 = 4;
pub const __PRAGMA_REDEFINE_EXTNAME: u32 = 1;
pub const __VERSION__: &'static [u8; 54usize] =
    b"4.2.1 Compatible Clang 6.0.0 (tags/RELEASE_600/final)\0";
pub const __OBJC_BOOL_IS_BOOL: u32 = 0;
pub const __CONSTANT_CFSTRINGS__: u32 = 1;
pub const __OPTIMIZE__: u32 = 1;
pub const __ORDER_LITTLE_ENDIAN__: u32 = 1234;
pub const __ORDER_BIG_ENDIAN__: u32 = 4321;
pub const __ORDER_PDP_ENDIAN__: u32 = 3412;
pub const __BYTE_ORDER__: u32 = 1234;
pub const __LITTLE_ENDIAN__: u32 = 1;
pub const _LP64: u32 = 1;
pub const __LP64__: u32 = 1;
pub const __CHAR_BIT__: u32 = 8;
pub const __SCHAR_MAX__: u32 = 127;
pub const __SHRT_MAX__: u32 = 32767;
pub const __INT_MAX__: u32 = 2147483647;
pub const __LONG_MAX__: u64 = 9223372036854775807;
pub const __LONG_LONG_MAX__: u64 = 9223372036854775807;
pub const __WCHAR_MAX__: u32 = 65535;
pub const __WINT_MAX__: u32 = 4294967295;
pub const __INTMAX_MAX__: u64 = 9223372036854775807;
pub const __SIZE_MAX__: i32 = -1;
pub const __UINTMAX_MAX__: i32 = -1;
pub const __PTRDIFF_MAX__: u64 = 9223372036854775807;
pub const __INTPTR_MAX__: u64 = 9223372036854775807;
pub const __UINTPTR_MAX__: i32 = -1;
pub const __SIZEOF_DOUBLE__: u32 = 8;
pub const __SIZEOF_FLOAT__: u32 = 4;
pub const __SIZEOF_INT__: u32 = 4;
pub const __SIZEOF_LONG__: u32 = 8;
pub const __SIZEOF_LONG_DOUBLE__: u32 = 16;
pub const __SIZEOF_LONG_LONG__: u32 = 8;
pub const __SIZEOF_POINTER__: u32 = 8;
pub const __SIZEOF_SHORT__: u32 = 2;
pub const __SIZEOF_PTRDIFF_T__: u32 = 8;
pub const __SIZEOF_SIZE_T__: u32 = 8;
pub const __SIZEOF_WCHAR_T__: u32 = 2;
pub const __SIZEOF_WINT_T__: u32 = 4;
pub const __SIZEOF_INT128__: u32 = 16;
pub const __INTMAX_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INTMAX_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINTMAX_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINTMAX_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINTMAX_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINTMAX_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __INTMAX_WIDTH__: u32 = 64;
pub const __PTRDIFF_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __PTRDIFF_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __PTRDIFF_WIDTH__: u32 = 64;
pub const __INTPTR_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INTPTR_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __INTPTR_WIDTH__: u32 = 64;
pub const __SIZE_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __SIZE_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __SIZE_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __SIZE_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __SIZE_WIDTH__: u32 = 64;
pub const __WCHAR_WIDTH__: u32 = 16;
pub const __WINT_WIDTH__: u32 = 32;
pub const __SIG_ATOMIC_WIDTH__: u32 = 32;
pub const __SIG_ATOMIC_MAX__: u32 = 2147483647;
pub const __UINTMAX_WIDTH__: u32 = 64;
pub const __UINTPTR_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINTPTR_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINTPTR_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINTPTR_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __UINTPTR_WIDTH__: u32 = 64;
pub const __FLT16_HAS_DENORM__: u32 = 1;
pub const __FLT16_DIG__: u32 = 3;
pub const __FLT16_DECIMAL_DIG__: u32 = 5;
pub const __FLT16_HAS_INFINITY__: u32 = 1;
pub const __FLT16_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT16_MANT_DIG__: u32 = 11;
pub const __FLT16_MAX_10_EXP__: u32 = 4;
pub const __FLT16_MAX_EXP__: u32 = 15;
pub const __FLT16_MIN_10_EXP__: i32 = -13;
pub const __FLT16_MIN_EXP__: i32 = -14;
pub const __FLT_HAS_DENORM__: u32 = 1;
pub const __FLT_DIG__: u32 = 6;
pub const __FLT_DECIMAL_DIG__: u32 = 9;
pub const __FLT_HAS_INFINITY__: u32 = 1;
pub const __FLT_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT_MANT_DIG__: u32 = 24;
pub const __FLT_MAX_10_EXP__: u32 = 38;
pub const __FLT_MAX_EXP__: u32 = 128;
pub const __FLT_MIN_10_EXP__: i32 = -37;
pub const __FLT_MIN_EXP__: i32 = -125;
pub const __DBL_HAS_DENORM__: u32 = 1;
pub const __DBL_DIG__: u32 = 15;
pub const __DBL_DECIMAL_DIG__: u32 = 17;
pub const __DBL_HAS_INFINITY__: u32 = 1;
pub const __DBL_HAS_QUIET_NAN__: u32 = 1;
pub const __DBL_MANT_DIG__: u32 = 53;
pub const __DBL_MAX_10_EXP__: u32 = 308;
pub const __DBL_MAX_EXP__: u32 = 1024;
pub const __DBL_MIN_10_EXP__: i32 = -307;
pub const __DBL_MIN_EXP__: i32 = -1021;
pub const __LDBL_HAS_DENORM__: u32 = 1;
pub const __LDBL_DIG__: u32 = 18;
pub const __LDBL_DECIMAL_DIG__: u32 = 21;
pub const __LDBL_HAS_INFINITY__: u32 = 1;
pub const __LDBL_HAS_QUIET_NAN__: u32 = 1;
pub const __LDBL_MANT_DIG__: u32 = 64;
pub const __LDBL_MAX_10_EXP__: u32 = 4932;
pub const __LDBL_MAX_EXP__: u32 = 16384;
pub const __LDBL_MIN_10_EXP__: i32 = -4931;
pub const __LDBL_MIN_EXP__: i32 = -16381;
pub const __POINTER_WIDTH__: u32 = 64;
pub const __BIGGEST_ALIGNMENT__: u32 = 16;
pub const __WCHAR_UNSIGNED__: u32 = 1;
pub const __WINT_UNSIGNED__: u32 = 1;
pub const __INT8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __INT16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __INT32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __INT64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __UINT8_MAX__: u32 = 255;
pub const __INT8_MAX__: u32 = 127;
pub const __UINT16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __UINT16_MAX__: u32 = 65535;
pub const __INT16_MAX__: u32 = 32767;
pub const __UINT32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __UINT32_MAX__: u32 = 4294967295;
pub const __INT32_MAX__: u32 = 2147483647;
pub const __UINT64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __UINT64_MAX__: i32 = -1;
pub const __INT64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST8_MAX__: u32 = 127;
pub const __INT_LEAST8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT_LEAST8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __UINT_LEAST8_MAX__: u32 = 255;
pub const __UINT_LEAST8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT_LEAST8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT_LEAST8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT_LEAST8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __INT_LEAST16_MAX__: u32 = 32767;
pub const __INT_LEAST16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT_LEAST16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __UINT_LEAST16_MAX__: u32 = 65535;
pub const __UINT_LEAST16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT_LEAST16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT_LEAST16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT_LEAST16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __INT_LEAST32_MAX__: u32 = 2147483647;
pub const __INT_LEAST32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT_LEAST32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __UINT_LEAST32_MAX__: u32 = 4294967295;
pub const __UINT_LEAST32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT_LEAST32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT_LEAST32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT_LEAST32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __INT_LEAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT_LEAST64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT_LEAST64_MAX__: i32 = -1;
pub const __UINT_LEAST64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT_LEAST64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT_LEAST64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT_LEAST64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __INT_FAST8_MAX__: u32 = 127;
pub const __INT_FAST8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT_FAST8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __UINT_FAST8_MAX__: u32 = 255;
pub const __UINT_FAST8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT_FAST8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT_FAST8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT_FAST8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __INT_FAST16_MAX__: u32 = 32767;
pub const __INT_FAST16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT_FAST16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __UINT_FAST16_MAX__: u32 = 65535;
pub const __UINT_FAST16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT_FAST16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT_FAST16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT_FAST16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __INT_FAST32_MAX__: u32 = 2147483647;
pub const __INT_FAST32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT_FAST32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __UINT_FAST32_MAX__: u32 = 4294967295;
pub const __UINT_FAST32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT_FAST32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT_FAST32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT_FAST32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __INT_FAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_FAST64_FMTd__: &'static [u8; 3usize] = b"ld\0";
pub const __INT_FAST64_FMTi__: &'static [u8; 3usize] = b"li\0";
pub const __UINT_FAST64_MAX__: i32 = -1;
pub const __UINT_FAST64_FMTo__: &'static [u8; 3usize] = b"lo\0";
pub const __UINT_FAST64_FMTu__: &'static [u8; 3usize] = b"lu\0";
pub const __UINT_FAST64_FMTx__: &'static [u8; 3usize] = b"lx\0";
pub const __UINT_FAST64_FMTX__: &'static [u8; 3usize] = b"lX\0";
pub const __FINITE_MATH_ONLY__: u32 = 0;
pub const __GNUC_GNU_INLINE__: u32 = 1;
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL: u32 = 1;
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LLONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __FLT_EVAL_METHOD__: u32 = 2;
pub const __FLT_RADIX__: u32 = 2;
pub const __DECIMAL_DIG__: u32 = 21;
pub const __SSP_STRONG__: u32 = 2;
pub const __amd64__: u32 = 1;
pub const __amd64: u32 = 1;
pub const __x86_64: u32 = 1;
pub const __x86_64__: u32 = 1;
pub const __k8: u32 = 1;
pub const __k8__: u32 = 1;
pub const __tune_k8__: u32 = 1;
pub const __NO_MATH_INLINES: u32 = 1;
pub const __FXSR__: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8: u32 = 1;
pub const __SIZEOF_FLOAT128__: u32 = 16;
pub const unix: u32 = 1;
pub const __unix: u32 = 1;
pub const __unix__: u32 = 1;
pub const linux: u32 = 1;
pub const __linux: u32 = 1;
pub const __linux__: u32 = 1;
pub const __gnu_linux__: u32 = 1;
pub const __ELF__: u32 = 1;
pub const __FLOAT128__: u32 = 1;
pub const __STDC__: u32 = 1;
pub const __STDC_HOSTED__: u32 = 1;
pub const __STDC_UTF_16__: u32 = 1;
pub const __STDC_UTF_32__: u32 = 1;
pub const __KERNEL__: u32 = 1;
pub const CONFIG_X86_X32_ABI: u32 = 1;
pub const CONFIG_AS_CFI: u32 = 1;
pub const CONFIG_AS_CFI_SIGNAL_FRAME: u32 = 1;
pub const CONFIG_AS_CFI_SECTIONS: u32 = 1;
pub const CONFIG_AS_FXSAVEQ: u32 = 1;
pub const CONFIG_AS_SSSE3: u32 = 1;
pub const CONFIG_AS_CRC32: u32 = 1;
pub const CONFIG_AS_AVX: u32 = 1;
pub const CONFIG_AS_AVX2: u32 = 1;
pub const CONFIG_AS_AVX512: u32 = 1;
pub const CONFIG_AS_SHA1_NI: u32 = 1;
pub const CONFIG_AS_SHA256_NI: u32 = 1;
pub const MODULE: u32 = 1;
pub const CC_USING_FENTRY: u32 = 1;
pub const CONFIG_IP6_NF_MATCH_AH_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_861_MODULE: u32 = 1;
pub const CONFIG_RING_BUFFER: u32 = 1;
pub const CONFIG_UWB_HWA_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8804_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_H323_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_SECCOMP_FILTER: u32 = 1;
pub const CONFIG_IP6_NF_SECURITY_MODULE: u32 = 1;
pub const CONFIG_SND_PROC_FS: u32 = 1;
pub const CONFIG_VFIO_PCI_MMAP: u32 = 1;
pub const CONFIG_SCSI_DMA: u32 = 1;
pub const CONFIG_TWL6040_CORE: u32 = 1;
pub const CONFIG_VFIO_MDEV_DEVICE_MODULE: u32 = 1;
pub const CONFIG_INTEL_IDLE: u32 = 1;
pub const CONFIG_TCP_MD5SIG: u32 = 1;
pub const CONFIG_KERNEL_GZIP: u32 = 1;
pub const CONFIG_HID_GT683R_MODULE: u32 = 1;
pub const CONFIG_MICROCODE: u32 = 1;
pub const CONFIG_ATM_ENI_MODULE: u32 = 1;
pub const CONFIG_MMA7455_MODULE: u32 = 1;
pub const CONFIG_VIDEO_EM28XX_V4L2_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CS3308_MODULE: u32 = 1;
pub const CONFIG_IP_SET_HASH_IPMARK_MODULE: u32 = 1;
pub const CONFIG_VIDEO_ADV7511_MODULE: u32 = 1;
pub const CONFIG_MAX1118_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_INEXIO_MODULE: u32 = 1;
pub const CONFIG_RTLBTCOEXIST_MODULE: u32 = 1;
pub const CONFIG_BATMAN_ADV_NC: u32 = 1;
pub const CONFIG_NFT_NAT_MODULE: u32 = 1;
pub const CONFIG_DW_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_WM831X_MODULE: u32 = 1;
pub const CONFIG_ZRAM_WRITEBACK: u32 = 1;
pub const CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK: u32 = 1;
pub const CONFIG_TOUCHSCREEN_WM9705: u32 = 1;
pub const CONFIG_INPUT_KEYBOARD: u32 = 1;
pub const CONFIG_SENSORS_ABITUGURU_MODULE: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_INT128: u32 = 1;
pub const CONFIG_IP_NF_TARGET_SYNPROXY_MODULE: u32 = 1;
pub const CONFIG_SLUB_CPU_PARTIAL: u32 = 1;
pub const CONFIG_MEMORY_ISOLATION: u32 = 1;
pub const CONFIG_USB_C67X00_HCD_MODULE: u32 = 1;
pub const CONFIG_RFS_ACCEL: u32 = 1;
pub const CONFIG_COMEDI_TEST_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_RT288X: u32 = 1;
pub const CONFIG_IP_NF_TARGET_REDIRECT_MODULE: u32 = 1;
pub const CONFIG_SERIO_ALTERA_PS2_MODULE: u32 = 1;
pub const CONFIG_DRM_GMA500_MODULE: u32 = 1;
pub const CONFIG_ARCH_WANTS_THP_SWAP: u32 = 1;
pub const CONFIG_CRC32: u32 = 1;
pub const CONFIG_I2C_BOARDINFO: u32 = 1;
pub const CONFIG_ATH9K_HTC_DEBUGFS: u32 = 1;
pub const CONFIG_DWC_XLGMAC_PCI_MODULE: u32 = 1;
pub const CONFIG_TI_ADC12138_MODULE: u32 = 1;
pub const CONFIG_DMI_SYSFS_MODULE: u32 = 1;
pub const CONFIG_SPEAKUP_SYNTH_LTLK_MODULE: u32 = 1;
pub const CONFIG_NF_NAT_PROTO_SCTP: u32 = 1;
pub const CONFIG_XEN_PV: u32 = 1;
pub const CONFIG_CROS_EC_PROTO: u32 = 1;
pub const CONFIG_USB_ALI_M5632: u32 = 1;
pub const CONFIG_NFT_FIB_INET_MODULE: u32 = 1;
pub const CONFIG_DM_SNAPSHOT_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_WM831X_MODULE: u32 = 1;
pub const CONFIG_MFD_WM831X_I2C: u32 = 1;
pub const CONFIG_IMA_APPRAISE_BOOTPARAM: u32 = 1;
pub const CONFIG_CAIF_MODULE: u32 = 1;
pub const CONFIG_PNFS_FLEXFILE_LAYOUT_MODULE: u32 = 1;
pub const CONFIG_IR_JVC_DECODER_MODULE: u32 = 1;
pub const CONFIG_X86_MCE: u32 = 1;
pub const CONFIG_PCMCIA_QLOGIC_MODULE: u32 = 1;
pub const CONFIG_SIGNED_PE_FILE_VERIFICATION: u32 = 1;
pub const CONFIG_USB_CONFIGFS_NCM: u32 = 1;
pub const CONFIG_DRM_NOUVEAU_MODULE: u32 = 1;
pub const CONFIG_FSCACHE_MODULE: u32 = 1;
pub const CONFIG_COMEDI_USBDUX_MODULE: u32 = 1;
pub const CONFIG_PARPORT_NOT_PC: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CPU_MODULE: u32 = 1;
pub const CONFIG_DVB_ISL6405_MODULE: u32 = 1;
pub const CONFIG_B43_BCMA_PIO: u32 = 1;
pub const CONFIG_AD7192_MODULE: u32 = 1;
pub const CONFIG_MOUSE_ELAN_I2C_MODULE: u32 = 1;
pub const CONFIG_USB_SNP_CORE_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_PCF85363_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX1668_MODULE: u32 = 1;
pub const CONFIG_BLK_SED_OPAL: u32 = 1;
pub const CONFIG_GPIO_AMD8111_MODULE: u32 = 1;
pub const CONFIG_SUNRPC_SWAP: u32 = 1;
pub const CONFIG_FB_TILEBLITTING: u32 = 1;
pub const CONFIG_TCM_QLA2XXX_MODULE: u32 = 1;
pub const CONFIG_KEY_DH_OPERATIONS: u32 = 1;
pub const CONFIG_IR_MCE_KBD_DECODER_MODULE: u32 = 1;
pub const CONFIG_MFD_RT5033_MODULE: u32 = 1;
pub const CONFIG_HSR_MODULE: u32 = 1;
pub const CONFIG_IXGBE_DCB: u32 = 1;
pub const CONFIG_NET_DSA_TAG_QCA: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_CONSERVATIVE: u32 = 1;
pub const CONFIG_SECCOMP: u32 = 1;
pub const CONFIG_HIGH_RES_TIMERS: u32 = 1;
pub const CONFIG_PCMCIA_AXNET_MODULE: u32 = 1;
pub const CONFIG_COMMON_CLK_WM831X_MODULE: u32 = 1;
pub const CONFIG_VIDEO_WM8739_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_SET_MEMORY: u32 = 1;
pub const CONFIG_DRM_AMD_DC: u32 = 1;
pub const CONFIG_MFD_CROS_EC_MODULE: u32 = 1;
pub const CONFIG_SECURITY_TOMOYO_MAX_AUDIT_LOG: u32 = 1024;
pub const CONFIG_BLK_DEV_DM: u32 = 1;
pub const CONFIG_RTC_DRV_88PM80X_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_RSXX_MODULE: u32 = 1;
pub const CONFIG_PWM_TWL_MODULE: u32 = 1;
pub const CONFIG_MTD_NAND_ECC_BCH: u32 = 1;
pub const CONFIG_RT2800USB_RT3573: u32 = 1;
pub const CONFIG_VLAN_8021Q_MODULE: u32 = 1;
pub const CONFIG_IP_MULTIPLE_TABLES: u32 = 1;
pub const CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT: u32 = 1;
pub const CONFIG_VFIO_PCI_VGA: u32 = 1;
pub const CONFIG_ACPI_BGRT: u32 = 1;
pub const CONFIG_SENSORS_LTC4260_MODULE: u32 = 1;
pub const CONFIG_UEVENT_HELPER: u32 = 1;
pub const CONFIG_CRYPTO_KEYWRAP_MODULE: u32 = 1;
pub const CONFIG_XEN_DOM0: u32 = 1;
pub const CONFIG_FIRMWARE_MEMMAP: u32 = 1;
pub const CONFIG_SSB_SDIOHOST: u32 = 1;
pub const CONFIG_BT_RFCOMM_MODULE: u32 = 1;
pub const CONFIG_FIX_EARLYCON_MEM: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_HEARTBEAT_MODULE: u32 = 1;
pub const CONFIG_DEV_APPLETALK_MODULE: u32 = 1;
pub const CONFIG_RAS_CEC: u32 = 1;
pub const CONFIG_INTEL_PUNIT_IPC_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_HX8353D_MODULE: u32 = 1;
pub const CONFIG_ND_PFN_MODULE: u32 = 1;
pub const CONFIG_CHARGER_LP8727_MODULE: u32 = 1;
pub const CONFIG_SCSI_INITIO_MODULE: u32 = 1;
pub const CONFIG_STK8BA50_MODULE: u32 = 1;
pub const CONFIG_DVB_TDA1004X_MODULE: u32 = 1;
pub const CONFIG_XZ_DEC_IA64: u32 = 1;
pub const CONFIG_REGULATOR_DA9211_MODULE: u32 = 1;
pub const CONFIG_RFD77402_MODULE: u32 = 1;
pub const CONFIG_INPUT_RETU_PWRBUTTON_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_ELAN: u32 = 1;
pub const CONFIG_JOYSTICK_ADI_MODULE: u32 = 1;
pub const CONFIG_DVB_BCM3510_MODULE: u32 = 1;
pub const CONFIG_INOTIFY_USER: u32 = 1;
pub const CONFIG_SND_SOC_RT286_MODULE: u32 = 1;
pub const CONFIG_WDAT_WDT_MODULE: u32 = 1;
pub const CONFIG_SECURITY_NETWORK_XFRM: u32 = 1;
pub const CONFIG_NF_CONNTRACK_NETBIOS_NS_MODULE: u32 = 1;
pub const CONFIG_HDMI: u32 = 1;
pub const CONFIG_SCSI_DH: u32 = 1;
pub const CONFIG_SCSI_LOGGING: u32 = 1;
pub const CONFIG_SX9500_MODULE: u32 = 1;
pub const CONFIG_FB_CYBER2000_DDC: u32 = 1;
pub const CONFIG_BRIDGE_EBT_T_FILTER_MODULE: u32 = 1;
pub const CONFIG_NETWORK_FILESYSTEMS: u32 = 1;
pub const CONFIG_IRQ_POLL: u32 = 1;
pub const CONFIG_JOYSTICK_IFORCE_232: u32 = 1;
pub const CONFIG_GREYBUS_LOOPBACK_MODULE: u32 = 1;
pub const CONFIG_KVM_INTEL_MODULE: u32 = 1;
pub const CONFIG_ASUS_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_MD4_MODULE: u32 = 1;
pub const CONFIG_BCMA_HOST_PCI: u32 = 1;
pub const CONFIG_AD7298_MODULE: u32 = 1;
pub const CONFIG_SATA_AHCI_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_IMA_DEFAULT_HASH_SHA1: u32 = 1;
pub const CONFIG_USB_SI470X_MODULE: u32 = 1;
pub const CONFIG_THERMAL_GOV_BANG_BANG: u32 = 1;
pub const CONFIG_X86_MINIMUM_CPU_FAMILY: u32 = 64;
pub const CONFIG_AD7923_MODULE: u32 = 1;
pub const CONFIG_SND_I2S_HI6210_I2S_MODULE: u32 = 1;
pub const CONFIG_SCSI_BFA_FC_MODULE: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_ONDEMAND: u32 = 1;
pub const CONFIG_KDB_DEFAULT_ENABLE: u32 = 1;
pub const CONFIG_SENSORS_LM95245_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_JL2005BCD_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_MC13XXX_MODULE: u32 = 1;
pub const CONFIG_CM36651_MODULE: u32 = 1;
pub const CONFIG_EXT4_ENCRYPTION: u32 = 1;
pub const CONFIG_AMD_PHY_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX18_ALSA_MODULE: u32 = 1;
pub const CONFIG_BT_HCIBFUSB_MODULE: u32 = 1;
pub const CONFIG_MFD_CS47L24: u32 = 1;
pub const CONFIG_CHASH_MODULE: u32 = 1;
pub const CONFIG_GLOB: u32 = 1;
pub const CONFIG_SND_SOC_CS42L73_MODULE: u32 = 1;
pub const CONFIG_PLX_HERMES_MODULE: u32 = 1;
pub const CONFIG_NFT_SET_BITMAP_MODULE: u32 = 1;
pub const CONFIG_PARAVIRT_SPINLOCKS: u32 = 1;
pub const CONFIG_CGROUP_DEVICE: u32 = 1;
pub const CONFIG_WL12XX_MODULE: u32 = 1;
pub const CONFIG_X86_TSC: u32 = 1;
pub const CONFIG_104_QUAD_8_MODULE: u32 = 1;
pub const CONFIG_PPP_SYNC_TTY_MODULE: u32 = 1;
pub const CONFIG_ARCH_SUSPEND_POSSIBLE: u32 = 1;
pub const CONFIG_HID_PLANTRONICS_MODULE: u32 = 1;
pub const CONFIG_MFD_TPS65090: u32 = 1;
pub const CONFIG_NCPFS_PACKET_SIGNING: u32 = 1;
pub const CONFIG_DA9055_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_COMPAT_NETLINK_MESSAGES: u32 = 1;
pub const CONFIG_INLINE_WRITE_UNLOCK_IRQ: u32 = 1;
pub const CONFIG_NFT_CHAIN_NAT_IPV6_MODULE: u32 = 1;
pub const CONFIG_RC_CORE_MODULE: u32 = 1;
pub const CONFIG_TCG_VTPM_PROXY_MODULE: u32 = 1;
pub const CONFIG_USB_G_SERIAL_MODULE: u32 = 1;
pub const CONFIG_CGROUP_WRITEBACK: u32 = 1;
pub const CONFIG_SND_SOC_TPA6130A2_MODULE: u32 = 1;
pub const CONFIG_MAC80211_STA_HASH_MAX_SIZE: u32 = 0;
pub const CONFIG_LEDS_PCA955X_MODULE: u32 = 1;
pub const CONFIG_NLS_MAC_TURKISH_MODULE: u32 = 1;
pub const CONFIG_IP_VS_NQ_MODULE: u32 = 1;
pub const CONFIG_DVB_DRXD_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_QEDR_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LTC4245_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_MMAP_RND_BITS: u32 = 1;
pub const CONFIG_TCG_TIS_CORE: u32 = 1;
pub const CONFIG_HID_SPEEDLINK_MODULE: u32 = 1;
pub const CONFIG_SPEAKUP_SYNTH_APOLLO_MODULE: u32 = 1;
pub const CONFIG_HIBERNATION: u32 = 1;
pub const CONFIG_BLK_DEV_NBD_MODULE: u32 = 1;
pub const CONFIG_PNPACPI: u32 = 1;
pub const CONFIG_AD7280_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_NAVMAN_MODULE: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_ATTR_SET: u32 = 1;
pub const CONFIG_RMI4_F12: u32 = 1;
pub const CONFIG_JOYSTICK_SPACEORB_MODULE: u32 = 1;
pub const CONFIG_EDAC_I5400_MODULE: u32 = 1;
pub const CONFIG_TCP_CONG_HTCP_MODULE: u32 = 1;
pub const CONFIG_EXT4_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_SERIAL_RP2_MODULE: u32 = 1;
pub const CONFIG_SCSI_DEBUG_MODULE: u32 = 1;
pub const CONFIG_NET_SWITCHDEV: u32 = 1;
pub const CONFIG_ZSTD_COMPRESS_MODULE: u32 = 1;
pub const CONFIG_DRM_I915_MODULE: u32 = 1;
pub const CONFIG_BINFMT_MISC_MODULE: u32 = 1;
pub const CONFIG_SENSORS_AD7314_MODULE: u32 = 1;
pub const CONFIG_VME_CA91CX42_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_PCM179X_I2C_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_HELPER_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MT6397_MODULE: u32 = 1;
pub const CONFIG_SSB_POSSIBLE: u32 = 1;
pub const CONFIG_HPET_MMAP_DEFAULT: u32 = 1;
pub const CONFIG_NFS_V4_2: u32 = 1;
pub const CONFIG_USBIP_VUDC_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_EBT_T_NAT_MODULE: u32 = 1;
pub const CONFIG_VIDEO_SAA7134_MODULE: u32 = 1;
pub const CONFIG_NF_NAT_SIP_MODULE: u32 = 1;
pub const CONFIG_USB_F_EEM_MODULE: u32 = 1;
pub const CONFIG_SENSORS_W83792D_MODULE: u32 = 1;
pub const CONFIG_VIDEO_ZORAN_BUZ_MODULE: u32 = 1;
pub const CONFIG_SENSORS_INA3221_MODULE: u32 = 1;
pub const CONFIG_MMU_NOTIFIER: u32 = 1;
pub const CONFIG_SYSV68_PARTITION: u32 = 1;
pub const CONFIG_RADIO_SHARK_MODULE: u32 = 1;
pub const CONFIG_ASYMMETRIC_KEY_TYPE: u32 = 1;
pub const CONFIG_VFIO_VIRQFD_MODULE: u32 = 1;
pub const CONFIG_VHOST_VSOCK_MODULE: u32 = 1;
pub const CONFIG_NET_9P_RDMA_MODULE: u32 = 1;
pub const CONFIG_TRANSPARENT_HUGEPAGE_MADVISE: u32 = 1;
pub const CONFIG_DRM_RADEON_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_STATISTIC_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_PCIMIO_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADDI_APCI_1032_MODULE: u32 = 1;
pub const CONFIG_TERANETICS_PHY_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_855_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_ILI9486_MODULE: u32 = 1;
pub const CONFIG_NFT_CHAIN_ROUTE_IPV4_MODULE: u32 = 1;
pub const CONFIG_SPI_DYNAMIC: u32 = 1;
pub const CONFIG_MTD_CMDLINE_PARTS_MODULE: u32 = 1;
pub const CONFIG_TMP006_MODULE: u32 = 1;
pub const CONFIG_ESI_DONGLE_MODULE: u32 = 1;
pub const CONFIG_SECURITY_YAMA: u32 = 1;
pub const CONFIG_VIDEO_SAA7127_MODULE: u32 = 1;
pub const CONFIG_I2C_ISMT_MODULE: u32 = 1;
pub const CONFIG_UHID_MODULE: u32 = 1;
pub const CONFIG_NETCONSOLE_DYNAMIC: u32 = 1;
pub const CONFIG_EDAC_I5100_MODULE: u32 = 1;
pub const CONFIG_DVB_EC100_MODULE: u32 = 1;
pub const CONFIG_IP_NF_NAT_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_EDGEPORT_TI_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_HID_MODULE: u32 = 1;
pub const CONFIG_SIGNATURE: u32 = 1;
pub const CONFIG_RTC_DRV_PCF50633_MODULE: u32 = 1;
pub const CONFIG_HDLC_RAW_MODULE: u32 = 1;
pub const CONFIG_B43LEGACY_LEDS: u32 = 1;
pub const CONFIG_USB_SERIAL_SAFE_MODULE: u32 = 1;
pub const CONFIG_NFC_NCI_UART_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_CROS_EC_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_NF_EBTABLES_MODULE: u32 = 1;
pub const CONFIG_HARDLOCKUP_DETECTOR_PERF: u32 = 1;
pub const CONFIG_MTD_LATCH_ADDR_MODULE: u32 = 1;
pub const CONFIG_DVB_LG2160_MODULE: u32 = 1;
pub const CONFIG_MTD_AMD76XROM_MODULE: u32 = 1;
pub const CONFIG_USB_OHCI_LITTLE_ENDIAN: u32 = 1;
pub const CONFIG_NET_SCH_FIFO: u32 = 1;
pub const CONFIG_WILC1000_SPI_MODULE: u32 = 1;
pub const CONFIG_REISERFS_FS_MODULE: u32 = 1;
pub const CONFIG_SWPHY: u32 = 1;
pub const CONFIG_STM_SOURCE_CONSOLE_MODULE: u32 = 1;
pub const CONFIG_AURORA_NB8800_MODULE: u32 = 1;
pub const CONFIG_TWL4030_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_THP_SWAP: u32 = 1;
pub const CONFIG_SATA_NV_MODULE: u32 = 1;
pub const CONFIG_FSNOTIFY: u32 = 1;
pub const CONFIG_ACPI_CONFIGFS_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_RMD128_MODULE: u32 = 1;
pub const CONFIG_LEDS_MAX8997_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_LOOP_MIN_COUNT: u32 = 8;
pub const CONFIG_STP_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_SQ905_MODULE: u32 = 1;
pub const CONFIG_MFD_TPS65910: u32 = 1;
pub const CONFIG_SPI_CADENCE_MODULE: u32 = 1;
pub const CONFIG_DVB_AU8522_MODULE: u32 = 1;
pub const CONFIG_INET6_TUNNEL_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MAX8925_MODULE: u32 = 1;
pub const CONFIG_INTEL_RAPL_MODULE: u32 = 1;
pub const CONFIG_VIA_FIR_MODULE: u32 = 1;
pub const CONFIG_SCSI_DC395x_MODULE: u32 = 1;
pub const CONFIG_DVB_M88RS2000_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_SIP_MODULE: u32 = 1;
pub const CONFIG_STACK_TRACER: u32 = 1;
pub const CONFIG_MEDIA_ATTACH: u32 = 1;
pub const CONFIG_SND_NM256_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_MANAGER_DISABLE_TESTS: u32 = 1;
pub const CONFIG_DMA_VIRT_OPS: u32 = 1;
pub const CONFIG_HIDRAW: u32 = 1;
pub const CONFIG_NET_SCH_FQ_CODEL_MODULE: u32 = 1;
pub const CONFIG_WIL6210_ISR_COR: u32 = 1;
pub const CONFIG_KSDAZZLE_DONGLE_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ADM1025_MODULE: u32 = 1;
pub const CONFIG_HAVE_KERNEL_LZMA: u32 = 1;
pub const CONFIG_HID_PRODIKEYS_MODULE: u32 = 1;
pub const CONFIG_BMA180_MODULE: u32 = 1;
pub const CONFIG_RT2X00_LIB_LEDS: u32 = 1;
pub const CONFIG_ARCH_HAS_FILTER_PGPROT: u32 = 1;
pub const CONFIG_RTL8XXXU_UNTESTED: u32 = 1;
pub const CONFIG_NET_PTP_CLASSIFY: u32 = 1;
pub const CONFIG_UNIX_DIAG_MODULE: u32 = 1;
pub const CONFIG_TSYS02D_MODULE: u32 = 1;
pub const CONFIG_VCNL4000_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_PCM3168A_SPI_MODULE: u32 = 1;
pub const CONFIG_IP_VS_SED_MODULE: u32 = 1;
pub const CONFIG_GENERIC_SMP_IDLE_THREAD: u32 = 1;
pub const CONFIG_MOUSE_CYAPA_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_QUALCOMM: u32 = 1;
pub const CONFIG_DVB_DS3000_MODULE: u32 = 1;
pub const CONFIG_FB_S1D13XXX_MODULE: u32 = 1;
pub const CONFIG_MTD_SST25L_MODULE: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_NUMA_BALANCING: u32 = 1;
pub const CONFIG_REGULATOR_LP3971_MODULE: u32 = 1;
pub const CONFIG_DM_FLAKEY_MODULE: u32 = 1;
pub const CONFIG_HAVE_COPY_THREAD_TLS: u32 = 1;
pub const CONFIG_VME_USER_MODULE: u32 = 1;
pub const CONFIG_PATA_OPTIDMA_MODULE: u32 = 1;
pub const CONFIG_DYNAMIC_DEBUG: u32 = 1;
pub const CONFIG_MACVTAP_MODULE: u32 = 1;
pub const CONFIG_LEDS_REGULATOR_MODULE: u32 = 1;
pub const CONFIG_CHELSIO_T4VF_MODULE: u32 = 1;
pub const CONFIG_HAVE_MEMORY_PRESENT: u32 = 1;
pub const CONFIG_CPUMASK_OFFSTACK: u32 = 1;
pub const CONFIG_USB_SERIAL_FTDI_SIO_MODULE: u32 = 1;
pub const CONFIG_EXTCON_RT8973A_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_EZCHIP: u32 = 1;
pub const CONFIG_BRIDGE_EBT_REDIRECT_MODULE: u32 = 1;
pub const CONFIG_XEN_COMPAT_XENFS: u32 = 1;
pub const CONFIG_XEN_SCSI_BACKEND_MODULE: u32 = 1;
pub const CONFIG_INTEL_TH_PCI_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_TIOCMD_MODULE: u32 = 1;
pub const CONFIG_MEDIA_DIGITAL_TV_SUPPORT: u32 = 1;
pub const CONFIG_8139CP_MODULE: u32 = 1;
pub const CONFIG_LDISC_AUTOLOAD: u32 = 1;
pub const CONFIG_GREYBUS_ES2_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_RSA: u32 = 1;
pub const CONFIG_FIB_RULES: u32 = 1;
pub const CONFIG_HID_ACRUX_FF: u32 = 1;
pub const CONFIG_CRYPTO_CRCT10DIF: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2408_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_OBEX: u32 = 1;
pub const CONFIG_RTC_DRV_MCP795_MODULE: u32 = 1;
pub const CONFIG_DVB_FIREDTV_INPUT: u32 = 1;
pub const CONFIG_SND_ES1968_INPUT: u32 = 1;
pub const CONFIG_IP_VS_NFCT: u32 = 1;
pub const CONFIG_HID_EMS_FF_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADDI_APCI_16XX_MODULE: u32 = 1;
pub const CONFIG_VLAN_8021Q_GVRP: u32 = 1;
pub const CONFIG_IWLWIFI_DEBUGFS: u32 = 1;
pub const CONFIG_IP_SET_HASH_NETIFACE_MODULE: u32 = 1;
pub const CONFIG_IP6_NF_MANGLE_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_TAG_DSA: u32 = 1;
pub const CONFIG_MTD_PLATRAM_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ES8316_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_SI2157_MODULE: u32 = 1;
pub const CONFIG_SCSI_CONSTANTS: u32 = 1;
pub const CONFIG_HAVE_IRQ_TIME_ACCOUNTING: u32 = 1;
pub const CONFIG_CFAG12864B_MODULE: u32 = 1;
pub const CONFIG_BT_MRVL_SDIO_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_REALM_MODULE: u32 = 1;
pub const CONFIG_SFC_FALCON_MODULE: u32 = 1;
pub const CONFIG_BT_HCIBPA10X_MODULE: u32 = 1;
pub const CONFIG_MEGARAID_NEWGEN: u32 = 1;
pub const CONFIG_INTEL_TXT: u32 = 1;
pub const CONFIG_HID_GFRM_MODULE: u32 = 1;
pub const CONFIG_MFD_CROS_EC_SPI_MODULE: u32 = 1;
pub const CONFIG_SQUASHFS_XATTR: u32 = 1;
pub const CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED: u32 = 1;
pub const CONFIG_IP_VS_RR_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_CHT_BSW_MAX98090_TI_MACH_MODULE: u32 = 1;
pub const CONFIG_IPV6: u32 = 1;
pub const CONFIG_ALTERA_PR_IP_CORE_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_QUALCOMM_MODULE: u32 = 1;
pub const CONFIG_TEST_LKM_MODULE: u32 = 1;
pub const CONFIG_MAX1027_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_HFI1_MODULE: u32 = 1;
pub const CONFIG_NET_9P_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_TPS62360_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_AEAD: u32 = 1;
pub const CONFIG_USB_GADGET_TARGET_MODULE: u32 = 1;
pub const CONFIG_FB_HECUBA_MODULE: u32 = 1;
pub const CONFIG_AUDIT_ARCH: u32 = 1;
pub const CONFIG_COMPAT: u32 = 1;
pub const CONFIG_POWERCAP: u32 = 1;
pub const CONFIG_MAGIC_SYSRQ_SERIAL: u32 = 1;
pub const CONFIG_LIQUIDIO_VF_MODULE: u32 = 1;
pub const CONFIG_BQL: u32 = 1;
pub const CONFIG_ADJD_S311_MODULE: u32 = 1;
pub const CONFIG_INPUT_MOUSEDEV_PSAUX: u32 = 1;
pub const CONFIG_RESET_TI_SYSCON_MODULE: u32 = 1;
pub const CONFIG_HAVE_KERNEL_BZIP2: u32 = 1;
pub const CONFIG_COMEDI_ADDI_APCI_3501_MODULE: u32 = 1;
pub const CONFIG_DEFAULT_TCP_CONG: &'static [u8; 6usize] = b"cubic\0";
pub const CONFIG_MCP4725_MODULE: u32 = 1;
pub const CONFIG_UEVENT_HELPER_PATH: &'static [u8; 1usize] = b"\0";
pub const CONFIG_USB_UAS_MODULE: u32 = 1;
pub const CONFIG_U_SERIAL_CONSOLE: u32 = 1;
pub const CONFIG_ORANGEFS_FS_MODULE: u32 = 1;
pub const CONFIG_NTB_NETDEV_MODULE: u32 = 1;
pub const CONFIG_DEVTMPFS: u32 = 1;
pub const CONFIG_NET_CLS_FLOW_MODULE: u32 = 1;
pub const CONFIG_PROCESSOR_SELECT: u32 = 1;
pub const CONFIG_X86_INTEL_TSX_MODE_OFF: u32 = 1;
pub const CONFIG_TIGON3_HWMON: u32 = 1;
pub const CONFIG_SENSORS_MAX8688_MODULE: u32 = 1;
pub const CONFIG_SENSORS_PC87427_MODULE: u32 = 1;
pub const CONFIG_INPUT_MAX77693_HAPTIC_MODULE: u32 = 1;
pub const CONFIG_SM_FTL_MODULE: u32 = 1;
pub const CONFIG_TI_ADC108S102_MODULE: u32 = 1;
pub const CONFIG_PNFS_FILE_LAYOUT_MODULE: u32 = 1;
pub const CONFIG_MCB_LPC_MODULE: u32 = 1;
pub const CONFIG_QED_SRIOV: u32 = 1;
pub const CONFIG_HSU_DMA_MODULE: u32 = 1;
pub const CONFIG_NET_IPVTI_MODULE: u32 = 1;
pub const CONFIG_I82092_MODULE: u32 = 1;
pub const CONFIG_SCSI_PMCRAID_MODULE: u32 = 1;
pub const CONFIG_NFC_NXP_NCI_MODULE: u32 = 1;
pub const CONFIG_DVB_ISL6423_MODULE: u32 = 1;
pub const CONFIG_FB_S3_DDC: u32 = 1;
pub const CONFIG_USB_STORAGE_USBAT_MODULE: u32 = 1;
pub const CONFIG_REISERFS_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_SND_FIREWIRE_DIGI00X_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_USER_MEM: u32 = 1;
pub const CONFIG_REGULATOR_ARIZONA_LDO1_MODULE: u32 = 1;
pub const CONFIG_GPIO_MAX7301_MODULE: u32 = 1;
pub const CONFIG_INPUT_88PM80X_ONKEY_MODULE: u32 = 1;
pub const CONFIG_APPLE_GMUX_MODULE: u32 = 1;
pub const CONFIG_NF_NAT_PROTO_GRE_MODULE: u32 = 1;
pub const CONFIG_YENTA_RICOH: u32 = 1;
pub const CONFIG_SUNRPC_BACKCHANNEL: u32 = 1;
pub const CONFIG_NLS_ISO8859_7_MODULE: u32 = 1;
pub const CONFIG_QEDF_MODULE: u32 = 1;
pub const CONFIG_UNISYS_VISORNIC_MODULE: u32 = 1;
pub const CONFIG_MOUSE_PS2_SMBUS: u32 = 1;
pub const CONFIG_CRYPTO_PCBC_MODULE: u32 = 1;
pub const CONFIG_IP6_NF_TARGET_REJECT_MODULE: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MAX: u32 = 16;
pub const CONFIG_UPROBES: u32 = 1;
pub const CONFIG_PWM_PCA9685_MODULE: u32 = 1;
pub const CONFIG_HISAX_FRITZPCI: u32 = 1;
pub const CONFIG_IR_SHARP_DECODER_MODULE: u32 = 1;
pub const CONFIG_HID_APPLEIR_MODULE: u32 = 1;
pub const CONFIG_COMEDI_PCL812_MODULE: u32 = 1;
pub const CONFIG_NFC_FDP_MODULE: u32 = 1;
pub const CONFIG_ASYNC_MEMCPY_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_MAX8998_MODULE: u32 = 1;
pub const CONFIG_ADIS16480_MODULE: u32 = 1;
pub const CONFIG_X86_POWERNOW_K8: u32 = 1;
pub const CONFIG_ARCH_SPARSEMEM_ENABLE: u32 = 1;
pub const CONFIG_V4L_TEST_DRIVERS: u32 = 1;
pub const CONFIG_SC1200_WDT_MODULE: u32 = 1;
pub const CONFIG_NF_NAT_REDIRECT_MODULE: u32 = 1;
pub const CONFIG_DCDBAS_MODULE: u32 = 1;
pub const CONFIG_CIO_DAC_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1305_MODULE: u32 = 1;
pub const CONFIG_CAIF_SPI_SLAVE_MODULE: u32 = 1;
pub const CONFIG_IR_NEC_DECODER_MODULE: u32 = 1;
pub const CONFIG_HOTPLUG_CPU: u32 = 1;
pub const CONFIG_USB_SERIAL_MOS7840_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_GENERIC_DMAENGINE_PCM: u32 = 1;
pub const CONFIG_INET_DIAG_DESTROY: u32 = 1;
pub const CONFIG_NLS_MAC_CYRILLIC_MODULE: u32 = 1;
pub const CONFIG_USB_SL811_HCD_ISO: u32 = 1;
pub const CONFIG_PM_SLEEP_DEBUG: u32 = 1;
pub const CONFIG_SND_MAESTRO3_INPUT: u32 = 1;
pub const CONFIG_MEDIA_PCI_SUPPORT: u32 = 1;
pub const CONFIG_WLAN: u32 = 1;
pub const CONFIG_AFFS_FS_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADDI_APCI_1516_MODULE: u32 = 1;
pub const CONFIG_ATM_FIRESTREAM_MODULE: u32 = 1;
pub const CONFIG_NFP_MODULE: u32 = 1;
pub const CONFIG_NAMESPACES: u32 = 1;
pub const CONFIG_USB_U_AUDIO_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2423_MODULE: u32 = 1;
pub const CONFIG_L2TP_DEBUGFS_MODULE: u32 = 1;
pub const CONFIG_XEN_512GB: u32 = 1;
pub const CONFIG_HAVE_CMPXCHG_DOUBLE: u32 = 1;
pub const CONFIG_NSC_FIR_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_ABX80X_MODULE: u32 = 1;
pub const CONFIG_USB_NET_INT51X1_MODULE: u32 = 1;
pub const CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION_MODULE: u32 = 1;
pub const CONFIG_KGDB_SERIAL_CONSOLE: u32 = 1;
pub const CONFIG_PATA_ATP867X_MODULE: u32 = 1;
pub const CONFIG_ARCH_USE_MEMREMAP_PROT: u32 = 1;
pub const CONFIG_SFI: u32 = 1;
pub const CONFIG_HAVE_ARCH_HUGE_VMAP: u32 = 1;
pub const CONFIG_FM10K_MODULE: u32 = 1;
pub const CONFIG_DW_DMAC_PCI_MODULE: u32 = 1;
pub const CONFIG_IA32_EMULATION: u32 = 1;
pub const CONFIG_SND_SOC_SIGMADSP_MODULE: u32 = 1;
pub const CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY: u32 = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_USA49W: u32 = 1;
pub const CONFIG_USB_CONFIGFS_MODULE: u32 = 1;
pub const CONFIG_FORTIFY_SOURCE: u32 = 1;
pub const CONFIG_COMEDI_CONTEC_PCI_DIO_MODULE: u32 = 1;
pub const CONFIG_AXP20X_ADC_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_BSG: u32 = 1;
pub const CONFIG_LEDS_WM8350_MODULE: u32 = 1;
pub const CONFIG_ENIC_MODULE: u32 = 1;
pub const CONFIG_SCSI_ISCI_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX6697_MODULE: u32 = 1;
pub const CONFIG_PATA_SERVERWORKS_MODULE: u32 = 1;
pub const CONFIG_CONNECTOR: u32 = 1;
pub const CONFIG_COMEDI_DAS16M1_MODULE: u32 = 1;
pub const CONFIG_MEDIA_USB_SUPPORT: u32 = 1;
pub const CONFIG_MFD_TPS68470: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_RATEEST_MODULE: u32 = 1;
pub const CONFIG_PCIEAER: u32 = 1;
pub const CONFIG_AIM_CDEV_MODULE: u32 = 1;
pub const CONFIG_EPIC100_MODULE: u32 = 1;
pub const CONFIG_SCTP_COOKIE_HMAC_SHA1: u32 = 1;
pub const CONFIG_BRIDGE_EBT_ARPREPLY_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_APPLE_MODULE: u32 = 1;
pub const CONFIG_B43LEGACY_DMA_AND_PIO_MODE: u32 = 1;
pub const CONFIG_MEM_SOFT_DIRTY: u32 = 1;
pub const CONFIG_PARIDE_MODULE: u32 = 1;
pub const CONFIG_KVM_DEBUG_FS: u32 = 1;
pub const CONFIG_INTEGRITY: u32 = 1;
pub const CONFIG_MPL115_MODULE: u32 = 1;
pub const CONFIG_DVB_MAX_ADAPTERS: u32 = 8;
pub const CONFIG_SENSORS_SIS5595_MODULE: u32 = 1;
pub const CONFIG_MPU3050_I2C_MODULE: u32 = 1;
pub const CONFIG_CW1200_WLAN_SDIO_MODULE: u32 = 1;
pub const CONFIG_DM_MULTIPATH_QL_MODULE: u32 = 1;
pub const CONFIG_LEGACY_PTYS: u32 = 1;
pub const CONFIG_LIBERTAS_USB_MODULE: u32 = 1;
pub const CONFIG_JFS_FS_MODULE: u32 = 1;
pub const CONFIG_CAN_EMS_USB_MODULE: u32 = 1;
pub const CONFIG_XFRM_IPCOMP_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DRBG_MENU: u32 = 1;
pub const CONFIG_CRYPTO_RNG2: u32 = 1;
pub const CONFIG_UIO_CIF_MODULE: u32 = 1;
pub const CONFIG_USB_PWC_INPUT_EVDEV: u32 = 1;
pub const CONFIG_FUSION_FC_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_NETLINK_QUEUE_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_CSUM_MODULE: u32 = 1;
pub const CONFIG_RTLLIB_CRYPTO_CCMP_MODULE: u32 = 1;
pub const CONFIG_CEPH_LIB_USE_DNS_RESOLVER: u32 = 1;
pub const CONFIG_RTC_DRV_AB3100_MODULE: u32 = 1;
pub const CONFIG_THERMAL_WRITABLE_TRIPS: u32 = 1;
pub const CONFIG_SCSI_MPT3SAS_MODULE: u32 = 1;
pub const CONFIG_NFTL_RW: u32 = 1;
pub const CONFIG_MFD_MC13XXX_MODULE: u32 = 1;
pub const CONFIG_NETWORK_PHY_TIMESTAMPING: u32 = 1;
pub const CONFIG_MSDOS_FS_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ISL29028_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DT2811_MODULE: u32 = 1;
pub const CONFIG_USB_U_SERIAL_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_UART_MODULE: u32 = 1;
pub const CONFIG_FB_VGA16_MODULE: u32 = 1;
pub const CONFIG_SCSI_FLASHPOINT: u32 = 1;
pub const CONFIG_NET_CLS_CGROUP_MODULE: u32 = 1;
pub const CONFIG_TUN: u32 = 1;
pub const CONFIG_SND_SOC_ES8328_MODULE: u32 = 1;
pub const CONFIG_IP_VS_FO_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_SUNPLUS_MODULE: u32 = 1;
pub const CONFIG_ISDN_AUDIO: u32 = 1;
pub const CONFIG_VZ89X_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DAS6402_MODULE: u32 = 1;
pub const CONFIG_ATM_IDT77252_MODULE: u32 = 1;
pub const CONFIG_DVB_AU8522_V4L_MODULE: u32 = 1;
pub const CONFIG_AD9832_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_BRIDGED_PHY_MODULE: u32 = 1;
pub const CONFIG_IIO_KFIFO_BUF_MODULE: u32 = 1;
pub const CONFIG_ENCLOSURE_SERVICES_MODULE: u32 = 1;
pub const CONFIG_UCSI_ACPI_MODULE: u32 = 1;
pub const CONFIG_IPV6_PIMSM_V2: u32 = 1;
pub const CONFIG_ARCH_ENABLE_THP_MIGRATION: u32 = 1;
pub const CONFIG_SENSORS_ADS1015_MODULE: u32 = 1;
pub const CONFIG_USB_XHCI_DBGCAP: u32 = 1;
pub const CONFIG_DVB_USB_DVBSKY_MODULE: u32 = 1;
pub const CONFIG_WIZNET_BUS_ANY: u32 = 1;
pub const CONFIG_BNX2_MODULE: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_DISK: u32 = 1;
pub const CONFIG_CAN_MODULE: u32 = 1;
pub const CONFIG_SND_VX222_MODULE: u32 = 1;
pub const CONFIG_CFG80211_MODULE: u32 = 1;
pub const CONFIG_MACSEC_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CHACHA20POLY1305_MODULE: u32 = 1;
pub const CONFIG_SSB_BLOCKIO: u32 = 1;
pub const CONFIG_MTD_BLOCK_RO_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_CHELSIO_MODULE: u32 = 1;
pub const CONFIG_MFD_DA9063: u32 = 1;
pub const CONFIG_EQUALIZER_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_HX8347D_MODULE: u32 = 1;
pub const CONFIG_COMEDI_JR3_PCI_MODULE: u32 = 1;
pub const CONFIG_SND_AU8810_MODULE: u32 = 1;
pub const CONFIG_GPIO_LYNXPOINT: u32 = 1;
pub const CONFIG_IP_SET_HASH_NETNET_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX6621_MODULE: u32 = 1;
pub const CONFIG_NFT_OBJREF_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_1250_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_6527_MODULE: u32 = 1;
pub const CONFIG_VFIO_PCI_IGD: u32 = 1;
pub const CONFIG_DM_CRYPT_MODULE: u32 = 1;
pub const CONFIG_REED_SOLOMON_ENC8: u32 = 1;
pub const CONFIG_REGULATOR_PV88060_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250: u32 = 1;
pub const CONFIG_RTC_DRV_ISL12022_MODULE: u32 = 1;
pub const CONFIG_PWM_CROS_EC_MODULE: u32 = 1;
pub const CONFIG_NET_TCPPROBE_MODULE: u32 = 1;
pub const CONFIG_NCP_FS_MODULE: u32 = 1;
pub const CONFIG_XEN_GNTDEV_MODULE: u32 = 1;
pub const CONFIG_XZ_DEC_TEST_MODULE: u32 = 1;
pub const CONFIG_SENSORS_W83793_MODULE: u32 = 1;
pub const CONFIG_PI433_MODULE: u32 = 1;
pub const CONFIG_B43LEGACY_PIO: u32 = 1;
pub const CONFIG_LZO_DECOMPRESS: u32 = 1;
pub const CONFIG_USB_EHCI_ROOT_HUB_TT: u32 = 1;
pub const CONFIG_LIBERTAS_THINFIRM_MODULE: u32 = 1;
pub const CONFIG_IP_VS_PROTO_AH: u32 = 1;
pub const CONFIG_EXOFS_FS_MODULE: u32 = 1;
pub const CONFIG_IOMMU_SUPPORT: u32 = 1;
pub const CONFIG_HID_BELKIN_MODULE: u32 = 1;
pub const CONFIG_VIDEO_IR_I2C_MODULE: u32 = 1;
pub const CONFIG_ROMFS_BACKED_BY_BLOCK: u32 = 1;
pub const CONFIG_VFIO_IOMMU_TYPE1_MODULE: u32 = 1;
pub const CONFIG_DVB_STV0367_MODULE: u32 = 1;
pub const CONFIG_STMMAC_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_CAMERA_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OV2640_MODULE: u32 = 1;
pub const CONFIG_ISDN_TTY_FAX: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_862_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_CISCO: u32 = 1;
pub const CONFIG_CRAMFS_BLOCKDEV: u32 = 1;
pub const CONFIG_NFSD_MODULE: u32 = 1;
pub const CONFIG_ISDN_DRV_AVMB1_C4_MODULE: u32 = 1;
pub const CONFIG_SENSORS_TSL2550_MODULE: u32 = 1;
pub const CONFIG_ITG3200_MODULE: u32 = 1;
pub const CONFIG_COMPAT_BINFMT_ELF: u32 = 1;
pub const CONFIG_VFIO_PCI_MODULE: u32 = 1;
pub const CONFIG_PWM_LPSS_MODULE: u32 = 1;
pub const CONFIG_X86_DIRECT_GBPAGES: u32 = 1;
pub const CONFIG_VIDEO_IVTV_ALSA_MODULE: u32 = 1;
pub const CONFIG_PATA_MPIIX_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_OPTION_MODULE: u32 = 1;
pub const CONFIG_HID_ACRUX_MODULE: u32 = 1;
pub const CONFIG_RD_LZMA: u32 = 1;
pub const CONFIG_USB_GSPCA_SE401_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SALSA20_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_GEMINILAKE_MODULE: u32 = 1;
pub const CONFIG_USB: u32 = 1;
pub const CONFIG_PATA_SIL680_MODULE: u32 = 1;
pub const CONFIG_ACPI_IPMI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT5651_MODULE: u32 = 1;
pub const CONFIG_CHARGER_MAX8998_MODULE: u32 = 1;
pub const CONFIG_CHARGER_AXP20X_MODULE: u32 = 1;
pub const CONFIG_MMC_SDHCI_PCI_MODULE: u32 = 1;
pub const CONFIG_USB_SPEEDTOUCH_MODULE: u32 = 1;
pub const CONFIG_I2C_XILINX_MODULE: u32 = 1;
pub const CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK: u32 = 1;
pub const CONFIG_REGULATOR_88PM8607_MODULE: u32 = 1;
pub const CONFIG_ALIM7101_WDT_MODULE: u32 = 1;
pub const CONFIG_ACPI_PCI_SLOT: u32 = 1;
pub const CONFIG_PM_WAKELOCKS_GC: u32 = 1;
pub const CONFIG_NFC_MRVL_I2C_MODULE: u32 = 1;
pub const CONFIG_MODULES_USE_ELF_RELA: u32 = 1;
pub const CONFIG_AD5686_MODULE: u32 = 1;
pub const CONFIG_CALGARY_IOMMU_ENABLED_BY_DEFAULT: u32 = 1;
pub const CONFIG_SND_BCD2000_MODULE: u32 = 1;
pub const CONFIG_BTREE: u32 = 1;
pub const CONFIG_CRYPTO_HMAC: u32 = 1;
pub const CONFIG_WLAN_VENDOR_REALTEK: u32 = 1;
pub const CONFIG_BLK_WBT: u32 = 1;
pub const CONFIG_INPUT_ADXL34X_SPI_MODULE: u32 = 1;
pub const CONFIG_ETHERNET: u32 = 1;
pub const CONFIG_PATA_CMD640_PCI_MODULE: u32 = 1;
pub const CONFIG_KXSD9_SPI_MODULE: u32 = 1;
pub const CONFIG_VFIO_NOIOMMU: u32 = 1;
pub const CONFIG_NET_SCH_CODEL_MODULE: u32 = 1;
pub const CONFIG_JFFS2_LZO: u32 = 1;
pub const CONFIG_FRAMEBUFFER_CONSOLE_ROTATION: u32 = 1;
pub const CONFIG_NVME_TARGET_FC_MODULE: u32 = 1;
pub const CONFIG_INPUT_BMA150_MODULE: u32 = 1;
pub const CONFIG_USBIP_VHCI_HC_PORTS: u32 = 8;
pub const CONFIG_USB_GSPCA_JEILINJ_MODULE: u32 = 1;
pub const CONFIG_SCHED_OMIT_FRAME_POINTER: u32 = 1;
pub const CONFIG_HID_LOGITECH_HIDPP_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SHA3_MODULE: u32 = 1;
pub const CONFIG_RETU_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_BRANCH_PROFILE_NONE: u32 = 1;
pub const CONFIG_SCSI_SCAN_ASYNC: u32 = 1;
pub const CONFIG_SPI_DW_MMIO_MODULE: u32 = 1;
pub const CONFIG_CRC_ITU_T_MODULE: u32 = 1;
pub const CONFIG_NET_DROP_MONITOR_MODULE: u32 = 1;
pub const CONFIG_SND_HRTIMER_MODULE: u32 = 1;
pub const CONFIG_HAVE_DMA_CONTIGUOUS: u32 = 1;
pub const CONFIG_ALI_FIR_MODULE: u32 = 1;
pub const CONFIG_DQL: u32 = 1;
pub const CONFIG_RAPIDIO_DISC_TIMEOUT: u32 = 30;
pub const CONFIG_VXLAN_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_BROXTON_MODULE: u32 = 1;
pub const CONFIG_PARPORT_PC_PCMCIA_MODULE: u32 = 1;
pub const CONFIG_FRAMEBUFFER_CONSOLE: u32 = 1;
pub const CONFIG_NET_DCCPPROBE_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_PCM512x_I2C_MODULE: u32 = 1;
pub const CONFIG_RMI4_F55: u32 = 1;
pub const CONFIG_DM_ZERO_MODULE: u32 = 1;
pub const CONFIG_DVB_DIB8000_MODULE: u32 = 1;
pub const CONFIG_X86_SUPPORTS_MEMORY_FAILURE: u32 = 1;
pub const CONFIG_SND_SEQUENCER_MODULE: u32 = 1;
pub const CONFIG_TCP_CONG_LP_MODULE: u32 = 1;
pub const CONFIG_SONY_FF: u32 = 1;
pub const CONFIG_PINCTRL_BAYTRAIL: u32 = 1;
pub const CONFIG_INPUT_GP2A_MODULE: u32 = 1;
pub const CONFIG_AD5064_MODULE: u32 = 1;
pub const CONFIG_GAMEPORT_EMU10K1_MODULE: u32 = 1;
pub const CONFIG_SOCK_CGROUP_DATA: u32 = 1;
pub const CONFIG_WL1251_SPI_MODULE: u32 = 1;
pub const CONFIG_SND_BEBOB_MODULE: u32 = 1;
pub const CONFIG_COREDUMP: u32 = 1;
pub const CONFIG_NET_FOU_IP_TUNNELS: u32 = 1;
pub const CONFIG_USB_NET_GL620A_MODULE: u32 = 1;
pub const CONFIG_MICREL_KS8995MA_MODULE: u32 = 1;
pub const CONFIG_DVB_LGDT3306A_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADDI_APCI_1500_MODULE: u32 = 1;
pub const CONFIG_SND_OPL3_LIB_MODULE: u32 = 1;
pub const CONFIG_IP_NF_ARPTABLES_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_F_TCM: u32 = 1;
pub const CONFIG_REGULATOR_SKY81452_MODULE: u32 = 1;
pub const CONFIG_DVB_ASCOT2E_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_GP8PSK_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_GENERIC: u32 = 1;
pub const CONFIG_HID_CHERRY_MODULE: u32 = 1;
pub const CONFIG_PC87413_WDT_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_SH1106_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_IMX_AUDMUX_MODULE: u32 = 1;
pub const CONFIG_JFFS2_COMPRESSION_OPTIONS: u32 = 1;
pub const CONFIG_CM3323_MODULE: u32 = 1;
pub const CONFIG_BATTERY_MAX17040_MODULE: u32 = 1;
pub const CONFIG_USERIO_MODULE: u32 = 1;
pub const CONFIG_MKISS_MODULE: u32 = 1;
pub const CONFIG_USE_PERCPU_NUMA_NODE_ID: u32 = 1;
pub const CONFIG_NFT_FIB_MODULE: u32 = 1;
pub const CONFIG_HID_SUNPLUS_MODULE: u32 = 1;
pub const CONFIG_DRM_VMWGFX_FBCON: u32 = 1;
pub const CONFIG_INPUT_ADXL34X_MODULE: u32 = 1;
pub const CONFIG_KSZ884X_PCI_MODULE: u32 = 1;
pub const CONFIG_HID_PICOLCD_MODULE: u32 = 1;
pub const CONFIG_BCMA_POSSIBLE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_RNDIS: u32 = 1;
pub const CONFIG_NF_LOG_IPV4_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_SFB_MODULE: u32 = 1;
pub const CONFIG_LEDS_LP5521_MODULE: u32 = 1;
pub const CONFIG_FUSION_CTL_MODULE: u32 = 1;
pub const CONFIG_TULIP_MODULE: u32 = 1;
pub const CONFIG_FB_SM750_MODULE: u32 = 1;
pub const CONFIG_AF_RXRPC_MODULE: u32 = 1;
pub const CONFIG_CIFS_ACL: u32 = 1;
pub const CONFIG_ZRAM_MODULE: u32 = 1;
pub const CONFIG_XEN_SELFBALLOONING: u32 = 1;
pub const CONFIG_CRYPTO_CAST5_MODULE: u32 = 1;
pub const CONFIG_VGA_ARB: u32 = 1;
pub const CONFIG_FB_INTEL_I2C: u32 = 1;
pub const CONFIG_SENSORS_CORETEMP_MODULE: u32 = 1;
pub const CONFIG_PARIDE_FIT2_MODULE: u32 = 1;
pub const CONFIG_NF_TABLES_ARP_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ACPI_MODULE: u32 = 1;
pub const CONFIG_FB_CARMINE_DRAM_EVAL: u32 = 1;
pub const CONFIG_FB_NVIDIA_BACKLIGHT: u32 = 1;
pub const CONFIG_SND_SOC_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_MV88E6060_MODULE: u32 = 1;
pub const CONFIG_MAXIM_THERMOCOUPLE_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_TPS51632_MODULE: u32 = 1;
pub const CONFIG_FIREWIRE_SBP2_MODULE: u32 = 1;
pub const CONFIG_MFD_MAX77693: u32 = 1;
pub const CONFIG_SECURITY_TOMOYO_POLICY_LOADER: &'static [u8; 18usize] = b"/sbin/tomoyo-init\0";
pub const CONFIG_NET_IPGRE_DEMUX_MODULE: u32 = 1;
pub const CONFIG_COMEDI_MULTIQ3_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_XC5000_MODULE: u32 = 1;
pub const CONFIG_NET_POLL_CONTROLLER: u32 = 1;
pub const CONFIG_PRINTK: u32 = 1;
pub const CONFIG_NCPFS_EXTRAS: u32 = 1;
pub const CONFIG_SPEAKUP_SYNTH_BNS_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_USA28X: u32 = 1;
pub const CONFIG_6LOWPAN_NHC_ROUTING_MODULE: u32 = 1;
pub const CONFIG_SFC_MODULE: u32 = 1;
pub const CONFIG_PHANTOM_MODULE: u32 = 1;
pub const CONFIG_HTC_I2CPLD: u32 = 1;
pub const CONFIG_SERIAL_8250_FINTEK: u32 = 1;
pub const CONFIG_PINCTRL_CANNONLAKE: u32 = 1;
pub const CONFIG_BMC150_ACCEL_MODULE: u32 = 1;
pub const CONFIG_FORCEDETH_MODULE: u32 = 1;
pub const CONFIG_ACPI_LPIT: u32 = 1;
pub const CONFIG_COMEDI_DAS08_CS_MODULE: u32 = 1;
pub const CONFIG_FB_SYS_FILLRECT_MODULE: u32 = 1;
pub const CONFIG_TIMERFD: u32 = 1;
pub const CONFIG_SPI_AXI_SPI_ENGINE_MODULE: u32 = 1;
pub const CONFIG_HID_THRUSTMASTER_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_MCRYPTD_MODULE: u32 = 1;
pub const CONFIG_USB_DYNAMIC_MINORS: u32 = 1;
pub const CONFIG_SENSORS_MAX16065_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_CYTTSP_I2C_MODULE: u32 = 1;
pub const CONFIG_SECURITY_APPARMOR_STACKED: u32 = 1;
pub const CONFIG_SENSORS_I5K_AMB_MODULE: u32 = 1;
pub const CONFIG_DNS_RESOLVER: u32 = 1;
pub const CONFIG_B53_MMAP_DRIVER_MODULE: u32 = 1;
pub const CONFIG_ITCO_VENDOR_SUPPORT: u32 = 1;
pub const CONFIG_TRACEPOINTS: u32 = 1;
pub const CONFIG_B43_PHY_LP: u32 = 1;
pub const CONFIG_MTD_CFI_I2: u32 = 1;
pub const CONFIG_CRYPTO_AUTHENC_MODULE: u32 = 1;
pub const CONFIG_AT803X_PHY_MODULE: u32 = 1;
pub const CONFIG_DVB_SP8870_MODULE: u32 = 1;
pub const CONFIG_I6300ESB_WDT_MODULE: u32 = 1;
pub const CONFIG_GPIO_ML_IOH_MODULE: u32 = 1;
pub const CONFIG_YENTA_MODULE: u32 = 1;
pub const CONFIG_USB_GPIO_VBUS_MODULE: u32 = 1;
pub const CONFIG_W1_MASTER_DS2482_MODULE: u32 = 1;
pub const CONFIG_COMEDI_SERIAL2002_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_SIDEWINDER_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_SKD_MODULE: u32 = 1;
pub const CONFIG_NET_EMATCH_STACK: u32 = 32;
pub const CONFIG_SRF04_MODULE: u32 = 1;
pub const CONFIG_CARL9170_LEDS: u32 = 1;
pub const CONFIG_VIDEO_V4L2_SUBDEV_API: u32 = 1;
pub const CONFIG_ATL1E_MODULE: u32 = 1;
pub const CONFIG_USB_STORAGE_ENE_UB6250_MODULE: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_ACTIVITY_MODULE: u32 = 1;
pub const CONFIG_DVB_DDBRIDGE_MODULE: u32 = 1;
pub const CONFIG_NLS_MAC_CENTEURO_MODULE: u32 = 1;
pub const CONFIG_IRDA_MODULE: u32 = 1;
pub const CONFIG_BRCMFMAC_SDIO: u32 = 1;
pub const CONFIG_BOUNCE: u32 = 1;
pub const CONFIG_LEDS_DA903X_MODULE: u32 = 1;
pub const CONFIG_DWMAC_GENERIC_MODULE: u32 = 1;
pub const CONFIG_RDS_RDMA_MODULE: u32 = 1;
pub const CONFIG_AD5592R_MODULE: u32 = 1;
pub const CONFIG_NUMA_BALANCING: u32 = 1;
pub const CONFIG_I2C_DESIGNWARE_BAYTRAIL: u32 = 1;
pub const CONFIG_THINKPAD_ACPI_MODULE: u32 = 1;
pub const CONFIG_P54_COMMON_MODULE: u32 = 1;
pub const CONFIG_SECURITY_APPARMOR_HASH: u32 = 1;
pub const CONFIG_SHMEM: u32 = 1;
pub const CONFIG_ISDN_PPP: u32 = 1;
pub const CONFIG_MTD_MODULE: u32 = 1;
pub const CONFIG_MIGRATION: u32 = 1;
pub const CONFIG_HAVE_ARCH_JUMP_LABEL: u32 = 1;
pub const CONFIG_LEDS_PCA9532_GPIO: u32 = 1;
pub const CONFIG_COMEDI_C6XDIGIO_MODULE: u32 = 1;
pub const CONFIG_MMC_BLOCK_MINORS: u32 = 8;
pub const CONFIG_IIO_SSP_SENSORS_COMMONS_MODULE: u32 = 1;
pub const CONFIG_USB_HSO_MODULE: u32 = 1;
pub const CONFIG_HID_PRIMAX_MODULE: u32 = 1;
pub const CONFIG_DECOMPRESS_LZMA: u32 = 1;
pub const CONFIG_PCI_IOV: u32 = 1;
pub const CONFIG_WATCHDOG_SYSFS: u32 = 1;
pub const CONFIG_SENSORS_IIO_HWMON_MODULE: u32 = 1;
pub const CONFIG_HAVE_KVM_EVENTFD: u32 = 1;
pub const CONFIG_SND_SOC_WM8776_MODULE: u32 = 1;
pub const CONFIG_GPIO_VIPERBOARD_MODULE: u32 = 1;
pub const CONFIG_QED_LL2: u32 = 1;
pub const CONFIG_DEVTMPFS_MOUNT: u32 = 1;
pub const CONFIG_PM_DEVFREQ_EVENT: u32 = 1;
pub const CONFIG_SND_HDA_DSP_LOADER: u32 = 1;
pub const CONFIG_SENSORS_AMC6821_MODULE: u32 = 1;
pub const CONFIG_MFD_SI476X_CORE_MODULE: u32 = 1;
pub const CONFIG_USB_IPHETH_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_TI_AM335X_TSC_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_850_MODULE: u32 = 1;
pub const CONFIG_DVB_CX22700_MODULE: u32 = 1;
pub const CONFIG_DNOTIFY: u32 = 1;
pub const CONFIG_COMEDI_DAS800_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CTS: u32 = 1;
pub const CONFIG_KEYBOARD_LM8333_MODULE: u32 = 1;
pub const CONFIG_HISAX_TELES_CS_MODULE: u32 = 1;
pub const CONFIG_SND_USB_PODHD_MODULE: u32 = 1;
pub const CONFIG_EDD: u32 = 1;
pub const CONFIG_DVB_USB_UMT_010_MODULE: u32 = 1;
pub const CONFIG_SUNGEM_PHY_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_DB9_MODULE: u32 = 1;
pub const CONFIG_EFI_CUSTOM_SSDT_OVERLAYS: u32 = 1;
pub const CONFIG_IMA_TRUSTED_KEYRING: u32 = 1;
pub const CONFIG_RTC_DRV_R9701_MODULE: u32 = 1;
pub const CONFIG_NFC_S3FWRN5_I2C_MODULE: u32 = 1;
pub const CONFIG_SCSI_UFSHCD_MODULE: u32 = 1;
pub const CONFIG_INPUT_MOUSEDEV: u32 = 1;
pub const CONFIG_GENERIC_NET_UTILS: u32 = 1;
pub const CONFIG_IPV6_ILA_MODULE: u32 = 1;
pub const CONFIG_FB_RADEON_BACKLIGHT: u32 = 1;
pub const CONFIG_LIBERTAS_CS_MODULE: u32 = 1;
pub const CONFIG_USB_ISP1362_HCD_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MC13XXX_CORE_MODULE: u32 = 1;
pub const CONFIG_INPUT_WM831X_ON_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_EKTF2127_MODULE: u32 = 1;
pub const CONFIG_ATA: u32 = 1;
pub const CONFIG_KEYBOARD_SUNKBD_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS42XX8_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_PALMAS_MODULE: u32 = 1;
pub const CONFIG_SENSORS_TPS40422_MODULE: u32 = 1;
pub const CONFIG_GPIO_MAX730X_MODULE: u32 = 1;
pub const CONFIG_MFD_WM8994_MODULE: u32 = 1;
pub const CONFIG_PCMCIA_3C589_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DES_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_WM9712: u32 = 1;
pub const CONFIG_CEPH_LIB_MODULE: u32 = 1;
pub const CONFIG_REMOTEPROC_MODULE: u32 = 1;
pub const CONFIG_GPIO_LP3943_MODULE: u32 = 1;
pub const CONFIG_STM_MODULE: u32 = 1;
pub const CONFIG_HISAX_ELSA_CS_MODULE: u32 = 1;
pub const CONFIG_COMEDI_MF6X4_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_COMPRESS: u32 = 1;
pub const CONFIG_ND_BTT_MODULE: u32 = 1;
pub const CONFIG_XEN_MCE_LOG: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_437: u32 = 1;
pub const CONFIG_HAVE_ARCH_SOFT_DIRTY: u32 = 1;
pub const CONFIG_SND_SOC_INNO_RK3036_MODULE: u32 = 1;
pub const CONFIG_HYPERV_KEYBOARD_MODULE: u32 = 1;
pub const CONFIG_INTEL_TH_GTH_MODULE: u32 = 1;
pub const CONFIG_MCS_FIR_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_DA9052_MODULE: u32 = 1;
pub const CONFIG_NATSEMI_MODULE: u32 = 1;
pub const CONFIG_ARCH_PROC_KCORE_TEXT: u32 = 1;
pub const CONFIG_NET_CLS_U32_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_NETLINK_GLUE_CT: u32 = 1;
pub const CONFIG_MISDN_MODULE: u32 = 1;
pub const CONFIG_EXPORTFS: u32 = 1;
pub const CONFIG_MTD_UBI_WL_THRESHOLD: u32 = 4096;
pub const CONFIG_BMC150_MAGN_I2C_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_WATTEROTT_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_MAX8907_MODULE: u32 = 1;
pub const CONFIG_AD525X_DPOT_I2C_MODULE: u32 = 1;
pub const CONFIG_MMC_RICOH_MMC: u32 = 1;
pub const CONFIG_HID_SENSOR_HUB_MODULE: u32 = 1;
pub const CONFIG_SND_MIXER_OSS_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_PENMOUNT_MODULE: u32 = 1;
pub const CONFIG_IP6_NF_MATCH_MH_MODULE: u32 = 1;
pub const CONFIG_NFT_EXTHDR_MODULE: u32 = 1;
pub const CONFIG_NET_INGRESS: u32 = 1;
pub const CONFIG_FB_TFT_ST7789V_MODULE: u32 = 1;
pub const CONFIG_SCSI_OSD_INITIATOR_MODULE: u32 = 1;
pub const CONFIG_VIDEO_ZORAN_DC30_MODULE: u32 = 1;
pub const CONFIG_DVB_S921_MODULE: u32 = 1;
pub const CONFIG_SCSI_OSD_DPRINT_SENSE: u32 = 1;
pub const CONFIG_MSI_WMI_MODULE: u32 = 1;
pub const CONFIG_IT87_WDT_MODULE: u32 = 1;
pub const CONFIG_LRU_CACHE_MODULE: u32 = 1;
pub const CONFIG_SCSI_CXGB3_ISCSI_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_LP3972_MODULE: u32 = 1;
pub const CONFIG_SND_DARLA24_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX1619_MODULE: u32 = 1;
pub const CONFIG_IPW2200_MONITOR: u32 = 1;
pub const CONFIG_CRYPTO_SHA256_MB_MODULE: u32 = 1;
pub const CONFIG_DVB_AF9013_MODULE: u32 = 1;
pub const CONFIG_PCMCIA_SYM53C500_MODULE: u32 = 1;
pub const CONFIG_OLD_SIGSUSPEND3: u32 = 1;
pub const CONFIG_SERIO: u32 = 1;
pub const CONFIG_DVB_USB_DTV5100_MODULE: u32 = 1;
pub const CONFIG_SCHEDSTATS: u32 = 1;
pub const CONFIG_TYPEC_UCSI_MODULE: u32 = 1;
pub const CONFIG_IBMASR_MODULE: u32 = 1;
pub const CONFIG_INPUT_MOUSE: u32 = 1;
pub const CONFIG_RTLWIFI_PCI_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_ISER_MODULE: u32 = 1;
pub const CONFIG_HOTPLUG_SMT: u32 = 1;
pub const CONFIG_FB_SYS_IMAGEBLIT_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TVEEPROM_MODULE: u32 = 1;
pub const CONFIG_X86: u32 = 1;
pub const CONFIG_PPS_CLIENT_PARPORT_MODULE: u32 = 1;
pub const CONFIG_DEFXX_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_SG_CHAIN: u32 = 1;
pub const CONFIG_SUNRPC_GSS_MODULE: u32 = 1;
pub const CONFIG_HID_LED_MODULE: u32 = 1;
pub const CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS: u32 = 1;
pub const CONFIG_TYPHOON_MODULE: u32 = 1;
pub const CONFIG_TIGON3_MODULE: u32 = 1;
pub const CONFIG_MA600_DONGLE_MODULE: u32 = 1;
pub const CONFIG_THUNDERBOLT_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CAST5_AVX_X86_64_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LM90_MODULE: u32 = 1;
pub const CONFIG_NETCONSOLE_MODULE: u32 = 1;
pub const CONFIG_RTC_INTF_SYSFS: u32 = 1;
pub const CONFIG_CHARGER_BQ24257_MODULE: u32 = 1;
pub const CONFIG_MMC_SDHCI_ACPI_MODULE: u32 = 1;
pub const CONFIG_BCMA_DRIVER_GPIO: u32 = 1;
pub const CONFIG_SND_SOC_SPDIF_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_RS5C372_MODULE: u32 = 1;
pub const CONFIG_QED_MODULE: u32 = 1;
pub const CONFIG_NET_EMATCH_U32_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_TOUCHWIN_MODULE: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_COMMON: u32 = 1;
pub const CONFIG_BLK_DEV_INITRD: u32 = 1;
pub const CONFIG_USB_EMI62_MODULE: u32 = 1;
pub const CONFIG_B43_PHY_N: u32 = 1;
pub const CONFIG_SCSI_IPS_MODULE: u32 = 1;
pub const CONFIG_ARCH_ENABLE_MEMORY_HOTREMOVE: u32 = 1;
pub const CONFIG_X86_MCE_AMD: u32 = 1;
pub const CONFIG_DM_BUFIO_MODULE: u32 = 1;
pub const CONFIG_I2C_ALGOPCA_MODULE: u32 = 1;
pub const CONFIG_CAN_GS_USB_MODULE: u32 = 1;
pub const CONFIG_BT_ATH3K_MODULE: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_TIMER_MODULE: u32 = 1;
pub const CONFIG_MCB_PCI_MODULE: u32 = 1;
pub const CONFIG_DRM_VIRTIO_GPU_MODULE: u32 = 1;
pub const CONFIG_COMMON_CLK_PALMAS_MODULE: u32 = 1;
pub const CONFIG_FSI_MASTER_HUB_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_M48T59_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8510_MODULE: u32 = 1;
pub const CONFIG_RT2800_LIB_MODULE: u32 = 1;
pub const CONFIG_EXTCON_ADC_JACK_MODULE: u32 = 1;
pub const CONFIG_DELL_WMI_LED_MODULE: u32 = 1;
pub const CONFIG_X86_X2APIC: u32 = 1;
pub const CONFIG_SND_SOC_TLV320AIC3X_MODULE: u32 = 1;
pub const CONFIG_FB_VESA: u32 = 1;
pub const CONFIG_DEFAULT_SECURITY_APPARMOR: u32 = 1;
pub const CONFIG_NFS_DEBUG: u32 = 1;
pub const CONFIG_CRYPTO_BLOWFISH_COMMON_MODULE: u32 = 1;
pub const CONFIG_USB_RAREMONO_MODULE: u32 = 1;
pub const CONFIG_BT_INTEL_MODULE: u32 = 1;
pub const CONFIG_CRC4_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_WM831X_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_TPS65090_MODULE: u32 = 1;
pub const CONFIG_FUSION_LAN_MODULE: u32 = 1;
pub const CONFIG_DRM_BOCHS_MODULE: u32 = 1;
pub const CONFIG_MTD_NAND_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_DW2102_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DRBG_HASH: u32 = 1;
pub const CONFIG_PATA_PCMCIA_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_SANE_MODULE: u32 = 1;
pub const CONFIG_SERIO_PARKBD_MODULE: u32 = 1;
pub const CONFIG_GPIO_PCF857X_MODULE: u32 = 1;
pub const CONFIG_SND_OSSEMUL: u32 = 1;
pub const CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL_MODULE: u32 = 1;
pub const CONFIG_ARCH_CLOCKSOURCE_DATA: u32 = 1;
pub const CONFIG_BACKLIGHT_SAHARA_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_TSC2004_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ADAU_UTILS_MODULE: u32 = 1;
pub const CONFIG_IPMI_PROC_INTERFACE: u32 = 1;
pub const CONFIG_TOIM3232_DONGLE_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_SURFACE3_SPI_MODULE: u32 = 1;
pub const CONFIG_IBM_RTL_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_MOS7720_MODULE: u32 = 1;
pub const CONFIG_XILLYBUS_MODULE: u32 = 1;
pub const CONFIG_SERIAL_DEV_BUS: u32 = 1;
pub const CONFIG_PREEMPT_NOTIFIERS: u32 = 1;
pub const CONFIG_NET_DSA_TAG_EDSA: u32 = 1;
pub const CONFIG_XEN_PVHVM: u32 = 1;
pub const CONFIG_FB_ARC_MODULE: u32 = 1;
pub const CONFIG_NF_CT_PROTO_DCCP: u32 = 1;
pub const CONFIG_ZLIB_INFLATE: u32 = 1;
pub const CONFIG_USB_FUNCTIONFS_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_V3020_MODULE: u32 = 1;
pub const CONFIG_HISAX_AVM_A1_CS_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_SYNOPSYS: u32 = 1;
pub const CONFIG_DVB_TUA6100_MODULE: u32 = 1;
pub const CONFIG_SENSORS_SHTC1_MODULE: u32 = 1;
pub const CONFIG_KVM_ASYNC_PF: u32 = 1;
pub const CONFIG_BMP280_MODULE: u32 = 1;
pub const CONFIG_CRC_T10DIF: u32 = 1;
pub const CONFIG_BT_HCIBTUART_MODULE: u32 = 1;
pub const CONFIG_EXTCON_USBC_CROS_EC_MODULE: u32 = 1;
pub const CONFIG_AD7746_MODULE: u32 = 1;
pub const CONFIG_MMA8452_MODULE: u32 = 1;
pub const CONFIG_THERMAL_GOV_FAIR_SHARE: u32 = 1;
pub const CONFIG_ENCRYPTED_KEYS: u32 = 1;
pub const CONFIG_MEDIA_TUNER_QT1010_MODULE: u32 = 1;
pub const CONFIG_DVB_DYNAMIC_MINORS: u32 = 1;
pub const CONFIG_BCH_CONST_T: u32 = 4;
pub const CONFIG_GPIO_WM831X_MODULE: u32 = 1;
pub const CONFIG_SSB_PCIHOST_POSSIBLE: u32 = 1;
pub const CONFIG_LCD_LMS283GF05_MODULE: u32 = 1;
pub const CONFIG_DRM_AMD_DC_PRE_VEGA: u32 = 1;
pub const CONFIG_HWMON: u32 = 1;
pub const CONFIG_AD5791_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_NAU8824_MODULE: u32 = 1;
pub const CONFIG_INTEL_GTT: u32 = 1;
pub const CONFIG_RTC_DRV_PCF85063_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_DLINK: u32 = 1;
pub const CONFIG_CRYPTO_TWOFISH_COMMON_MODULE: u32 = 1;
pub const CONFIG_DLCI_MAX: u32 = 8;
pub const CONFIG_AUDITSYSCALL: u32 = 1;
pub const CONFIG_BT_HCIUART_3WIRE: u32 = 1;
pub const CONFIG_USB_PHY: u32 = 1;
pub const CONFIG_MANAGER_SBS_MODULE: u32 = 1;
pub const CONFIG_X86_ACPI_CPUFREQ_CPB: u32 = 1;
pub const CONFIG_NLS_ISO8859_2_MODULE: u32 = 1;
pub const CONFIG_MFD_DA9052_I2C: u32 = 1;
pub const CONFIG_QEDE_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LM63_MODULE: u32 = 1;
pub const CONFIG_RC_DEVICES: u32 = 1;
pub const CONFIG_CRYPTO_CRC32_PCLMUL_MODULE: u32 = 1;
pub const CONFIG_USB_VIDEO_CLASS_MODULE: u32 = 1;
pub const CONFIG_EXTCON_INTEL_CHT_WC_MODULE: u32 = 1;
pub const CONFIG_CLKBLD_I8253: u32 = 1;
pub const CONFIG_ATM_NICSTAR_MODULE: u32 = 1;
pub const CONFIG_MCP4131_MODULE: u32 = 1;
pub const CONFIG_FB_ATY_GX: u32 = 1;
pub const CONFIG_RTC_INTF_PROC: u32 = 1;
pub const CONFIG_HID_PICOLCD_FB: u32 = 1;
pub const CONFIG_USB_SERIAL_TI_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_CBQ_MODULE: u32 = 1;
pub const CONFIG_VIDEO_VP27SMPX_MODULE: u32 = 1;
pub const CONFIG_PM_CLK: u32 = 1;
pub const CONFIG_USB_CONFIGFS_F_HID: u32 = 1;
pub const CONFIG_ARCH_USE_BUILTIN_BSWAP: u32 = 1;
pub const CONFIG_UNISYS_VISORHBA_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LTC2990_MODULE: u32 = 1;
pub const CONFIG_PERF_EVENTS_INTEL_RAPL_MODULE: u32 = 1;
pub const CONFIG_USB_DWC2_PCI_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_MOS7715_PARPORT: u32 = 1;
pub const CONFIG_CRYPTO_SERPENT_MODULE: u32 = 1;
pub const CONFIG_DVB_SI2168_MODULE: u32 = 1;
pub const CONFIG_CPU_IDLE_GOV_MENU: u32 = 1;
pub const CONFIG_ARCH_HAS_UBSAN_SANITIZE_ALL: u32 = 1;
pub const CONFIG_USB_EHSET_TEST_FIXTURE_MODULE: u32 = 1;
pub const CONFIG_MTD_PCI_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_TINYLCD_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_LPSS_MODULE: u32 = 1;
pub const CONFIG_ACPI_FAN: u32 = 1;
pub const CONFIG_SND_FM801_MODULE: u32 = 1;
pub const CONFIG_MOUSE_PS2_SENTELIC: u32 = 1;
pub const CONFIG_HYSDN_CAPI: u32 = 1;
pub const CONFIG_FB_FLEX_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_MAX8925_MODULE: u32 = 1;
pub const CONFIG_FB_MATROX_MYSTIQUE: u32 = 1;
pub const CONFIG_VIDEO_CS5345_MODULE: u32 = 1;
pub const CONFIG_SECURITY_APPARMOR: u32 = 1;
pub const CONFIG_RTC_DRV_RX8010_MODULE: u32 = 1;
pub const CONFIG_DP83867_PHY_MODULE: u32 = 1;
pub const CONFIG_STACKTRACE_SUPPORT: u32 = 1;
pub const CONFIG_B44_PCI_AUTOSELECT: u32 = 1;
pub const CONFIG_DVB_USB_AF9035_MODULE: u32 = 1;
pub const CONFIG_COMEDI_AMPLC_PCI224_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_TIO_MODULE: u32 = 1;
pub const CONFIG_MFD_TI_LP873X_MODULE: u32 = 1;
pub const CONFIG_SERIAL_MAX3100_MODULE: u32 = 1;
pub const CONFIG_LEDS_LP8788_MODULE: u32 = 1;
pub const CONFIG_SENSORS_EMC1403_MODULE: u32 = 1;
pub const CONFIG_MLXFW_MODULE: u32 = 1;
pub const CONFIG_RESET_CONTROLLER: u32 = 1;
pub const CONFIG_BNA_MODULE: u32 = 1;
pub const CONFIG_MAXSMP: u32 = 1;
pub const CONFIG_OUTPUT_FORMAT: &'static [u8; 13usize] = b"elf64-x86-64\0";
pub const CONFIG_I2C_MUX_LTC4306_MODULE: u32 = 1;
pub const CONFIG_VIDEO_M52790_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_AES_TI_MODULE: u32 = 1;
pub const CONFIG_ACPI: u32 = 1;
pub const CONFIG_HTS221_SPI_MODULE: u32 = 1;
pub const CONFIG_SCSI_SYM53C8XX_2_MODULE: u32 = 1;
pub const CONFIG_SCSI_CXGB4_ISCSI_MODULE: u32 = 1;
pub const CONFIG_TABLET_USB_PEGASUS_MODULE: u32 = 1;
pub const CONFIG_IP_SET_HASH_IPMAC_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_HX8340BN_MODULE: u32 = 1;
pub const CONFIG_SENSORS_SHT15_MODULE: u32 = 1;
pub const CONFIG_USB_UHCI_HCD: u32 = 1;
pub const CONFIG_NVRAM_MODULE: u32 = 1;
pub const CONFIG_USB_ISP1760_MODULE: u32 = 1;
pub const CONFIG_CHARGER_BQ24735_MODULE: u32 = 1;
pub const CONFIG_LOCKD_MODULE: u32 = 1;
pub const CONFIG_LEDS_INTEL_SS4200_MODULE: u32 = 1;
pub const CONFIG_DRM_KMS_FB_HELPER: u32 = 1;
pub const CONFIG_USB_F_FS_MODULE: u32 = 1;
pub const CONFIG_USB_CHIPIDEA_UDC: u32 = 1;
pub const CONFIG_DVB_FIREDTV_MODULE: u32 = 1;
pub const CONFIG_DVB_S5H1411_MODULE: u32 = 1;
pub const CONFIG_NF_CT_NETLINK_TIMEOUT_MODULE: u32 = 1;
pub const CONFIG_ARCH_MIGHT_HAVE_ACPI_PDC: u32 = 1;
pub const CONFIG_SOUND_OSS_CORE: u32 = 1;
pub const CONFIG_PCIE_DW_HOST: u32 = 1;
pub const CONFIG_AIC79XX_REG_PRETTY_PRINT: u32 = 1;
pub const CONFIG_HFSPLUS_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_TI_ADC0832_MODULE: u32 = 1;
pub const CONFIG_RT2800USB_RT35XX: u32 = 1;
pub const CONFIG_FB_SAVAGE_MODULE: u32 = 1;
pub const CONFIG_LIBERTAS_MODULE: u32 = 1;
pub const CONFIG_HPET_MMAP: u32 = 1;
pub const CONFIG_WLAN_VENDOR_RALINK: u32 = 1;
pub const CONFIG_NTB_PINGPONG_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_TV8532_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_KPP2: u32 = 1;
pub const CONFIG_IO_DELAY_0XED: u32 = 1;
pub const CONFIG_LTE_GDM724X_MODULE: u32 = 1;
pub const CONFIG_DRM_VMWGFX_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_MICROCHIP: u32 = 1;
pub const CONFIG_JFFS2_FS_MODULE: u32 = 1;
pub const CONFIG_STE10XP_MODULE: u32 = 1;
pub const CONFIG_NFT_REJECT_IPV6_MODULE: u32 = 1;
pub const CONFIG_HID_SAITEK_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8750_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_MT6397_MODULE: u32 = 1;
pub const CONFIG_CASSINI_MODULE: u32 = 1;
pub const CONFIG_USB_WHCI_HCD_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT5660_MODULE: u32 = 1;
pub const CONFIG_SCSI_DH_ALUA_MODULE: u32 = 1;
pub const CONFIG_KEXEC_VERIFY_SIG: u32 = 1;
pub const CONFIG_MTRR: u32 = 1;
pub const CONFIG_USB_G_NCM_MODULE: u32 = 1;
pub const CONFIG_ADIS16203_MODULE: u32 = 1;
pub const CONFIG_MFD_MC13XXX_I2C_MODULE: u32 = 1;
pub const CONFIG_BT_RFCOMM_TTY: u32 = 1;
pub const CONFIG_LIBFCOE_MODULE: u32 = 1;
pub const CONFIG_NET_UDP_TUNNEL_MODULE: u32 = 1;
pub const CONFIG_INTEGRITY_SIGNATURE: u32 = 1;
pub const CONFIG_INPUT_MAX8997_HAPTIC_MODULE: u32 = 1;
pub const CONFIG_RPCSEC_GSS_KRB5_MODULE: u32 = 1;
pub const CONFIG_SCSI_EATA_LINKED_COMMANDS: u32 = 1;
pub const CONFIG_VIDEOBUF_VMALLOC_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_LP8788_MODULE: u32 = 1;
pub const CONFIG_MTD_CFI_UTIL_MODULE: u32 = 1;
pub const CONFIG_NO_HZ_IDLE: u32 = 1;
pub const CONFIG_USB_ISP1761_UDC: u32 = 1;
pub const CONFIG_SND_SOC_CS4271_I2C_MODULE: u32 = 1;
pub const CONFIG_NLS_MAC_ROMANIAN_MODULE: u32 = 1;
pub const CONFIG_SND_LX6464ES_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_ADAPTEC: u32 = 1;
pub const CONFIG_CFG80211_REQUIRE_SIGNED_REGDB: u32 = 1;
pub const CONFIG_SENSORS_PCF8591_MODULE: u32 = 1;
pub const CONFIG_DVB_STV0299_MODULE: u32 = 1;
pub const CONFIG_IIO_CROS_EC_ACCEL_LEGACY_MODULE: u32 = 1;
pub const CONFIG_MOUSE_PS2_BYD: u32 = 1;
pub const CONFIG_IPW2200_RADIOTAP: u32 = 1;
pub const CONFIG_SSB_B43_PCI_BRIDGE: u32 = 1;
pub const CONFIG_ACER_WMI_MODULE: u32 = 1;
pub const CONFIG_KXSD9_MODULE: u32 = 1;
pub const CONFIG_CHARGER_TWL4030_MODULE: u32 = 1;
pub const CONFIG_USB_AN2720: u32 = 1;
pub const CONFIG_F2FS_STAT_FS: u32 = 1;
pub const CONFIG_SENSORS_UCD9200_MODULE: u32 = 1;
pub const CONFIG_MIC_COSM_MODULE: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING: u32 = 1;
pub const CONFIG_EXTCON_INTEL_INT3496_MODULE: u32 = 1;
pub const CONFIG_MLX4_DEBUG: u32 = 1;
pub const CONFIG_BSD_PROCESS_ACCT: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_STRING_MODULE: u32 = 1;
pub const CONFIG_SSB_DRIVER_PCICORE: u32 = 1;
pub const CONFIG_INPUT_TABLET: u32 = 1;
pub const CONFIG_MOSTCORE_MODULE: u32 = 1;
pub const CONFIG_88EU_AP_MODE: u32 = 1;
pub const CONFIG_HID_SENSOR_IIO_TRIGGER_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_MAX2165_MODULE: u32 = 1;
pub const CONFIG_MDIO_MODULE: u32 = 1;
pub const CONFIG_N_HDLC_MODULE: u32 = 1;
pub const CONFIG_MTD_CFI_INTELEXT_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DRBG_HMAC: u32 = 1;
pub const CONFIG_ATM_LANAI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_GTM601_MODULE: u32 = 1;
pub const CONFIG_DRM_BRIDGE: u32 = 1;
pub const CONFIG_LLC2_MODULE: u32 = 1;
pub const CONFIG_IR_WINBOND_CIR_MODULE: u32 = 1;
pub const CONFIG_HPET_EMULATE_RTC: u32 = 1;
pub const CONFIG_USB_F_SERIAL_MODULE: u32 = 1;
pub const CONFIG_X86_MPPARSE: u32 = 1;
pub const CONFIG_BNXT_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_SILAN: u32 = 1;
pub const CONFIG_SENSORS_UCD9000_MODULE: u32 = 1;
pub const CONFIG_SND_OXYGEN_LIB_MODULE: u32 = 1;
pub const CONFIG_US5182D_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_MAX98357A_MODULE: u32 = 1;
pub const CONFIG_DLM_MODULE: u32 = 1;
pub const CONFIG_SERIAL_ARC_MODULE: u32 = 1;
pub const CONFIG_STK8312_MODULE: u32 = 1;
pub const CONFIG_DRM_ANALOGIX_ANX78XX_MODULE: u32 = 1;
pub const CONFIG_CAN_CC770_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_BPF_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_GOTOP: u32 = 1;
pub const CONFIG_EEEPC_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_MIGRATE_VMA_HELPER: u32 = 1;
pub const CONFIG_HID_ACCUTOUCH_MODULE: u32 = 1;
pub const CONFIG_BT_6LOWPAN_MODULE: u32 = 1;
pub const CONFIG_USB_STORAGE_MODULE: u32 = 1;
pub const CONFIG_GPIO_LP873X_MODULE: u32 = 1;
pub const CONFIG_MAG3110_MODULE: u32 = 1;
pub const CONFIG_HMC6352_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_BROADCOM: u32 = 1;
pub const CONFIG_SERIAL_FSL_LPUART_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_PCTV452E_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_PSXPAD_SPI_FF: u32 = 1;
pub const CONFIG_DVB_VES1820_MODULE: u32 = 1;
pub const CONFIG_GENERIC_CPU_AUTOPROBE: u32 = 1;
pub const CONFIG_BAYCOM_SER_HDX_MODULE: u32 = 1;
pub const CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE: u32 = 1;
pub const CONFIG_CRYPTO_SEED_MODULE: u32 = 1;
pub const CONFIG_SCHED_MC: u32 = 1;
pub const CONFIG_DELL_RBU_MODULE: u32 = 1;
pub const CONFIG_ALTERA_MBOX_MODULE: u32 = 1;
pub const CONFIG_SCSI_SAS_ATA: u32 = 1;
pub const CONFIG_AD7266_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_LABPC_PCI_MODULE: u32 = 1;
pub const CONFIG_SECONDARY_TRUSTED_KEYRING: u32 = 1;
pub const CONFIG_BATTERY_DS2782_MODULE: u32 = 1;
pub const CONFIG_DEV_DAX_PMEM_MODULE: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_PERFORMANCE: u32 = 1;
pub const CONFIG_IR_LIRC_CODEC_MODULE: u32 = 1;
pub const CONFIG_GPIO_ICH_MODULE: u32 = 1;
pub const CONFIG_EFI: u32 = 1;
pub const CONFIG_RATIONAL: u32 = 1;
pub const CONFIG_I2C_MUX_MODULE: u32 = 1;
pub const CONFIG_LMP91000_MODULE: u32 = 1;
pub const CONFIG_DONGLE: u32 = 1;
pub const CONFIG_NVME_TARGET_LOOP_MODULE: u32 = 1;
pub const CONFIG_SATA_MV_MODULE: u32 = 1;
pub const CONFIG_DVB_TS2020_MODULE: u32 = 1;
pub const CONFIG_AGP_AMD64: u32 = 1;
pub const CONFIG_WLAN_VENDOR_INTEL: u32 = 1;
pub const CONFIG_HAVE_SETUP_PER_CPU_AREA: u32 = 1;
pub const CONFIG_TI_DAC082S085_MODULE: u32 = 1;
pub const CONFIG_CHARGER_ISP1704_MODULE: u32 = 1;
pub const CONFIG_DRM_I915_USERPTR: u32 = 1;
pub const CONFIG_SPI_SLAVE_TIME_MODULE: u32 = 1;
pub const CONFIG_SYSTEM_TRUSTED_KEYRING: u32 = 1;
pub const CONFIG_MEDIA_TUNER_QM1D1C0042_MODULE: u32 = 1;
pub const CONFIG_WATCHDOG_CORE: u32 = 1;
pub const CONFIG_SND_SOC_FSL_SPDIF_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_SIMPLE_MODULE: u32 = 1;
pub const CONFIG_GENERIC_EARLY_IOREMAP: u32 = 1;
pub const CONFIG_DVB_TUNER_DIB0090_MODULE: u32 = 1;
pub const CONFIG_PCI_XEN: u32 = 1;
pub const CONFIG_SND_USB_AUDIO_MODULE: u32 = 1;
pub const CONFIG_LCD_AMS369FG06_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_EGALAX_SERIAL_MODULE: u32 = 1;
pub const CONFIG_IEEE802154_ATUSB_MODULE: u32 = 1;
pub const CONFIG_ARCNET_CAP_MODULE: u32 = 1;
pub const CONFIG_VIDEO_ZORAN_ZR36060_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX231XX_MODULE: u32 = 1;
pub const CONFIG_SPEAKUP_SYNTH_TXPRT_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX31790_MODULE: u32 = 1;
pub const CONFIG_X25_MODULE: u32 = 1;
pub const CONFIG_NET_L3_MASTER_DEV: u32 = 1;
pub const CONFIG_HID_SENSOR_INCLINOMETER_3D_MODULE: u32 = 1;
pub const CONFIG_SENSORS_FTSTEUTATES_MODULE: u32 = 1;
pub const CONFIG_TCP_CONG_YEAH_MODULE: u32 = 1;
pub const CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE: u32 = 1;
pub const CONFIG_IEEE802154_MODULE: u32 = 1;
pub const CONFIG_DA9063_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_HID_SENSOR_CUSTOM_SENSOR_MODULE: u32 = 1;
pub const CONFIG_SCSI_QLA_FC_MODULE: u32 = 1;
pub const CONFIG_VMAP_STACK: u32 = 1;
pub const CONFIG_TELCLOCK_MODULE: u32 = 1;
pub const CONFIG_I40EVF_MODULE: u32 = 1;
pub const CONFIG_COMEDI_AMPLC_PC263_ISA_MODULE: u32 = 1;
pub const CONFIG_BMG160_SPI_MODULE: u32 = 1;
pub const CONFIG_IO_DELAY_TYPE_0XED: u32 = 1;
pub const CONFIG_BLOCK: u32 = 1;
pub const CONFIG_HAVE_IDE: u32 = 1;
pub const CONFIG_IP_VS_LC_MODULE: u32 = 1;
pub const CONFIG_USB_DWC3_PCI_MODULE: u32 = 1;
pub const CONFIG_HID_APPLE_MODULE: u32 = 1;
pub const CONFIG_BNXT_FLOWER_OFFLOAD: u32 = 1;
pub const CONFIG_CRYPTO_SERPENT_AVX2_X86_64_MODULE: u32 = 1;
pub const CONFIG_STREAM_PARSER: u32 = 1;
pub const CONFIG_MEDIA_TUNER_TDA827X_MODULE: u32 = 1;
pub const CONFIG_VMXNET3_MODULE: u32 = 1;
pub const CONFIG_INIT_ENV_ARG_LIMIT: u32 = 32;
pub const CONFIG_IP_NF_ARP_MANGLE_MODULE: u32 = 1;
pub const CONFIG_USB_WUSB_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_SSD1306_MODULE: u32 = 1;
pub const CONFIG_P54_LEDS: u32 = 1;
pub const CONFIG_RTC_DRV_88PM860X_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX34440_MODULE: u32 = 1;
pub const CONFIG_SENSORS_G760A_MODULE: u32 = 1;
pub const CONFIG_RDS_MODULE: u32 = 1;
pub const CONFIG_AK09911_MODULE: u32 = 1;
pub const CONFIG_DVB_ATBM8830_MODULE: u32 = 1;
pub const CONFIG_PATA_EFAR_MODULE: u32 = 1;
pub const CONFIG_PCI_ENDPOINT_CONFIGFS: u32 = 1;
pub const CONFIG_HOLTEK_FF: u32 = 1;
pub const CONFIG_NOUVEAU_LEGACY_CTX_SUPPORT: u32 = 1;
pub const CONFIG_EEPROM_93XX46_MODULE: u32 = 1;
pub const CONFIG_CC_STACKPROTECTOR_STRONG: u32 = 1;
pub const CONFIG_COMEDI_DYNA_PCI10XX_MODULE: u32 = 1;
pub const CONFIG_ATL2_MODULE: u32 = 1;
pub const CONFIG_USER_NS: u32 = 1;
pub const CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH: u32 = 1;
pub const CONFIG_CRYPTO_USER_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_PPTP_MODULE: u32 = 1;
pub const CONFIG_CPU_SUP_INTEL: u32 = 1;
pub const CONFIG_TCP_CONG_CDG_MODULE: u32 = 1;
pub const CONFIG_DVB_ZL10036_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX231XX_ALSA_MODULE: u32 = 1;
pub const CONFIG_CHARGER_DA9150_MODULE: u32 = 1;
pub const CONFIG_HFSPLUS_FS_MODULE: u32 = 1;
pub const CONFIG_TMPFS_POSIX_ACL: u32 = 1;
pub const CONFIG_STRICT_KERNEL_RWX: u32 = 1;
pub const CONFIG_SENSORS_ADM9240_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CAFE_CCIC_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SKL_RT286_MACH_MODULE: u32 = 1;
pub const CONFIG_SND_USB_UA101_MODULE: u32 = 1;
pub const CONFIG_ACPI_APEI_PCIEAER: u32 = 1;
pub const CONFIG_TOUCHSCREEN_CYTTSP_CORE_MODULE: u32 = 1;
pub const CONFIG_NETLINK_DIAG_MODULE: u32 = 1;
pub const CONFIG_CAN_IFI_CANFD_MODULE: u32 = 1;
pub const CONFIG_BUG: u32 = 1;
pub const CONFIG_KS0108_PORT: u32 = 888;
pub const CONFIG_SCSI_AIC7XXX_MODULE: u32 = 1;
pub const CONFIG_CONTEXT_SWITCH_TRACER: u32 = 1;
pub const CONFIG_MAC80211_HAS_RC: u32 = 1;
pub const CONFIG_BATMAN_ADV_BLA: u32 = 1;
pub const CONFIG_KDB_KEYBOARD: u32 = 1;
pub const CONFIG_SND_SOC_SSM2602_SPI_MODULE: u32 = 1;
pub const CONFIG_LOGIWHEELS_FF: u32 = 1;
pub const CONFIG_SENSORS_INA209_MODULE: u32 = 1;
pub const CONFIG_USB_SL811_HCD_MODULE: u32 = 1;
pub const CONFIG_OCFS2_FS_O2CB_MODULE: u32 = 1;
pub const CONFIG_MDIO_GPIO_MODULE: u32 = 1;
pub const CONFIG_XEN: u32 = 1;
pub const CONFIG_CRYPTO_CAST6_MODULE: u32 = 1;
pub const CONFIG_6LOWPAN_NHC_UDP_MODULE: u32 = 1;
pub const CONFIG_NET_EMATCH_META_MODULE: u32 = 1;
pub const CONFIG_FB_AUO_K1901_MODULE: u32 = 1;
pub const CONFIG_KS8842_MODULE: u32 = 1;
pub const CONFIG_SCSI_IPR_DUMP: u32 = 1;
pub const CONFIG_W1_MASTER_DS1WM_MODULE: u32 = 1;
pub const CONFIG_I40E_DCB: u32 = 1;
pub const CONFIG_GREYBUS_LIGHT_MODULE: u32 = 1;
pub const CONFIG_PANTHERLORD_FF: u32 = 1;
pub const CONFIG_I2C_DIOLAN_U2C_MODULE: u32 = 1;
pub const CONFIG_PM: u32 = 1;
pub const CONFIG_SND_CS46XX_NEW_DSP: u32 = 1;
pub const CONFIG_CAIF_HSI_MODULE: u32 = 1;
pub const CONFIG_MXC6255_MODULE: u32 = 1;
pub const CONFIG_PPS_MODULE: u32 = 1;
pub const CONFIG_FB_RIVA_BACKLIGHT: u32 = 1;
pub const CONFIG_GENERIC_ISA_DMA: u32 = 1;
pub const CONFIG_IEEE802154_CA8210_DEBUGFS: u32 = 1;
pub const CONFIG_NFC_PN544_MODULE: u32 = 1;
pub const CONFIG_CHARGER_MAX8903_MODULE: u32 = 1;
pub const CONFIG_USB_LCD_MODULE: u32 = 1;
pub const CONFIG_MEMCG: u32 = 1;
pub const CONFIG_SPI: u32 = 1;
pub const CONFIG_TCS3414_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MENF21BMC_HWMON_MODULE: u32 = 1;
pub const CONFIG_RTC_SYSTOHC_DEVICE: &'static [u8; 5usize] = b"rtc0\0";
pub const CONFIG_SENSORS_DS620_MODULE: u32 = 1;
pub const CONFIG_EVM_EXTRA_SMACK_XATTRS: u32 = 1;
pub const CONFIG_V4L_MEM2MEM_DRIVERS: u32 = 1;
pub const CONFIG_X86_SPEEDSTEP_CENTRINO: u32 = 1;
pub const CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT: u32 = 1;
pub const CONFIG_MFD_TPS65912_SPI: u32 = 1;
pub const CONFIG_NFT_HASH_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_IRC_MODULE: u32 = 1;
pub const CONFIG_RENESAS_PHY_MODULE: u32 = 1;
pub const CONFIG_NOUVEAU_DEBUG_DEFAULT: u32 = 3;
pub const CONFIG_BACKLIGHT_AAT2870_MODULE: u32 = 1;
pub const CONFIG_PATA_NS87410_MODULE: u32 = 1;
pub const CONFIG_PCMCIA_SPECTRUM_MODULE: u32 = 1;
pub const CONFIG_L2TP_IP_MODULE: u32 = 1;
pub const CONFIG_RADIO_SI476X_MODULE: u32 = 1;
pub const CONFIG_MTD_REDBOOT_PARTS_MODULE: u32 = 1;
pub const CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE: u32 = 0;
pub const CONFIG_MTD_UBI_FASTMAP: u32 = 1;
pub const CONFIG_SND_SOC_TLV320AIC23_SPI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_IMG_SPDIF_IN_MODULE: u32 = 1;
pub const CONFIG_USB_STV06XX_MODULE: u32 = 1;
pub const CONFIG_PPP_DEFLATE_MODULE: u32 = 1;
pub const CONFIG_USELIB: u32 = 1;
pub const CONFIG_REGULATOR_DA903X_MODULE: u32 = 1;
pub const CONFIG_VGA_SWITCHEROO: u32 = 1;
pub const CONFIG_PSAMPLE_MODULE: u32 = 1;
pub const CONFIG_USB_ISP1301_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_DA9052_MODULE: u32 = 1;
pub const CONFIG_B53_MDIO_DRIVER_MODULE: u32 = 1;
pub const CONFIG_IRQ_REMAP: u32 = 1;
pub const CONFIG_DVB_PT3_MODULE: u32 = 1;
pub const CONFIG_TEXTSEARCH_KMP_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_USA28XA: u32 = 1;
pub const CONFIG_FMC_WRITE_EEPROM_MODULE: u32 = 1;
pub const CONFIG_COMEDI_AMPLC_PC263_PCI_MODULE: u32 = 1;
pub const CONFIG_SND_MAESTRO3_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_SMEM_MODULE: u32 = 1;
pub const CONFIG_VT: u32 = 1;
pub const CONFIG_USB_NET_NET1080_MODULE: u32 = 1;
pub const CONFIG_STK3310_MODULE: u32 = 1;
pub const CONFIG_SENSORS_F71805F_MODULE: u32 = 1;
pub const CONFIG_SUNRPC_DEBUG: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_CLASSIFY_MODULE: u32 = 1;
pub const CONFIG_INET6_ESP_OFFLOAD_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_IMG_SPDIF_OUT_MODULE: u32 = 1;
pub const CONFIG_CCS811_MODULE: u32 = 1;
pub const CONFIG_HID_TIVO_MODULE: u32 = 1;
pub const CONFIG_HID_ICADE_MODULE: u32 = 1;
pub const CONFIG_PCI_ATS: u32 = 1;
pub const CONFIG_MISDN_IPAC_MODULE: u32 = 1;
pub const CONFIG_PARIDE_KTTI_MODULE: u32 = 1;
pub const CONFIG_F2FS_FS_SECURITY: u32 = 1;
pub const CONFIG_LTC2497_MODULE: u32 = 1;
pub const CONFIG_MACB_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_CIRRUS_MODULE: u32 = 1;
pub const CONFIG_GPIO_PCI_IDIO_16_MODULE: u32 = 1;
pub const CONFIG_REGMAP_SPI: u32 = 1;
pub const CONFIG_UNISYSSPAR: u32 = 1;
pub const CONFIG_BT_BREDR: u32 = 1;
pub const CONFIG_DMA_ACPI: u32 = 1;
pub const CONFIG_VIDEO_HEXIUM_GEMINI_MODULE: u32 = 1;
pub const CONFIG_WATCHDOG_HANDLE_BOOT_ENABLED: u32 = 1;
pub const CONFIG_EXTCON_SM5502_MODULE: u32 = 1;
pub const CONFIG_CB710_DEBUG_ASSUMPTIONS: u32 = 1;
pub const CONFIG_INTEL_SOC_PMIC_CHTWC: u32 = 1;
pub const CONFIG_SPLIT_PTLOCK_CPUS: u32 = 4;
pub const CONFIG_LEDS_AS3645A_MODULE: u32 = 1;
pub const CONFIG_USB_R8A66597_MODULE: u32 = 1;
pub const CONFIG_SBITMAP: u32 = 1;
pub const CONFIG_INPUT_DRV2665_HAPTICS_MODULE: u32 = 1;
pub const CONFIG_EDAC_E752X_MODULE: u32 = 1;
pub const CONFIG_GTP_MODULE: u32 = 1;
pub const CONFIG_EXTCON_MAX3355_MODULE: u32 = 1;
pub const CONFIG_MSPRO_BLOCK_MODULE: u32 = 1;
pub const CONFIG_DVB_TUNER_ITD1000_MODULE: u32 = 1;
pub const CONFIG_POWER_SUPPLY: u32 = 1;
pub const CONFIG_DM_PERSISTENT_DATA_MODULE: u32 = 1;
pub const CONFIG_PATA_VIA_MODULE: u32 = 1;
pub const CONFIG_DAVICOM_PHY_MODULE: u32 = 1;
pub const CONFIG_SCSI_UFSHCD_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_SCTP_COOKIE_HMAC_MD5: u32 = 1;
pub const CONFIG_CIFS_XATTR: u32 = 1;
pub const CONFIG_KEXEC_JUMP: u32 = 1;
pub const CONFIG_SENSORS_ADM1275_MODULE: u32 = 1;
pub const CONFIG_SND_DMAENGINE_PCM_MODULE: u32 = 1;
pub const CONFIG_I2C_PCA_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_NFQUEUE_MODULE: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_BOOTPARAM: u32 = 1;
pub const CONFIG_ARCH_HAS_UACCESS_FLUSHCACHE: u32 = 1;
pub const CONFIG_CAN_8DEV_USB_MODULE: u32 = 1;
pub const CONFIG_HAVE_RCU_TABLE_FREE: u32 = 1;
pub const CONFIG_SND_HDA_INPUT_BEEP: u32 = 1;
pub const CONFIG_WEXT_CORE: u32 = 1;
pub const CONFIG_I2C_DESIGNWARE_CORE: u32 = 1;
pub const CONFIG_USB_GSPCA_MR97310A_MODULE: u32 = 1;
pub const CONFIG_DVB_HOPPER_MODULE: u32 = 1;
pub const CONFIG_GENERIC_IRQ_CHIP: u32 = 1;
pub const CONFIG_ACPI_THERMAL_REL_MODULE: u32 = 1;
pub const CONFIG_NETLABEL: u32 = 1;
pub const CONFIG_VIDEO_WM8775_MODULE: u32 = 1;
pub const CONFIG_CHARGER_SBS_MODULE: u32 = 1;
pub const CONFIG_NLS: u32 = 1;
pub const CONFIG_CALGARY_IOMMU: u32 = 1;
pub const CONFIG_NF_CONNTRACK_TIMEOUT: u32 = 1;
pub const CONFIG_GPIO_SCH311X_MODULE: u32 = 1;
pub const CONFIG_INPUT_PCAP_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_HDAC_HDMI_MODULE: u32 = 1;
pub const CONFIG_INPUT_PALMAS_PWRBUTTON_MODULE: u32 = 1;
pub const CONFIG_V4L2_FLASH_LED_CLASS_MODULE: u32 = 1;
pub const CONFIG_MFD_ARIZONA: u32 = 1;
pub const CONFIG_VIDEO_COBALT_MODULE: u32 = 1;
pub const CONFIG_IP_SET_HASH_IPPORTNET_MODULE: u32 = 1;
pub const CONFIG_SMC_DIAG_MODULE: u32 = 1;
pub const CONFIG_LEDS_APU_MODULE: u32 = 1;
pub const CONFIG_CDROM_PKTCDVD_BUFFERS: u32 = 8;
pub const CONFIG_SCHED_AUTOGROUP: u32 = 1;
pub const CONFIG_COMEDI_PCL730_MODULE: u32 = 1;
pub const CONFIG_GPIO_TPS65912_MODULE: u32 = 1;
pub const CONFIG_SPI_SPIDEV_MODULE: u32 = 1;
pub const CONFIG_EFI_BOOTLOADER_CONTROL_MODULE: u32 = 1;
pub const CONFIG_MEDIA_CAMERA_SUPPORT: u32 = 1;
pub const CONFIG_PRISM2_USB_MODULE: u32 = 1;
pub const CONFIG_ADM8211_MODULE: u32 = 1;
pub const CONFIG_MFD_WM8997: u32 = 1;
pub const CONFIG_AIM_NETWORK_MODULE: u32 = 1;
pub const CONFIG_HWPOISON_INJECT_MODULE: u32 = 1;
pub const CONFIG_NTB_TOOL_MODULE: u32 = 1;
pub const CONFIG_VME_FAKE_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_ILI9325_MODULE: u32 = 1;
pub const CONFIG_RTL8188EE_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_SECMARK_MODULE: u32 = 1;
pub const CONFIG_HID_MAGICMOUSE_MODULE: u32 = 1;
pub const CONFIG_MICROSEMI_PHY_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TW686X_MODULE: u32 = 1;
pub const CONFIG_INTEL_CHT_INT33FE_MODULE: u32 = 1;
pub const CONFIG_NFT_COUNTER_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AK4554_MODULE: u32 = 1;
pub const CONFIG_I2C_GPIO_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TDA9840_MODULE: u32 = 1;
pub const CONFIG_INET_UDP_DIAG_MODULE: u32 = 1;
pub const CONFIG_MEDIA_SDR_SUPPORT: u32 = 1;
pub const CONFIG_USB_CONFIGFS_ACM: u32 = 1;
pub const CONFIG_CGROUP_BPF: u32 = 1;
pub const CONFIG_RAPIDIO_ENUM_BASIC_MODULE: u32 = 1;
pub const CONFIG_XEN_SAVE_RESTORE: u32 = 1;
pub const CONFIG_DVB_USB_ZD1301_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_ETURBO: u32 = 1;
pub const CONFIG_DELL_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_PPPOE_MODULE: u32 = 1;
pub const CONFIG_IPV6_SEG6_HMAC: u32 = 1;
pub const CONFIG_CRYPTO_CRCT10DIF_PCLMUL_MODULE: u32 = 1;
pub const CONFIG_WL1251_SDIO_MODULE: u32 = 1;
pub const CONFIG_PCI_REALLOC_ENABLE_AUTO: u32 = 1;
pub const CONFIG_X86_INTEL_PSTATE: u32 = 1;
pub const CONFIG_SND_LAYLA24_MODULE: u32 = 1;
pub const CONFIG_NFC_PN533_USB_MODULE: u32 = 1;
pub const CONFIG_ZONE_DMA: u32 = 1;
pub const CONFIG_VIDEO_CX25821_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_SPCA508_MODULE: u32 = 1;
pub const CONFIG_USB_LEGOTOWER_MODULE: u32 = 1;
pub const CONFIG_LEDS_LP8501_MODULE: u32 = 1;
pub const CONFIG_NF_NAT_IPV6_MODULE: u32 = 1;
pub const CONFIG_I2C_ROBOTFUZZ_OSIF_MODULE: u32 = 1;
pub const CONFIG_MTD_DATAFLASH_MODULE: u32 = 1;
pub const CONFIG_DVB_DRX39XYJ_MODULE: u32 = 1;
pub const CONFIG_FB_MB862XX_I2C: u32 = 1;
pub const CONFIG_QLCNIC_HWMON: u32 = 1;
pub const CONFIG_ACPI_I2C_OPREGION: u32 = 1;
pub const CONFIG_HISAX_TELESPCI: u32 = 1;
pub const CONFIG_ISDN_DIVERSION_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_DIBUSB_MC_MODULE: u32 = 1;
pub const CONFIG_I2C_CBUS_GPIO_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_VP702X_MODULE: u32 = 1;
pub const CONFIG_ROCKER_MODULE: u32 = 1;
pub const CONFIG_CAN_CC770_ISA_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_OWNER_MODULE: u32 = 1;
pub const CONFIG_GPIO_WM8994_MODULE: u32 = 1;
pub const CONFIG_I2C_SIS5595_MODULE: u32 = 1;
pub const CONFIG_X86_PTDUMP_CORE: u32 = 1;
pub const CONFIG_SND_SEQ_DEVICE_MODULE: u32 = 1;
pub const CONFIG_SUN_PARTITION: u32 = 1;
pub const CONFIG_IP_NF_TARGET_ECN_MODULE: u32 = 1;
pub const CONFIG_SND_GINA24_MODULE: u32 = 1;
pub const CONFIG_NFC_NXP_NCI_I2C_MODULE: u32 = 1;
pub const CONFIG_MD_FAULTY_MODULE: u32 = 1;
pub const CONFIG_SYN_COOKIES: u32 = 1;
pub const CONFIG_SENSORS_IR35221_MODULE: u32 = 1;
pub const CONFIG_REED_SOLOMON_DEC8: u32 = 1;
pub const CONFIG_IRQ_WORK: u32 = 1;
pub const CONFIG_ATH9K_MODULE: u32 = 1;
pub const CONFIG_PCI_MSI: u32 = 1;
pub const CONFIG_IP_ADVANCED_ROUTER: u32 = 1;
pub const CONFIG_MISDN_NETJET_MODULE: u32 = 1;
pub const CONFIG_ARCNET_COM20020_CS_MODULE: u32 = 1;
pub const CONFIG_COMEDI_CB_PCIDDA_MODULE: u32 = 1;
pub const CONFIG_VIDEO_USBVISION_MODULE: u32 = 1;
pub const CONFIG_FB_SYS_COPYAREA_MODULE: u32 = 1;
pub const CONFIG_X86_64_SMP: u32 = 1;
pub const CONFIG_HTU21_MODULE: u32 = 1;
pub const CONFIG_USB_EHCI_PCI: u32 = 1;
pub const CONFIG_PATA_CYPRESS_MODULE: u32 = 1;
pub const CONFIG_CLEANCACHE: u32 = 1;
pub const CONFIG_SPI_BITBANG_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_MT2063_MODULE: u32 = 1;
pub const CONFIG_USB_STORAGE_ALAUDA_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_FUJITSU: u32 = 1;
pub const CONFIG_JOYSTICK_GRIP_MP_MODULE: u32 = 1;
pub const CONFIG_SPARSEMEM_EXTREME: u32 = 1;
pub const CONFIG_DMARD09_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2406_MODULE: u32 = 1;
pub const CONFIG_B44_PCICORE_AUTOSELECT: u32 = 1;
pub const CONFIG_IWLWIFI_MODULE: u32 = 1;
pub const CONFIG_AB3100_OTP_MODULE: u32 = 1;
pub const CONFIG_USB_COMMON: u32 = 1;
pub const CONFIG_CYPRESS_FIRMWARE_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ADM1031_MODULE: u32 = 1;
pub const CONFIG_TASK_XACCT: u32 = 1;
pub const CONFIG_ARCNET_1051_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_TDA18271_MODULE: u32 = 1;
pub const CONFIG_IP_SET_BITMAP_PORT_MODULE: u32 = 1;
pub const CONFIG_IP6_NF_IPTABLES_MODULE: u32 = 1;
pub const CONFIG_LZ4_COMPRESS_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SIGMADSP_REGMAP_MODULE: u32 = 1;
pub const CONFIG_KVM_VFIO: u32 = 1;
pub const CONFIG_REGULATOR_AB3100_MODULE: u32 = 1;
pub const CONFIG_PHY_QCOM_USB_HSIC_MODULE: u32 = 1;
pub const CONFIG_USB_HSIC_USB3503_MODULE: u32 = 1;
pub const CONFIG_X86_PCC_CPUFREQ: u32 = 1;
pub const CONFIG_QFMT_V1_MODULE: u32 = 1;
pub const CONFIG_DVB_IX2505V_MODULE: u32 = 1;
pub const CONFIG_TEKRAM_DONGLE_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_ZYTRONIC: u32 = 1;
pub const CONFIG_ATM_HORIZON_MODULE: u32 = 1;
pub const CONFIG_SND_SONICVIBES_MODULE: u32 = 1;
pub const CONFIG_FIXED_PHY: u32 = 1;
pub const CONFIG_CHELSIO_T4_FCOE: u32 = 1;
pub const CONFIG_DVB_SP2_MODULE: u32 = 1;
pub const CONFIG_GPIO_WS16C48_MODULE: u32 = 1;
pub const CONFIG_GPIO_ACPI: u32 = 1;
pub const CONFIG_MFD_MAX8998: u32 = 1;
pub const CONFIG_ARCH_DEFCONFIG: &'static [u8; 34usize] = b"arch/x86/configs/x86_64_defconfig\0";
pub const CONFIG_SENSORS_TMP103_MODULE: u32 = 1;
pub const CONFIG_NLS_MAC_GAELIC_MODULE: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_USERSPACE: u32 = 1;
pub const CONFIG_FTRACE_SYSCALLS: u32 = 1;
pub const CONFIG_IMG_ASCII_LCD_MODULE: u32 = 1;
pub const CONFIG_SND_CA0106_MODULE: u32 = 1;
pub const CONFIG_VIDEO_VIA_CAMERA_MODULE: u32 = 1;
pub const CONFIG_LOG_CPU_MAX_BUF_SHIFT: u32 = 12;
pub const CONFIG_SOC_CAMERA_RJ54N1_MODULE: u32 = 1;
pub const CONFIG_VIDEO_SAA6752HS_MODULE: u32 = 1;
pub const CONFIG_ISDN_DIVAS_MAINT_MODULE: u32 = 1;
pub const CONFIG_NF_DUP_IPV4_MODULE: u32 = 1;
pub const CONFIG_XEN_PVHVM_SMP: u32 = 1;
pub const CONFIG_MAC80211_RC_MINSTREL_VHT: u32 = 1;
pub const CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE: u32 = 1;
pub const CONFIG_BLK_DEV_DM_BUILTIN: u32 = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_USA18X: u32 = 1;
pub const CONFIG_RPR0521_MODULE: u32 = 1;
pub const CONFIG_COMEDI_FL512_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_IPW_MODULE: u32 = 1;
pub const CONFIG_I2C_PIIX4_MODULE: u32 = 1;
pub const CONFIG_EDAC_I7300_MODULE: u32 = 1;
pub const CONFIG_USB_HCD_SSB_MODULE: u32 = 1;
pub const CONFIG_INTEL_SOC_DTS_THERMAL_MODULE: u32 = 1;
pub const CONFIG_ARCNET_COM20020_PCI_MODULE: u32 = 1;
pub const CONFIG_SERIAL_UARTLITE_MODULE: u32 = 1;
pub const CONFIG_INET_IPCOMP_MODULE: u32 = 1;
pub const CONFIG_SENSORS_FSCHMD_MODULE: u32 = 1;
pub const CONFIG_TASKS_RCU: u32 = 1;
pub const CONFIG_MCP2120_DONGLE_MODULE: u32 = 1;
pub const CONFIG_VGA_ARB_MAX_GPUS: u32 = 16;
pub const CONFIG_DVB_USB_DIB0700_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_FUJITSU_MODULE: u32 = 1;
pub const CONFIG_PCMCIA_MODULE: u32 = 1;
pub const CONFIG_XEN_BLKDEV_BACKEND_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT5514_SPI_MODULE: u32 = 1;
pub const CONFIG_GENERIC_PINCONF: u32 = 1;
pub const CONFIG_HISAX_NICCY: u32 = 1;
pub const CONFIG_CAN_PEAK_USB_MODULE: u32 = 1;
pub const CONFIG_FMC_TRIVIAL_MODULE: u32 = 1;
pub const CONFIG_BT_HCIBLUECARD_MODULE: u32 = 1;
pub const CONFIG_ISDN_X25: u32 = 1;
pub const CONFIG_JFFS2_FS_XATTR: u32 = 1;
pub const CONFIG_XILLYBUS_PCIE_MODULE: u32 = 1;
pub const CONFIG_EVENT_TRACING: u32 = 1;
pub const CONFIG_PAGE_TABLE_ISOLATION: u32 = 1;
pub const CONFIG_MFD_INTEL_LPSS_MODULE: u32 = 1;
pub const CONFIG_SND_ENS1370_MODULE: u32 = 1;
pub const CONFIG_NET_CADENCE: u32 = 1;
pub const CONFIG_AD7476_MODULE: u32 = 1;
pub const CONFIG_ASYNC_PQ_MODULE: u32 = 1;
pub const CONFIG_HID_KEYTOUCH_MODULE: u32 = 1;
pub const CONFIG_HID_CYPRESS_MODULE: u32 = 1;
pub const CONFIG_N_GSM_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_LM363X_MODULE: u32 = 1;
pub const CONFIG_SG_POOL: u32 = 1;
pub const CONFIG_BRIDGE_EBT_LIMIT_MODULE: u32 = 1;
pub const CONFIG_SURFACE_PRO3_BUTTON_MODULE: u32 = 1;
pub const CONFIG_DRM_KMS_HELPER_MODULE: u32 = 1;
pub const CONFIG_SERIAL_IPOCTAL_MODULE: u32 = 1;
pub const CONFIG_DRM_PANEL_RASPBERRYPI_TOUCHSCREEN_MODULE: u32 = 1;
pub const CONFIG_IPW2200_PROMISCUOUS: u32 = 1;
pub const CONFIG_TRACE_SINK_MODULE: u32 = 1;
pub const CONFIG_NF_SOCKET_IPV6_MODULE: u32 = 1;
pub const CONFIG_OCFS2_FS_USERSPACE_CLUSTER_MODULE: u32 = 1;
pub const CONFIG_INTEL_BXTWC_PMIC_TMU_MODULE: u32 = 1;
pub const CONFIG_HYSDN_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADL_PCI9111_MODULE: u32 = 1;
pub const CONFIG_ATA_OVER_ETH_MODULE: u32 = 1;
pub const CONFIG_BLK_MQ_PCI: u32 = 1;
pub const CONFIG_USB_NET_PLUSB_MODULE: u32 = 1;
pub const CONFIG_VIDEO_SAA711X_MODULE: u32 = 1;
pub const CONFIG_RTL8192C_COMMON_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_PWM_MODULE: u32 = 1;
pub const CONFIG_MFD_WM831X_SPI: u32 = 1;
pub const CONFIG_SENSORS_LM95234_MODULE: u32 = 1;
pub const CONFIG_SECURITY_DEFAULT_DISPLAY_APPARMOR: u32 = 1;
pub const CONFIG_MEN_A21_WDT_MODULE: u32 = 1;
pub const CONFIG_PREEMPT_VOLUNTARY: u32 = 1;
pub const CONFIG_DVB_BUDGET_CORE_MODULE: u32 = 1;
pub const CONFIG_NLS_ISO8859_1_MODULE: u32 = 1;
pub const CONFIG_MFD_WM8400: u32 = 1;
pub const CONFIG_MTD_INTEL_VR_NOR_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_WORKQUEUE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_WDT87XX_I2C_MODULE: u32 = 1;
pub const CONFIG_MACINTOSH_DRIVERS: u32 = 1;
pub const CONFIG_NFC_MODULE: u32 = 1;
pub const CONFIG_ADE7754_MODULE: u32 = 1;
pub const CONFIG_ALX_MODULE: u32 = 1;
pub const CONFIG_CIFS_FSCACHE: u32 = 1;
pub const CONFIG_SILEAD_DMI: u32 = 1;
pub const CONFIG_R8169_MODULE: u32 = 1;
pub const CONFIG_MAX30102_MODULE: u32 = 1;
pub const CONFIG_TCP_CONG_HYBLA_MODULE: u32 = 1;
pub const CONFIG_PCI_STUB_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DRBG_CTR: u32 = 1;
pub const CONFIG_NCPFS_NFS_NS: u32 = 1;
pub const CONFIG_DRM_I2C_NXP_TDA998X_MODULE: u32 = 1;
pub const CONFIG_HID_KENSINGTON_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_GENERIC_MODULE: u32 = 1;
pub const CONFIG_USB_EHCI_HCD: u32 = 1;
pub const CONFIG_BATTERY_DS2760_MODULE: u32 = 1;
pub const CONFIG_TEXTSEARCH_BM_MODULE: u32 = 1;
pub const CONFIG_SENSORS_HMC5843_I2C_MODULE: u32 = 1;
pub const CONFIG_CHARGER_BQ25890_MODULE: u32 = 1;
pub const CONFIG_FUJITSU_ES_MODULE: u32 = 1;
pub const CONFIG_FS_IOMAP: u32 = 1;
pub const CONFIG_8139TOO_MODULE: u32 = 1;
pub const CONFIG_JFS_SECURITY: u32 = 1;
pub const CONFIG_AFS_FSCACHE: u32 = 1;
pub const CONFIG_SND_PDAUDIOCF_MODULE: u32 = 1;
pub const CONFIG_NLS_MAC_INUIT_MODULE: u32 = 1;
pub const CONFIG_PHY_QCOM_USB_HS_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_LL: u32 = 1;
pub const CONFIG_HID_ZYDACRON_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_LP8755_MODULE: u32 = 1;
pub const CONFIG_PPP_MPPE_MODULE: u32 = 1;
pub const CONFIG_CAN_CALC_BITTIMING: u32 = 1;
pub const CONFIG_HID_SENSOR_ACCEL_3D_MODULE: u32 = 1;
pub const CONFIG_DE2104X_MODULE: u32 = 1;
pub const CONFIG_KXSD9_I2C_MODULE: u32 = 1;
pub const CONFIG_MEMORY_HOTPLUG: u32 = 1;
pub const CONFIG_ISA_BUS_API: u32 = 1;
pub const CONFIG_VMD_MODULE: u32 = 1;
pub const CONFIG_HISAX_SEDLBAUER_CS_MODULE: u32 = 1;
pub const CONFIG_DVB_B2C2_FLEXCOP_MODULE: u32 = 1;
pub const CONFIG_USB_NET_SR9700_MODULE: u32 = 1;
pub const CONFIG_HOTPLUG_PCI_ACPI: u32 = 1;
pub const CONFIG_USB_IRDA_MODULE: u32 = 1;
pub const CONFIG_SATA_ZPODD: u32 = 1;
pub const CONFIG_HID_CMEDIA_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8960_MODULE: u32 = 1;
pub const CONFIG_RFKILL: u32 = 1;
pub const CONFIG_VIDEO_TVP5150_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_FC0012_MODULE: u32 = 1;
pub const CONFIG_NETDEVICES: u32 = 1;
pub const CONFIG_ISA_BUS: u32 = 1;
pub const CONFIG_NET_KEY_MODULE: u32 = 1;
pub const CONFIG_SMS_SIANO_MDTV_MODULE: u32 = 1;
pub const CONFIG_HAVE_CONTEXT_TRACKING: u32 = 1;
pub const CONFIG_IP6_NF_TARGET_HL_MODULE: u32 = 1;
pub const CONFIG_IOSCHED_DEADLINE: u32 = 1;
pub const CONFIG_DLCI_MODULE: u32 = 1;
pub const CONFIG_ATM_IDT77252_USE_SUNI: u32 = 1;
pub const CONFIG_SND_OPL3_LIB_SEQ_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_KCOV: u32 = 1;
pub const CONFIG_CGROUP_FREEZER: u32 = 1;
pub const CONFIG_VIDEO_UPD64083_MODULE: u32 = 1;
pub const CONFIG_SERIAL_ALTERA_JTAGUART_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_MELFAS_MIP4_MODULE: u32 = 1;
pub const CONFIG_EVENTFD: u32 = 1;
pub const CONFIG_CRYPTO_DEV_PADLOCK_SHA_MODULE: u32 = 1;
pub const CONFIG_SOC_CAMERA_MT9T112_MODULE: u32 = 1;
pub const CONFIG_SPI_DESIGNWARE_MODULE: u32 = 1;
pub const CONFIG_MTD_CK804XROM_MODULE: u32 = 1;
pub const CONFIG_PARIDE_PD_MODULE: u32 = 1;
pub const CONFIG_RTL8192CE_MODULE: u32 = 1;
pub const CONFIG_WAN: u32 = 1;
pub const CONFIG_VLAN_8021Q_MVRP: u32 = 1;
pub const CONFIG_RTL8821AE_MODULE: u32 = 1;
pub const CONFIG_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_IPV6_SIT_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_TPS65912_MODULE: u32 = 1;
pub const CONFIG_XFRM: u32 = 1;
pub const CONFIG_SENSORS_K8TEMP_MODULE: u32 = 1;
pub const CONFIG_DEFCONFIG_LIST: &'static [u8; 36usize] = b"/lib/modules/$UNAME_RELEASE/.config\0";
pub const CONFIG_SND_SOC_BT_SCO_MODULE: u32 = 1;
pub const CONFIG_ASYNC_TX_DMA: u32 = 1;
pub const CONFIG_COMEDI_DAS16_MODULE: u32 = 1;
pub const CONFIG_CAIF_USB_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_PMEM_API: u32 = 1;
pub const CONFIG_USB_F_UAC2_MODULE: u32 = 1;
pub const CONFIG_HAVE_KPROBES_ON_FTRACE: u32 = 1;
pub const CONFIG_REGULATOR_PV88090_MODULE: u32 = 1;
pub const CONFIG_IP_SET_HASH_IP_MODULE: u32 = 1;
pub const CONFIG_TINYDRM_ST7586_MODULE: u32 = 1;
pub const CONFIG_YENTA_TOSHIBA: u32 = 1;
pub const CONFIG_USB_MR800_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_AS5011_MODULE: u32 = 1;
pub const CONFIG_AIRO_MODULE: u32 = 1;
pub const CONFIG_MTD_NETtel_MODULE: u32 = 1;
pub const CONFIG_MFD_VX855_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_CONSOLE: u32 = 1;
pub const CONFIG_IPV6_MULTIPLE_TABLES: u32 = 1;
pub const CONFIG_USB_ANNOUNCE_NEW_DEVICES: u32 = 1;
pub const CONFIG_USB_SERIAL_WHITEHEAT_MODULE: u32 = 1;
pub const CONFIG_NET_CLS_ROUTE4_MODULE: u32 = 1;
pub const CONFIG_JUMP_LABEL: u32 = 1;
pub const CONFIG_HID_UDRAW_PS3_MODULE: u32 = 1;
pub const CONFIG_PCMCIA_FMVJ18X_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_QT1070_MODULE: u32 = 1;
pub const CONFIG_MFD_KEMPLD_MODULE: u32 = 1;
pub const CONFIG_USB_NET2272_MODULE: u32 = 1;
pub const CONFIG_OVERLAY_FS_MODULE: u32 = 1;
pub const CONFIG_IP_SET_HASH_NETPORT_MODULE: u32 = 1;
pub const CONFIG_CIFS_ALLOW_INSECURE_LEGACY: u32 = 1;
pub const CONFIG_TCG_INFINEON_MODULE: u32 = 1;
pub const CONFIG_ATH9K_HTC_MODULE: u32 = 1;
pub const CONFIG_IP_VS_DH_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8753_MODULE: u32 = 1;
pub const CONFIG_BRCMFMAC_PROTO_MSGBUF: u32 = 1;
pub const CONFIG_AX25_DAMA_SLAVE: u32 = 1;
pub const CONFIG_AD5380_MODULE: u32 = 1;
pub const CONFIG_RT2800PCI_RT3290: u32 = 1;
pub const CONFIG_VIDEO_MEM2MEM_DEINTERLACE_MODULE: u32 = 1;
pub const CONFIG_RADIO_WL128X_MODULE: u32 = 1;
pub const CONFIG_COMMON_CLK_CS2000_CP_MODULE: u32 = 1;
pub const CONFIG_DA311_MODULE: u32 = 1;
pub const CONFIG_IP_NF_TARGET_MASQUERADE_MODULE: u32 = 1;
pub const CONFIG_AIC79XX_RESET_DELAY_MS: u32 = 5000;
pub const CONFIG_UIO_HV_GENERIC_MODULE: u32 = 1;
pub const CONFIG_ARCNET_COM20020_MODULE: u32 = 1;
pub const CONFIG_TORTURE_TEST_MODULE: u32 = 1;
pub const CONFIG_MFD_AAT2870_CORE: u32 = 1;
pub const CONFIG_HAVE_EBPF_JIT: u32 = 1;
pub const CONFIG_NF_CONNTRACK_BROADCAST_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_LZ4_MODULE: u32 = 1;
pub const CONFIG_ECRYPT_FS: u32 = 1;
pub const CONFIG_NFT_FWD_NETDEV_MODULE: u32 = 1;
pub const CONFIG_PROC_PAGE_MONITOR: u32 = 1;
pub const CONFIG_USB_CONFIGFS_ECM: u32 = 1;
pub const CONFIG_MFD_MAX8907_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_EXTENDED: u32 = 1;
pub const CONFIG_GAMEPORT_FM801_MODULE: u32 = 1;
pub const CONFIG_KS959_DONGLE_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_MAX6916_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_MAGELLAN_MODULE: u32 = 1;
pub const CONFIG_AD7887_MODULE: u32 = 1;
pub const CONFIG_AD7780_MODULE: u32 = 1;
pub const CONFIG_FTL_MODULE: u32 = 1;
pub const CONFIG_IGB_HWMON: u32 = 1;
pub const CONFIG_MTD_NAND_BCH_MODULE: u32 = 1;
pub const CONFIG_DM_CACHE_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_R820T_MODULE: u32 = 1;
pub const CONFIG_MTD_SPI_NOR_USE_4K_SECTORS: u32 = 1;
pub const CONFIG_IPMI_DEVICE_INTERFACE_MODULE: u32 = 1;
pub const CONFIG_BPF: u32 = 1;
pub const CONFIG_9P_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_KINGSUN_DONGLE_MODULE: u32 = 1;
pub const CONFIG_STM_SOURCE_HEARTBEAT_MODULE: u32 = 1;
pub const CONFIG_NF_NAT_PROTO_DCCP: u32 = 1;
pub const CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV: u32 = 1;
pub const CONFIG_VIDEO_SH_VEU_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ADM1021_MODULE: u32 = 1;
pub const CONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK: u32 = 1;
pub const CONFIG_C2PORT_MODULE: u32 = 1;
pub const CONFIG_EVM_ATTR_FSUUID: u32 = 1;
pub const CONFIG_DM_DELAY_MODULE: u32 = 1;
pub const CONFIG_MEMORY_HOTPLUG_DEFAULT_ONLINE: u32 = 1;
pub const CONFIG_X86_CMOV: u32 = 1;
pub const CONFIG_USB_SERIAL_CH341_MODULE: u32 = 1;
pub const CONFIG_HID_SENSOR_IIO_COMMON_MODULE: u32 = 1;
pub const CONFIG_USB_FTDI_ELAN_MODULE: u32 = 1;
pub const CONFIG_ACPI_HOTPLUG_CPU: u32 = 1;
pub const CONFIG_VIDEO_ZORAN_AVS6EYES_MODULE: u32 = 1;
pub const CONFIG_PM_TRACE_RTC: u32 = 1;
pub const CONFIG_RD_LZO: u32 = 1;
pub const CONFIG_COMEDI_ADDI_APCI_1564_MODULE: u32 = 1;
pub const CONFIG_USB_RAINSHADOW_CEC_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_FRIIO_MODULE: u32 = 1;
pub const CONFIG_JFFS2_FS_SECURITY: u32 = 1;
pub const CONFIG_USB_G_NOKIA_MODULE: u32 = 1;
pub const CONFIG_IP_SET_HASH_IPPORT_MODULE: u32 = 1;
pub const CONFIG_CAIF_TTY_MODULE: u32 = 1;
pub const CONFIG_KPROBE_EVENTS: u32 = 1;
pub const CONFIG_SENSORS_SHT21_MODULE: u32 = 1;
pub const CONFIG_USB_IOWARRIOR_MODULE: u32 = 1;
pub const CONFIG_SND_HDSP_MODULE: u32 = 1;
pub const CONFIG_BATTERY_DA9052_MODULE: u32 = 1;
pub const CONFIG_SERIO_CT82C710_MODULE: u32 = 1;
pub const CONFIG_OPENVSWITCH_GENEVE_MODULE: u32 = 1;
pub const CONFIG_MLX4_CORE_GEN2: u32 = 1;
pub const CONFIG_USBPCWATCHDOG_MODULE: u32 = 1;
pub const CONFIG_MODULE_SIG_ALL: u32 = 1;
pub const CONFIG_USB_EZUSB_FX2_MODULE: u32 = 1;
pub const CONFIG_SND_USB_TONEPORT_MODULE: u32 = 1;
pub const CONFIG_WIMAX_I2400M_USB_MODULE: u32 = 1;
pub const CONFIG_SND_USB_USX2Y_MODULE: u32 = 1;
pub const CONFIG_SCSI_SPI_ATTRS_MODULE: u32 = 1;
pub const CONFIG_PARIDE_EPATC8: u32 = 1;
pub const CONFIG_FB_CYBER2000_MODULE: u32 = 1;
pub const CONFIG_BCMA_DRIVER_GMAC_CMN: u32 = 1;
pub const CONFIG_RTL8XXXU_MODULE: u32 = 1;
pub const CONFIG_GREENASIA_FF: u32 = 1;
pub const CONFIG_PINCTRL_CEDARFORK_MODULE: u32 = 1;
pub const CONFIG_SCSI_HPSA_MODULE: u32 = 1;
pub const CONFIG_MICROCODE_AMD: u32 = 1;
pub const CONFIG_SPEAKUP_SYNTH_ACNTSA_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_IMG_I2S_IN_MODULE: u32 = 1;
pub const CONFIG_RAPIDIO_TSI721_MODULE: u32 = 1;
pub const CONFIG_SND_KORG1212_MODULE: u32 = 1;
pub const CONFIG_SENSORS_VIA_CPUTEMP_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_SECMARK: u32 = 1;
pub const CONFIG_CROS_EC_LPC_MEC: u32 = 1;
pub const CONFIG_ISDN_DRV_GIGASET_MODULE: u32 = 1;
pub const CONFIG_GP2AP020A00F_MODULE: u32 = 1;
pub const CONFIG_CHELSIO_T3_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OV7640_MODULE: u32 = 1;
pub const CONFIG_INSTRUCTION_DECODER: u32 = 1;
pub const CONFIG_CRYPTO_SHA512: u32 = 1;
pub const CONFIG_SND_SOC_IMG_PISTACHIO_INTERNAL_DAC_MODULE: u32 = 1;
pub const CONFIG_PHONET_MODULE: u32 = 1;
pub const CONFIG_MWIFIEX_PCIE_MODULE: u32 = 1;
pub const CONFIG_CAN_C_CAN_PCI_MODULE: u32 = 1;
pub const CONFIG_CAN_VXCAN_MODULE: u32 = 1;
pub const CONFIG_TRUSTED_KEYS: u32 = 1;
pub const CONFIG_SND_SOC_AC97_BUS: u32 = 1;
pub const CONFIG_BACKLIGHT_CLASS_DEVICE: u32 = 1;
pub const CONFIG_B43_HWRNG: u32 = 1;
pub const CONFIG_VHOST_MODULE: u32 = 1;
pub const CONFIG_USB_M5602_MODULE: u32 = 1;
pub const CONFIG_RT2X00_LIB_USB_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_EXAR: u32 = 1;
pub const CONFIG_UIO_MF624_MODULE: u32 = 1;
pub const CONFIG_WM8350_POWER_MODULE: u32 = 1;
pub const CONFIG_SPI_DLN2_MODULE: u32 = 1;
pub const CONFIG_INPUT_CMA3000_I2C_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_NULL: u32 = 1;
pub const CONFIG_INTEL_WMI_THUNDERBOLT_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_AF9005_REMOTE_MODULE: u32 = 1;
pub const CONFIG_B43_PHY_G: u32 = 1;
pub const CONFIG_NET_VENDOR_SEEQ: u32 = 1;
pub const CONFIG_NF_DEFRAG_IPV4_MODULE: u32 = 1;
pub const CONFIG_USER_RETURN_NOTIFIER: u32 = 1;
pub const CONFIG_RTC_DRV_AM1805_MODULE: u32 = 1;
pub const CONFIG_NFT_SET_HASH_MODULE: u32 = 1;
pub const CONFIG_INTEL_IOMMU_FLOPPY_WA: u32 = 1;
pub const CONFIG_BT_QCA_MODULE: u32 = 1;
pub const CONFIG_USB_IDMOUSE_MODULE: u32 = 1;
pub const CONFIG_SELECT_MEMORY_MODEL: u32 = 1;
pub const CONFIG_CRYPTO_CAMELLIA_AESNI_AVX2_X86_64_MODULE: u32 = 1;
pub const CONFIG_SND_FIREWIRE_TASCAM_MODULE: u32 = 1;
pub const CONFIG_MISDN_INFINEON_MODULE: u32 = 1;
pub const CONFIG_INET_XFRM_MODE_BEET_MODULE: u32 = 1;
pub const CONFIG_HID_LCPOWER_MODULE: u32 = 1;
pub const CONFIG_VIRTIO_CONSOLE: u32 = 1;
pub const CONFIG_MOUSE_ELAN_I2C_SMBUS: u32 = 1;
pub const CONFIG_NFC_MRVL_MODULE: u32 = 1;
pub const CONFIG_ACPI_APEI_EINJ_MODULE: u32 = 1;
pub const CONFIG_PERSISTENT_KEYRINGS: u32 = 1;
pub const CONFIG_NET_ACT_CONNMARK_MODULE: u32 = 1;
pub const CONFIG_BFS_FS_MODULE: u32 = 1;
pub const CONFIG_FS_ENCRYPTION: u32 = 1;
pub const CONFIG_SND_ES1938_MODULE: u32 = 1;
pub const CONFIG_PM_DEBUG: u32 = 1;
pub const CONFIG_VIDEO_TW9906_MODULE: u32 = 1;
pub const CONFIG_DVB_BUDGET_AV_MODULE: u32 = 1;
pub const CONFIG_IPV6_ROUTE_INFO: u32 = 1;
pub const CONFIG_MFD_WM8350_I2C: u32 = 1;
pub const CONFIG_NETFILTER_ADVANCED: u32 = 1;
pub const CONFIG_CRYPTO_DEFLATE_MODULE: u32 = 1;
pub const CONFIG_GENERIC_STRNLEN_USER: u32 = 1;
pub const CONFIG_MFD_WM8350: u32 = 1;
pub const CONFIG_NFT_DUP_NETDEV_MODULE: u32 = 1;
pub const CONFIG_USB_APPLEDISPLAY_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_KLSI_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_TCPMSS_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DA9063_MODULE: u32 = 1;
pub const CONFIG_IGB_MODULE: u32 = 1;
pub const CONFIG_MTD_CFI_MODULE: u32 = 1;
pub const CONFIG_PGTABLE_MAPPING: u32 = 1;
pub const CONFIG_COMEDI_USBDUXSIGMA_MODULE: u32 = 1;
pub const CONFIG_QCOM_VADC_COMMON_MODULE: u32 = 1;
pub const CONFIG_RPMSG_VIRTIO_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_IPCOMP_MODULE: u32 = 1;
pub const CONFIG_IPV6_ROUTER_PREF: u32 = 1;
pub const CONFIG_JFFS2_FS_DEBUG: u32 = 0;
pub const CONFIG_BT_HCIBTSDIO_MODULE: u32 = 1;
pub const CONFIG_DRM_QXL_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_RSI: u32 = 1;
pub const CONFIG_SLIP_COMPRESSED: u32 = 1;
pub const CONFIG_CRYPTO_JITTERENTROPY: u32 = 1;
pub const CONFIG_JOYSTICK_PSXPAD_SPI_MODULE: u32 = 1;
pub const CONFIG_NTB_INTEL_MODULE: u32 = 1;
pub const CONFIG_SND_VX_LIB_MODULE: u32 = 1;
pub const CONFIG_ATM_MPOA_MODULE: u32 = 1;
pub const CONFIG_TYPEC_MODULE: u32 = 1;
pub const CONFIG_ARCH_ENABLE_HUGEPAGE_MIGRATION: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_L2TP_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_SERDEV: u32 = 1;
pub const CONFIG_INPUT_ARIZONA_HAPTICS_MODULE: u32 = 1;
pub const CONFIG_DM_SWITCH_MODULE: u32 = 1;
pub const CONFIG_ROCKETPORT_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_GCM: u32 = 1;
pub const CONFIG_SND_INDIGOIO_MODULE: u32 = 1;
pub const CONFIG_NE2K_PCI_MODULE: u32 = 1;
pub const CONFIG_MOUSE_SYNAPTICS_USB_MODULE: u32 = 1;
pub const CONFIG_NET_SCTPPROBE_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_NETLINK_LOG_MODULE: u32 = 1;
pub const CONFIG_HAVE_DYNAMIC_FTRACE: u32 = 1;
pub const CONFIG_PWM_LPSS_PCI_MODULE: u32 = 1;
pub const CONFIG_CDROM: u32 = 1;
pub const CONFIG_PINCTRL_CHERRYVIEW: u32 = 1;
pub const CONFIG_NLS_ISO8859_14_MODULE: u32 = 1;
pub const CONFIG_DS1803_MODULE: u32 = 1;
pub const CONFIG_MTD_PHRAM_MODULE: u32 = 1;
pub const CONFIG_MAGIC_SYSRQ: u32 = 1;
pub const CONFIG_MFD_88PM860X: u32 = 1;
pub const CONFIG_CROS_EC_CHARDEV_MODULE: u32 = 1;
pub const CONFIG_VOP_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_F_FS: u32 = 1;
pub const CONFIG_E100_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_TPS6586X_MODULE: u32 = 1;
pub const CONFIG_THERMAL_EMULATION: u32 = 1;
pub const CONFIG_MDIO_THUNDER_MODULE: u32 = 1;
pub const CONFIG_DMI: u32 = 1;
pub const CONFIG_IPV6_SIT_6RD: u32 = 1;
pub const CONFIG_SND_SOC_NAU8540_MODULE: u32 = 1;
pub const CONFIG_WIL6210_TRACING: u32 = 1;
pub const CONFIG_PARPORT_SERIAL_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_BYTCR_RT5660_MACH_MODULE: u32 = 1;
pub const CONFIG_SND_DICE_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_KPP: u32 = 1;
pub const CONFIG_PNFS_BLOCK_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_RDC: u32 = 1;
pub const CONFIG_MACHZ_WDT_MODULE: u32 = 1;
pub const CONFIG_PGTABLE_LEVELS: u32 = 4;
pub const CONFIG_MFD_CROS_EC_I2C_MODULE: u32 = 1;
pub const CONFIG_CPUSETS: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_MARK_MODULE: u32 = 1;
pub const CONFIG_FB_MATROX_MODULE: u32 = 1;
pub const CONFIG_ISDN: u32 = 1;
pub const CONFIG_VIDEO_PVRUSB2_SYSFS: u32 = 1;
pub const CONFIG_ATLAS_PH_SENSOR_MODULE: u32 = 1;
pub const CONFIG_FUNCTION_PROFILER: u32 = 1;
pub const CONFIG_MAC80211_RC_DEFAULT_MINSTREL: u32 = 1;
pub const CONFIG_NVME_MULTIPATH: u32 = 1;
pub const CONFIG_RMI4_F03_SERIO_MODULE: u32 = 1;
pub const CONFIG_SPARSE_IRQ: u32 = 1;
pub const CONFIG_MMA7455_I2C_MODULE: u32 = 1;
pub const CONFIG_COMEDI_AMPLC_PC236_MODULE: u32 = 1;
pub const CONFIG_DVB_LGS8GXX_MODULE: u32 = 1;
pub const CONFIG_IR_SERIAL_TRANSMITTER: u32 = 1;
pub const CONFIG_DGNC_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP_MODULE: u32 = 1;
pub const CONFIG_INPUT_IDEAPAD_SLIDEBAR_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_MODULE: u32 = 1;
pub const CONFIG_USB_CHIPIDEA_ULPI: u32 = 1;
pub const CONFIG_SSFDC_MODULE: u32 = 1;
pub const CONFIG_IP_NF_MANGLE_MODULE: u32 = 1;
pub const CONFIG_LEDS_USER_MODULE: u32 = 1;
pub const CONFIG_TIFM_7XX1_MODULE: u32 = 1;
pub const CONFIG_USB_MASS_STORAGE_MODULE: u32 = 1;
pub const CONFIG_SCSI_UFS_DWC_TC_PCI_MODULE: u32 = 1;
pub const CONFIG_HID_PICOLCD_LEDS: u32 = 1;
pub const CONFIG_COMEDI_CB_DAS16_CS_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1286_MODULE: u32 = 1;
pub const CONFIG_FCOE_FNIC_MODULE: u32 = 1;
pub const CONFIG_INTEL_SMARTCONNECT_MODULE: u32 = 1;
pub const CONFIG_ATH10K_DEBUGFS: u32 = 1;
pub const CONFIG_BCM_KONA_USB2_PHY_MODULE: u32 = 1;
pub const CONFIG_MOXA_INTELLIO_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_MCS5000_MODULE: u32 = 1;
pub const CONFIG_DVB_VES1X93_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_ILI9341_MODULE: u32 = 1;
pub const CONFIG_SECURITY_PERF_EVENTS_RESTRICT: u32 = 1;
pub const CONFIG_DRM_UDL_MODULE: u32 = 1;
pub const CONFIG_SECURITYFS: u32 = 1;
pub const CONFIG_LIBERTAS_MESH: u32 = 1;
pub const CONFIG_RTC_DRV_S5M_MODULE: u32 = 1;
pub const CONFIG_DEFAULT_CFQ: u32 = 1;
pub const CONFIG_RCU_STALL_COMMON: u32 = 1;
pub const CONFIG_COMEDI_NI_PCIDIO_MODULE: u32 = 1;
pub const CONFIG_BT_DEBUGFS: u32 = 1;
pub const CONFIG_CPU_SUP_AMD: u32 = 1;
pub const CONFIG_SND_SOC_SIRF_AUDIO_CODEC_MODULE: u32 = 1;
pub const CONFIG_INET6_XFRM_MODE_TUNNEL_MODULE: u32 = 1;
pub const CONFIG_MFD_INTEL_QUARK_I2C_GPIO_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_EBT_VLAN_MODULE: u32 = 1;
pub const CONFIG_PCIEPORTBUS: u32 = 1;
pub const CONFIG_MEDIA_SUPPORT_MODULE: u32 = 1;
pub const CONFIG_NFT_FIB_IPV6_MODULE: u32 = 1;
pub const CONFIG_SENSORS_F75375S_MODULE: u32 = 1;
pub const CONFIG_DEBUG_BUGVERBOSE: u32 = 1;
pub const CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK: u32 = 1;
pub const CONFIG_ACPI_CUSTOM_DSDT_FILE: &'static [u8; 1usize] = b"\0";
pub const CONFIG_NCPFS_OS2_NS: u32 = 1;
pub const CONFIG_IP_NF_FILTER_MODULE: u32 = 1;
pub const CONFIG_BH1780_MODULE: u32 = 1;
pub const CONFIG_HID_ZEROPLUS_MODULE: u32 = 1;
pub const CONFIG_REED_SOLOMON_DEC16: u32 = 1;
pub const CONFIG_SENSORS_MC13783_ADC_MODULE: u32 = 1;
pub const CONFIG_DM_INTEGRITY_MODULE: u32 = 1;
pub const CONFIG_SATA_SX4_MODULE: u32 = 1;
pub const CONFIG_MAC802154_MODULE: u32 = 1;
pub const CONFIG_IBM_ASM_MODULE: u32 = 1;
pub const CONFIG_SOC_CAMERA_OV772X_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_LENGTH_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_EBT_PKTTYPE_MODULE: u32 = 1;
pub const CONFIG_HID_SENSOR_GYRO_3D_MODULE: u32 = 1;
pub const CONFIG_COMEDI_8255_SA_MODULE: u32 = 1;
pub const CONFIG_AFE4403_MODULE: u32 = 1;
pub const CONFIG_MODULES_TREE_LOOKUP: u32 = 1;
pub const CONFIG_FAT_FS: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_CA0132_MODULE: u32 = 1;
pub const CONFIG_FCOE_MODULE: u32 = 1;
pub const CONFIG_CAN_SJA1000_MODULE: u32 = 1;
pub const CONFIG_AUFS_BDEV_LOOP: u32 = 1;
pub const CONFIG_SND_HDA_INTEL_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_QAT_DH895xCCVF_MODULE: u32 = 1;
pub const CONFIG_MAY_USE_DEVLINK_MODULE: u32 = 1;
pub const CONFIG_TEXTSEARCH_FSM_MODULE: u32 = 1;
pub const CONFIG_USB_HSIC_USB4604_MODULE: u32 = 1;
pub const CONFIG_MISDN_DSP_MODULE: u32 = 1;
pub const CONFIG_THIN_ARCHIVES: u32 = 1;
pub const CONFIG_SENSORS_LM75_MODULE: u32 = 1;
pub const CONFIG_PANEL_PROFILE: u32 = 5;
pub const CONFIG_INFINIBAND_CXGB4_MODULE: u32 = 1;
pub const CONFIG_DVB_STV0910_MODULE: u32 = 1;
pub const CONFIG_LSI_ET1011C_PHY_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT5616_MODULE: u32 = 1;
pub const CONFIG_HISAX_SEDLBAUER: u32 = 1;
pub const CONFIG_IP6_NF_RAW_MODULE: u32 = 1;
pub const CONFIG_SPEAKUP_SYNTH_SOFT_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_EC168_MODULE: u32 = 1;
pub const CONFIG_USB_ZD1201_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1742_MODULE: u32 = 1;
pub const CONFIG_NVMEM: u32 = 1;
pub const CONFIG_INET_TUNNEL_MODULE: u32 = 1;
pub const CONFIG_X86_INTERNODE_CACHE_SHIFT: u32 = 6;
pub const CONFIG_BMA220_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SERPENT_SSE2_X86_64_MODULE: u32 = 1;
pub const CONFIG_NF_LOG_ARP_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_PADLOCK: u32 = 1;
pub const CONFIG_SENSORS_PMBUS_MODULE: u32 = 1;
pub const CONFIG_EEPROM_93CX6_MODULE: u32 = 1;
pub const CONFIG_GPIO_WM8350_MODULE: u32 = 1;
pub const CONFIG_IEEE802154_CA8210_MODULE: u32 = 1;
pub const CONFIG_NET_9P_VIRTIO_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_SKBMOD_MODULE: u32 = 1;
pub const CONFIG_PINCONF: u32 = 1;
pub const CONFIG_MFD_DA9052_SPI: u32 = 1;
pub const CONFIG_X86_CHECK_BIOS_CORRUPTION: u32 = 1;
pub const CONFIG_IIO_ST_LSM6DSX_I2C_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_SMSC_LAN9303_I2C_MODULE: u32 = 1;
pub const CONFIG_MLX4_CORE_MODULE: u32 = 1;
pub const CONFIG_GPIO_MENZ127_MODULE: u32 = 1;
pub const CONFIG_FSI_MASTER_GPIO_MODULE: u32 = 1;
pub const CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK: i32 = -1;
pub const CONFIG_SND_MIA_MODULE: u32 = 1;
pub const CONFIG_GENERIC_CLOCKEVENTS: u32 = 1;
pub const CONFIG_ROMFS_FS_MODULE: u32 = 1;
pub const CONFIG_IOSCHED_CFQ: u32 = 1;
pub const CONFIG_OID_REGISTRY: u32 = 1;
pub const CONFIG_MFD_88PM805_MODULE: u32 = 1;
pub const CONFIG_PHY_PXA_28NM_HSIC_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_DTT200U_MODULE: u32 = 1;
pub const CONFIG_CIFS_UPCALL: u32 = 1;
pub const CONFIG_GREYBUS_VIBRATOR_MODULE: u32 = 1;
pub const CONFIG_THUNDER_NIC_PF_MODULE: u32 = 1;
pub const CONFIG_RWSEM_XCHGADD_ALGORITHM: u32 = 1;
pub const CONFIG_RADIO_TEA575X_MODULE: u32 = 1;
pub const CONFIG_DSCC4_PCISYNC: u32 = 1;
pub const CONFIG_PARIDE_EPIA_MODULE: u32 = 1;
pub const CONFIG_LIB80211_MODULE: u32 = 1;
pub const CONFIG_MEDIA_CEC_SUPPORT: u32 = 1;
pub const CONFIG_MFD_CORE: u32 = 1;
pub const CONFIG_HAVE_KERNEL_XZ: u32 = 1;
pub const CONFIG_COMEDI_AMPLC_PC236_ISA_MODULE: u32 = 1;
pub const CONFIG_USB_CXACRU_MODULE: u32 = 1;
pub const CONFIG_DRM_GMA3600: u32 = 1;
pub const CONFIG_X86_PKG_TEMP_THERMAL_MODULE: u32 = 1;
pub const CONFIG_RAID_ATTRS_MODULE: u32 = 1;
pub const CONFIG_RFKILL_LEDS: u32 = 1;
pub const CONFIG_BT_HCIBTUSB_BCM: u32 = 1;
pub const CONFIG_CONSOLE_TRANSLATIONS: u32 = 1;
pub const CONFIG_PATA_CMD64X_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_TM2_TOUCHKEY_MODULE: u32 = 1;
pub const CONFIG_MTD_CFI_STAA_MODULE: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_ATOMIC_RMW: u32 = 1;
pub const CONFIG_TCG_CRB: u32 = 1;
pub const CONFIG_REGULATOR_AD5398_MODULE: u32 = 1;
pub const CONFIG_USB_F_UVC_MODULE: u32 = 1;
pub const CONFIG_RAID6_PQ_MODULE: u32 = 1;
pub const CONFIG_SBC_FITPC2_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_HW_RANDOM_TIMERIOMEM_MODULE: u32 = 1;
pub const CONFIG_NET_IPGRE_MODULE: u32 = 1;
pub const CONFIG_ADT7316_MODULE: u32 = 1;
pub const CONFIG_LIBERTAS_SDIO_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_QAT_MODULE: u32 = 1;
pub const CONFIG_FUSION: u32 = 1;
pub const CONFIG_MTDRAM_TOTAL_SIZE: u32 = 4096;
pub const CONFIG_VIDEO_TEA6420_MODULE: u32 = 1;
pub const CONFIG_SWIOTLB_XEN: u32 = 1;
pub const CONFIG_BRIDGE_EBT_IP6_MODULE: u32 = 1;
pub const CONFIG_NF_NAT_SNMP_BASIC_MODULE: u32 = 1;
pub const CONFIG_SND_X86: u32 = 1;
pub const CONFIG_NFT_FIB_NETDEV_MODULE: u32 = 1;
pub const CONFIG_PCMCIA_LOAD_CIS: u32 = 1;
pub const CONFIG_XEN_SYMS: u32 = 1;
pub const CONFIG_SERIAL_EARLYCON: u32 = 1;
pub const CONFIG_CLS_U32_MARK: u32 = 1;
pub const CONFIG_DVB_CX24120_MODULE: u32 = 1;
pub const CONFIG_SND_ICE1712_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_MAX8925_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_AKCIPHER: u32 = 1;
pub const CONFIG_LIBERTAS_SPI_MODULE: u32 = 1;
pub const CONFIG_SCSI_ACARD_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SIGMADSP_I2C_MODULE: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_BACKLIGHT_MODULE: u32 = 1;
pub const CONFIG_VIDEO_ZORAN_LML33_MODULE: u32 = 1;
pub const CONFIG_ACPI_CPU_FREQ_PSS: u32 = 1;
pub const CONFIG_CPU_FREQ: u32 = 1;
pub const CONFIG_USB_OHCI_HCD: u32 = 1;
pub const CONFIG_VIA_RHINE_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_MODULE: u32 = 1;
pub const CONFIG_HOSTAP_FIRMWARE: u32 = 1;
pub const CONFIG_VHOST_RING_MODULE: u32 = 1;
pub const CONFIG_DM_MIRROR_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_BLOWFISH_MODULE: u32 = 1;
pub const CONFIG_FB_SIS_MODULE: u32 = 1;
pub const CONFIG_DUMMY_CONSOLE: u32 = 1;
pub const CONFIG_MLXSW_CORE_HWMON: u32 = 1;
pub const CONFIG_AIC7XXX_DEBUG_MASK: u32 = 0;
pub const CONFIG_SENSORS_LTC3815_MODULE: u32 = 1;
pub const CONFIG_SCSI_GDTH_MODULE: u32 = 1;
pub const CONFIG_USB_F_TCM_MODULE: u32 = 1;
pub const CONFIG_USB_PCI: u32 = 1;
pub const CONFIG_COMEDI_DAS08_PCI_MODULE: u32 = 1;
pub const CONFIG_NLS_ASCII_MODULE: u32 = 1;
pub const CONFIG_RFKILL_GPIO_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_DA9055_MODULE: u32 = 1;
pub const CONFIG_USB_G_PRINTER_MODULE: u32 = 1;
pub const CONFIG_B43_MODULE: u32 = 1;
pub const CONFIG_FPGA_MGR_ALTERA_CVP_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_GRIP_MODULE: u32 = 1;
pub const CONFIG_BAYCOM_SER_FDX_MODULE: u32 = 1;
pub const CONFIG_MEDIA_ALTERA_CI_MODULE: u32 = 1;
pub const CONFIG_NF_REJECT_IPV4_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_M41T94_MODULE: u32 = 1;
pub const CONFIG_AD_SIGMA_DELTA_MODULE: u32 = 1;
pub const CONFIG_WIMAX_DEBUG_LEVEL: u32 = 8;
pub const CONFIG_RANDOMIZE_MEMORY: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_BITS_MAX: u32 = 32;
pub const CONFIG_SND_SOC_FSL_SSI_MODULE: u32 = 1;
pub const CONFIG_BPF_EVENTS: u32 = 1;
pub const CONFIG_USB_LAN78XX_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_I2C_MODULE: u32 = 1;
pub const CONFIG_VIDEO_HEXIUM_ORION_MODULE: u32 = 1;
pub const CONFIG_IIO_CROS_EC_SENSORS_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE: u32 = 1;
pub const CONFIG_BACKLIGHT_GPIO_MODULE: u32 = 1;
pub const CONFIG_INTEL_MEI_ME_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_QIB_MODULE: u32 = 1;
pub const CONFIG_6LOWPAN_NHC_MOBILITY_MODULE: u32 = 1;
pub const CONFIG_LAPBETHER_MODULE: u32 = 1;
pub const CONFIG_USB_SI4713_MODULE: u32 = 1;
pub const CONFIG_SATA_SVW_MODULE: u32 = 1;
pub const CONFIG_MAX11100_MODULE: u32 = 1;
pub const CONFIG_TRACE_IRQFLAGS_SUPPORT: u32 = 1;
pub const CONFIG_AD5360_MODULE: u32 = 1;
pub const CONFIG_IEEE802154_MRF24J40_MODULE: u32 = 1;
pub const CONFIG_MFD_SYSCON: u32 = 1;
pub const CONFIG_SND_SOC_TAS5720_MODULE: u32 = 1;
pub const CONFIG_MTD_PHYSMAP_MODULE: u32 = 1;
pub const CONFIG_MS5611_SPI_MODULE: u32 = 1;
pub const CONFIG_NFS_V3_ACL: u32 = 1;
pub const CONFIG_HDLC_X25_MODULE: u32 = 1;
pub const CONFIG_IPV6_SEG6_LWTUNNEL: u32 = 1;
pub const CONFIG_CHARGER_GPIO_MODULE: u32 = 1;
pub const CONFIG_INPUT_GPIO_DECODER_MODULE: u32 = 1;
pub const CONFIG_INFTL_MODULE: u32 = 1;
pub const CONFIG_NFT_NUMGEN_MODULE: u32 = 1;
pub const CONFIG_GAMEPORT_L4_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ADT7462_MODULE: u32 = 1;
pub const CONFIG_DETECT_HUNG_TASK: u32 = 1;
pub const CONFIG_PARIDE_FRIQ_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MAX14577_MODULE: u32 = 1;
pub const CONFIG_SENSORS_NCT7802_MODULE: u32 = 1;
pub const CONFIG_CAN_MCP251X_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CCM_MODULE: u32 = 1;
pub const CONFIG_TCP_CONG_ADVANCED: u32 = 1;
pub const CONFIG_NET_CLS_RSVP6_MODULE: u32 = 1;
pub const CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT: u32 = 1;
pub const CONFIG_USB_NET_CDC_SUBSET_MODULE: u32 = 1;
pub const CONFIG_AD7152_MODULE: u32 = 1;
pub const CONFIG_BT_RTL_MODULE: u32 = 1;
pub const CONFIG_MMA9551_CORE_MODULE: u32 = 1;
pub const CONFIG_VIDEO_VIMC_MODULE: u32 = 1;
pub const CONFIG_KVM_GUEST: u32 = 1;
pub const CONFIG_DRM_KMS_CMA_HELPER: u32 = 1;
pub const CONFIG_GS_FPGABOOT_MODULE: u32 = 1;
pub const CONFIG_QFMT_V2_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_COMMON_MODULE: u32 = 1;
pub const CONFIG_USB_S2255_MODULE: u32 = 1;
pub const CONFIG_INET_DCCP_DIAG_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_DA9063_MODULE: u32 = 1;
pub const CONFIG_TAP_MODULE: u32 = 1;
pub const CONFIG_ARCNET_COM90xxIO_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CONNMARK_MODULE: u32 = 1;
pub const CONFIG_ATH9K_HW_MODULE: u32 = 1;
pub const CONFIG_BLK_CGROUP: u32 = 1;
pub const CONFIG_USB_SERIAL_MCT_U232_MODULE: u32 = 1;
pub const CONFIG_UIO_PDRV_GENIRQ_MODULE: u32 = 1;
pub const CONFIG_BT_HCIBT3C_MODULE: u32 = 1;
pub const CONFIG_LEDS_TRIGGERS: u32 = 1;
pub const CONFIG_NET_FOU_MODULE: u32 = 1;
pub const CONFIG_WIMAX_I2400M_DEBUG_LEVEL: u32 = 8;
pub const CONFIG_CRYPTO_RNG: u32 = 1;
pub const CONFIG_USB_SERIAL_GARMIN_MODULE: u32 = 1;
pub const CONFIG_W1_MASTER_GPIO_MODULE: u32 = 1;
pub const CONFIG_RAW_DRIVER_MODULE: u32 = 1;
pub const CONFIG_MTD_ESB2ROM_MODULE: u32 = 1;
pub const CONFIG_XFS_QUOTA: u32 = 1;
pub const CONFIG_COMEDI_ISA_DRIVERS: u32 = 1;
pub const CONFIG_JOYSTICK_COBRA_MODULE: u32 = 1;
pub const CONFIG_ATH10K_MODULE: u32 = 1;
pub const CONFIG_SECURITY_SMACK: u32 = 1;
pub const CONFIG_NET_SCH_ATM_MODULE: u32 = 1;
pub const CONFIG_DRM_AMDGPU_CIK: u32 = 1;
pub const CONFIG_WINBOND_840_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_CYTTSP_SPI_MODULE: u32 = 1;
pub const CONFIG_TI_TLC4541_MODULE: u32 = 1;
pub const CONFIG_SCSI_3W_9XXX_MODULE: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN: u32 = 8;
pub const CONFIG_VIDEO_KS0127_MODULE: u32 = 1;
pub const CONFIG_MVMDIO_MODULE: u32 = 1;
pub const CONFIG_HWLAT_TRACER: u32 = 1;
pub const CONFIG_SND_USB: u32 = 1;
pub const CONFIG_LOGIG940_FF: u32 = 1;
pub const CONFIG_VIDEOBUF2_MEMOPS_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS3232_HWMON: u32 = 1;
pub const CONFIG_RD_GZIP: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_E2I: u32 = 1;
pub const CONFIG_ARCH_HAS_CPU_RELAX: u32 = 1;
pub const CONFIG_HAVE_REGS_AND_STACK_ACCESS_API: u32 = 1;
pub const CONFIG_BCMA_HOST_PCI_POSSIBLE: u32 = 1;
pub const CONFIG_SND_SOC_TFA9879_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LTC4261_MODULE: u32 = 1;
pub const CONFIG_MMC_SDRICOH_CS_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADV_PCI1720_MODULE: u32 = 1;
pub const CONFIG_MISDN_W6692_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_MODULE: u32 = 1;
pub const CONFIG_THRUSTMASTER_FF: u32 = 1;
pub const CONFIG_MDIO_BUS: u32 = 1;
pub const CONFIG_TREE_RCU: u32 = 1;
pub const CONFIG_PWM_SYSFS: u32 = 1;
pub const CONFIG_FB_TFT_FBTFT_DEVICE_MODULE: u32 = 1;
pub const CONFIG_SOC_TI: u32 = 1;
pub const CONFIG_ALLOW_DEV_COREDUMP: u32 = 1;
pub const CONFIG_I2C_MUX_GPIO_MODULE: u32 = 1;
pub const CONFIG_SWIOTLB: u32 = 1;
pub const CONFIG_SND_USB_CAIAQ_MODULE: u32 = 1;
pub const CONFIG_USB_STORAGE_CYPRESS_ATACB_MODULE: u32 = 1;
pub const CONFIG_EXT4_FS_SECURITY: u32 = 1;
pub const CONFIG_SPEAKUP_SYNTH_DUMMY_MODULE: u32 = 1;
pub const CONFIG_ATH9K_HWRNG: u32 = 1;
pub const CONFIG_GRO_CELLS: u32 = 1;
pub const CONFIG_SECURITY_APPARMOR_HASH_DEFAULT: u32 = 1;
pub const CONFIG_SCSI_MVUMI_MODULE: u32 = 1;
pub const CONFIG_NET_TEAM_MODE_ACTIVEBACKUP_MODULE: u32 = 1;
pub const CONFIG_9P_FS_SECURITY: u32 = 1;
pub const CONFIG_SOC_CAMERA_MT9M111_MODULE: u32 = 1;
pub const CONFIG_IR_XMP_DECODER_MODULE: u32 = 1;
pub const CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN: u32 = 1;
pub const CONFIG_FB_TFT_SSD1325_MODULE: u32 = 1;
pub const CONFIG_BEFS_FS_MODULE: u32 = 1;
pub const CONFIG_SND_ALI5451_MODULE: u32 = 1;
pub const CONFIG_PCI_MSI_IRQ_DOMAIN: u32 = 1;
pub const CONFIG_INFINIBAND_USER_MAD_MODULE: u32 = 1;
pub const CONFIG_GENERIC_ADC_THERMAL_MODULE: u32 = 1;
pub const CONFIG_HID_ROCCAT_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_HP: u32 = 1;
pub const CONFIG_F71808E_WDT_MODULE: u32 = 1;
pub const CONFIG_HID_SENSOR_TEMP_MODULE: u32 = 1;
pub const CONFIG_INET_XFRM_MODE_TRANSPORT_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_MD5: u32 = 1;
pub const CONFIG_IMA_DEFAULT_TEMPLATE: &'static [u8; 7usize] = b"ima-ng\0";
pub const CONFIG_VIDEO_CS53L32A_MODULE: u32 = 1;
pub const CONFIG_IR_REDRAT3_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_VICAM_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_AD7879_SPI_MODULE: u32 = 1;
pub const CONFIG_PCMCIA_HERMES_MODULE: u32 = 1;
pub const CONFIG_TRANSPARENT_HUGEPAGE: u32 = 1;
pub const CONFIG_CLOCKSOURCE_VALIDATE_LAST_CYCLE: u32 = 1;
pub const CONFIG_USB_F_SS_LB_MODULE: u32 = 1;
pub const CONFIG_ISCSI_TCP_MODULE: u32 = 1;
pub const CONFIG_ATA_ACPI: u32 = 1;
pub const CONFIG_NFSD_V3: u32 = 1;
pub const CONFIG_PATA_ALI_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_MV88E6XXX_GLOBAL2: u32 = 1;
pub const CONFIG_X86_EXTENDED_PLATFORM: u32 = 1;
pub const CONFIG_ISDN_MPP: u32 = 1;
pub const CONFIG_GPIO_JANZ_TTL_MODULE: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE: u32 = 0;
pub const CONFIG_USB_CHIPIDEA_MODULE: u32 = 1;
pub const CONFIG_MFD_WL1273_CORE_MODULE: u32 = 1;
pub const CONFIG_RT2800USB_RT53XX: u32 = 1;
pub const CONFIG_SND_ECHO3G_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_FC0011_MODULE: u32 = 1;
pub const CONFIG_ACPI_PROCESSOR: u32 = 1;
pub const CONFIG_XEN_SCRUB_PAGES: u32 = 1;
pub const CONFIG_DVB_TDA10023_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_TEA5767_MODULE: u32 = 1;
pub const CONFIG_BATMAN_ADV_MODULE: u32 = 1;
pub const CONFIG_ELFCORE: u32 = 1;
pub const CONFIG_REGULATOR_BD9571MWV_MODULE: u32 = 1;
pub const CONFIG_ISDN_DRV_AVMB1_AVM_CS_MODULE: u32 = 1;
pub const CONFIG_NFT_REDIR_IPV6_MODULE: u32 = 1;
pub const CONFIG_HAVE_KVM: u32 = 1;
pub const CONFIG_SND_FIREWIRE: u32 = 1;
pub const CONFIG_EDAC_SKX_MODULE: u32 = 1;
pub const CONFIG_VIDEOBUF_DVB_MODULE: u32 = 1;
pub const CONFIG_COMEDI_PCMDA12_MODULE: u32 = 1;
pub const CONFIG_PCCARD_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_OV519_MODULE: u32 = 1;
pub const CONFIG_DM_LOG_WRITES_MODULE: u32 = 1;
pub const CONFIG_BINFMT_ELF: u32 = 1;
pub const CONFIG_RTC_DRV_RX4581_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS4349_MODULE: u32 = 1;
pub const CONFIG_NET_CLS_FLOWER_MODULE: u32 = 1;
pub const CONFIG_SCSI_PROC_FS: u32 = 1;
pub const CONFIG_RMI4_F11: u32 = 1;
pub const CONFIG_PARIDE_PG_MODULE: u32 = 1;
pub const CONFIG_I2C_HID_MODULE: u32 = 1;
pub const CONFIG_MD_RAID456_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_PCF50633_MODULE: u32 = 1;
pub const CONFIG_IIO_TRIGGER: u32 = 1;
pub const CONFIG_FB_AUO_K190X_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_IFORCE_USB: u32 = 1;
pub const CONFIG_SCHED_TRACER: u32 = 1;
pub const CONFIG_RTS5208_MODULE: u32 = 1;
pub const CONFIG_DSCC4_MODULE: u32 = 1;
pub const CONFIG_CICADA_PHY_MODULE: u32 = 1;
pub const CONFIG_UDF_NLS: u32 = 1;
pub const CONFIG_JOYSTICK_STINGER_MODULE: u32 = 1;
pub const CONFIG_HAVE_PERF_REGS: u32 = 1;
pub const CONFIG_PINCTRL_DENVERTON_MODULE: u32 = 1;
pub const CONFIG_CIFS_DEBUG: u32 = 1;
pub const CONFIG_LEDS_LP55XX_COMMON_MODULE: u32 = 1;
pub const CONFIG_HAVE_KVM_MSI: u32 = 1;
pub const CONFIG_MEDIA_ANALOG_TV_SUPPORT: u32 = 1;
pub const CONFIG_IP_PIMSM_V1: u32 = 1;
pub const CONFIG_BCACHE_MODULE: u32 = 1;
pub const CONFIG_INET6_AH_MODULE: u32 = 1;
pub const CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT: u32 = 1;
pub const CONFIG_SENSORS_MAX197_MODULE: u32 = 1;
pub const CONFIG_RAPIDIO_CHMAN_MODULE: u32 = 1;
pub const CONFIG_TARGET_CORE_MODULE: u32 = 1;
pub const CONFIG_AUFS_FS_MODULE: u32 = 1;
pub const CONFIG_VLSI_FIR_MODULE: u32 = 1;
pub const CONFIG_HID_XINMO_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_BNXT_RE_MODULE: u32 = 1;
pub const CONFIG_NFS_V4_SECURITY_LABEL: u32 = 1;
pub const CONFIG_USB_SERIAL_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX88_ALSA_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_ALTEON: u32 = 1;
pub const CONFIG_NFT_DUP_IPV4_MODULE: u32 = 1;
pub const CONFIG_SENSORS_GL518SM_MODULE: u32 = 1;
pub const CONFIG_MLX5_CORE_IPOIB: u32 = 1;
pub const CONFIG_USB_MON_MODULE: u32 = 1;
pub const CONFIG_COMEDI_CB_PCIMDAS_MODULE: u32 = 1;
pub const CONFIG_NTB_IDT_MODULE: u32 = 1;
pub const CONFIG_VGASTATE_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_FIXED_VOLTAGE_MODULE: u32 = 1;
pub const CONFIG_LCD_L4F00242T03_MODULE: u32 = 1;
pub const CONFIG_XEN_PVCALLS_FRONTEND_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_RENESAS: u32 = 1;
pub const CONFIG_SIGMATEL_FIR_MODULE: u32 = 1;
pub const CONFIG_VIDEO_SAA717X_MODULE: u32 = 1;
pub const CONFIG_KEYS: u32 = 1;
pub const CONFIG_XEN_PV_SMP: u32 = 1;
pub const CONFIG_REGULATOR_TPS6507X_MODULE: u32 = 1;
pub const CONFIG_BE2ISCSI_MODULE: u32 = 1;
pub const CONFIG_INET_XFRM_TUNNEL_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_FM3130_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_MAX9860_MODULE: u32 = 1;
pub const CONFIG_RMI4_2D_SENSOR: u32 = 1;
pub const CONFIG_ACPI_PROCESSOR_CSTATE: u32 = 1;
pub const CONFIG_TMP007_MODULE: u32 = 1;
pub const CONFIG_XEN_EFI: u32 = 1;
pub const CONFIG_IPMI_POWEROFF_MODULE: u32 = 1;
pub const CONFIG_SND_VMASTER: u32 = 1;
pub const CONFIG_NETFILTER_XT_MARK_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XTABLES_MODULE: u32 = 1;
pub const CONFIG_IP_VS_LBLC_MODULE: u32 = 1;
pub const CONFIG_HAVE_KVM_IRQ_BYPASS: u32 = 1;
pub const CONFIG_SYSTEM_BLACKLIST_KEYRING: u32 = 1;
pub const CONFIG_BLK_DEV_NULL_BLK_MODULE: u32 = 1;
pub const CONFIG_DP83640_PHY_MODULE: u32 = 1;
pub const CONFIG_SOFTLOCKUP_DETECTOR: u32 = 1;
pub const CONFIG_NFC_PN533_I2C_MODULE: u32 = 1;
pub const CONFIG_USB_ISP1760_HCD: u32 = 1;
pub const CONFIG_MFD_AXP20X_I2C_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_OPERA1_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_ECHAINIV_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_AUDITSYSCALL: u32 = 1;
pub const CONFIG_LEDS_BD2802_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_MC13783_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_STOWAWAY_MODULE: u32 = 1;
pub const CONFIG_FB_RIVA_MODULE: u32 = 1;
pub const CONFIG_ATM_HE_MODULE: u32 = 1;
pub const CONFIG_POWER_AVS: u32 = 1;
pub const CONFIG_IPMI_SI_MODULE: u32 = 1;
pub const CONFIG_TI_ADS1015_MODULE: u32 = 1;
pub const CONFIG_USB_STORAGE_DATAFAB_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_AF9005_MODULE: u32 = 1;
pub const CONFIG_MFD_RC5T583: u32 = 1;
pub const CONFIG_TCP_CONG_VEGAS_MODULE: u32 = 1;
pub const CONFIG_LEDS_88PM860X_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_USER_API_HASH_MODULE: u32 = 1;
pub const CONFIG_SENSORS_IBMPEX_MODULE: u32 = 1;
pub const CONFIG_BOOT_PRINTK_DELAY: u32 = 1;
pub const CONFIG_CHARGER_88PM860X_MODULE: u32 = 1;
pub const CONFIG_IWLMVM_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ADM1026_MODULE: u32 = 1;
pub const CONFIG_PATA_NINJA32_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_CCP_DD_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ADT7470_MODULE: u32 = 1;
pub const CONFIG_PM_SLEEP_SMP: u32 = 1;
pub const CONFIG_SPI_PXA2XX_PCI_MODULE: u32 = 1;
pub const CONFIG_FB_PM3_MODULE: u32 = 1;
pub const CONFIG_X86_16BIT: u32 = 1;
pub const CONFIG_CRYPTO_HW: u32 = 1;
pub const CONFIG_MAC80211_RC_MINSTREL_HT: u32 = 1;
pub const CONFIG_USB_EG20T_MODULE: u32 = 1;
pub const CONFIG_USB_STORAGE_KARMA_MODULE: u32 = 1;
pub const CONFIG_TTPCI_EEPROM_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_CYTTSP4_SPI_MODULE: u32 = 1;
pub const CONFIG_NTB_PERF_MODULE: u32 = 1;
pub const CONFIG_TEHUTI_MODULE: u32 = 1;
pub const CONFIG_PUNIT_ATOM_DEBUG_MODULE: u32 = 1;
pub const CONFIG_THUNDERBOLT_NET_MODULE: u32 = 1;
pub const CONFIG_SIS900_MODULE: u32 = 1;
pub const CONFIG_IIO_ST_MAGN_SPI_3AXIS_MODULE: u32 = 1;
pub const CONFIG_PCSPKR_PLATFORM: u32 = 1;
pub const CONFIG_LEDS_LP3952_MODULE: u32 = 1;
pub const CONFIG_HAVE_LIVEPATCH: u32 = 1;
pub const CONFIG_MEGARAID_LEGACY_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_POLY1305_X86_64_MODULE: u32 = 1;
pub const CONFIG_DVB_AV7110_IR: u32 = 1;
pub const CONFIG_CARDBUS: u32 = 1;
pub const CONFIG_ATH9K_AHB: u32 = 1;
pub const CONFIG_SENSORS_ISL29018_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1307_CENTURY: u32 = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_USA19W: u32 = 1;
pub const CONFIG_IIO_SSP_SENSORHUB_MODULE: u32 = 1;
pub const CONFIG_HID_GREENASIA_MODULE: u32 = 1;
pub const CONFIG_ORINOCO_USB_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_ILI210X_MODULE: u32 = 1;
pub const CONFIG_XEN_ACPI_PROCESSOR: u32 = 1;
pub const CONFIG_INTEGRITY_ASYMMETRIC_KEYS: u32 = 1;
pub const CONFIG_HWSPINLOCK: u32 = 1;
pub const CONFIG_SERIAL_RP2_NR_UARTS: u32 = 32;
pub const CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE: u32 = 438;
pub const CONFIG_BACKLIGHT_DA903X_MODULE: u32 = 1;
pub const CONFIG_KALLSYMS_ABSOLUTE_PERCPU: u32 = 1;
pub const CONFIG_INTEL_POWERCLAMP_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DEFAULT_BUF_SIZE_KB: u32 = 2048;
pub const CONFIG_BIG_KEYS: u32 = 1;
pub const CONFIG_NFC_ST21NFCA_I2C_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_ADP5520_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_FSL_ESAI_MODULE: u32 = 1;
pub const CONFIG_SMS_USB_DRV_MODULE: u32 = 1;
pub const CONFIG_ACPI_AC: u32 = 1;
pub const CONFIG_TLS_MODULE: u32 = 1;
pub const CONFIG_ACPI_HOTPLUG_IOAPIC: u32 = 1;
pub const CONFIG_HID_STEELSERIES_MODULE: u32 = 1;
pub const CONFIG_JFFS2_FS_WRITEBUFFER: u32 = 1;
pub const CONFIG_BMI160_SPI_MODULE: u32 = 1;
pub const CONFIG_SPI_MASTER: u32 = 1;
pub const CONFIG_FB_TFT_RA8875_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_OPTICON_MODULE: u32 = 1;
pub const CONFIG_RTL8180_MODULE: u32 = 1;
pub const CONFIG_DS4424_MODULE: u32 = 1;
pub const CONFIG_LWTUNNEL: u32 = 1;
pub const CONFIG_IEEE802154_AT86RF230_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_ARIZONA_MICSUPP_MODULE: u32 = 1;
pub const CONFIG_AD5504_MODULE: u32 = 1;
pub const CONFIG_SERIAL_SC16IS7XX_I2C: u32 = 1;
pub const CONFIG_DVB_TC90522_MODULE: u32 = 1;
pub const CONFIG_DVB_NXT200X_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LM87_MODULE: u32 = 1;
pub const CONFIG_SND_SST_IPC_ACPI_MODULE: u32 = 1;
pub const CONFIG_PALMAS_GPADC_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_THROTTLING: u32 = 1;
pub const CONFIG_VT_HW_CONSOLE_BINDING: u32 = 1;
pub const CONFIG_AIX_PARTITION: u32 = 1;
pub const CONFIG_GPIO_104_IDIO_16_MODULE: u32 = 1;
pub const CONFIG_NET_TEAM_MODE_BROADCAST_MODULE: u32 = 1;
pub const CONFIG_MPLS: u32 = 1;
pub const CONFIG_NF_TABLES_NETDEV_MODULE: u32 = 1;
pub const CONFIG_CHARGER_SMB347_MODULE: u32 = 1;
pub const CONFIG_NFC_S3FWRN5_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TW9903_MODULE: u32 = 1;
pub const CONFIG_ATH9K_CHANNEL_CONTEXT: u32 = 1;
pub const CONFIG_NET_ACT_GACT_MODULE: u32 = 1;
pub const CONFIG_SLIP_MODE_SLIP6: u32 = 1;
pub const CONFIG_RTL8192E_MODULE: u32 = 1;
pub const CONFIG_HID_GYRATION_MODULE: u32 = 1;
pub const CONFIG_PA12203001_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AK4642_MODULE: u32 = 1;
pub const CONFIG_GPIO_WHISKEY_COVE_MODULE: u32 = 1;
pub const CONFIG_IRDA_CACHE_LAST_LSAP: u32 = 1;
pub const CONFIG_SRAM: u32 = 1;
pub const CONFIG_NFT_MASQ_IPV4_MODULE: u32 = 1;
pub const CONFIG_USB_WDM_MODULE: u32 = 1;
pub const CONFIG_PATA_TOSHIBA_MODULE: u32 = 1;
pub const CONFIG_BT_HCIBCM203X_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_WM8400_MODULE: u32 = 1;
pub const CONFIG_THERMAL_HWMON: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_COMPOSITE_MODULE: u32 = 1;
pub const CONFIG_I2C_MUX_PCA9541_MODULE: u32 = 1;
pub const CONFIG_MAX1363_MODULE: u32 = 1;
pub const CONFIG_SND_USB_HIFACE_MODULE: u32 = 1;
pub const CONFIG_VIDEO_EM28XX_DVB_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_KOBIL_SCT_MODULE: u32 = 1;
pub const CONFIG_HDLC_FR_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_UPD78F0730_MODULE: u32 = 1;
pub const CONFIG_FB_ATY128_BACKLIGHT: u32 = 1;
pub const CONFIG_USB_GSPCA_TOUPTEK_MODULE: u32 = 1;
pub const CONFIG_GENEVE_MODULE: u32 = 1;
pub const CONFIG_XZ_DEC_X86: u32 = 1;
pub const CONFIG_MLX5_INFINIBAND_MODULE: u32 = 1;
pub const CONFIG_RMI4_SPI_MODULE: u32 = 1;
pub const CONFIG_MAC80211_LEDS: u32 = 1;
pub const CONFIG_INPUT_JOYDEV_MODULE: u32 = 1;
pub const CONFIG_FB_MATROX_MAVEN_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_LKKBD_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_TPROXY_MODULE: u32 = 1;
pub const CONFIG_HIBERNATE_CALLBACKS: u32 = 1;
pub const CONFIG_MEN_Z188_ADC_MODULE: u32 = 1;
pub const CONFIG_LEDS_MC13783_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_DW_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS42L56_MODULE: u32 = 1;
pub const CONFIG_IP_DCCP_MODULE: u32 = 1;
pub const CONFIG_LIBIPW_MODULE: u32 = 1;
pub const CONFIG_FIREWIRE_OHCI_MODULE: u32 = 1;
pub const CONFIG_ATH10K_USB_MODULE: u32 = 1;
pub const CONFIG_PCIEASPM_DEBUG: u32 = 1;
pub const CONFIG_THERMAL_EMERGENCY_POWEROFF_DELAY_MS: u32 = 0;
pub const CONFIG_COMMON_CLK_S2MPS11_MODULE: u32 = 1;
pub const CONFIG_USB_ACM_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADL_PCI9118_MODULE: u32 = 1;
pub const CONFIG_USB_RTL8150_MODULE: u32 = 1;
pub const CONFIG_NVME_CORE_MODULE: u32 = 1;
pub const CONFIG_INTEL_TURBO_MAX_3: u32 = 1;
pub const CONFIG_GPIO_MAX7300_MODULE: u32 = 1;
pub const CONFIG_USB_MSI2500_MODULE: u32 = 1;
pub const CONFIG_CRC16: u32 = 1;
pub const CONFIG_BACKLIGHT_SKY81452_MODULE: u32 = 1;
pub const CONFIG_USB_NET_AX8817X_MODULE: u32 = 1;
pub const CONFIG_SND_EMU10K1_MODULE: u32 = 1;
pub const CONFIG_GENERIC_CALIBRATE_DELAY: u32 = 1;
pub const CONFIG_CRYPTO_GF128MUL: u32 = 1;
pub const CONFIG_UPROBE_EVENTS: u32 = 1;
pub const CONFIG_NLS_ISO8859_6_MODULE: u32 = 1;
pub const CONFIG_NET_CLS: u32 = 1;
pub const CONFIG_ADF4350_MODULE: u32 = 1;
pub const CONFIG_XFS_RT: u32 = 1;
pub const CONFIG_SI7005_MODULE: u32 = 1;
pub const CONFIG_COMEDI_S626_MODULE: u32 = 1;
pub const CONFIG_EFI_SIGNATURE_LIST_PARSER: u32 = 1;
pub const CONFIG_SND_INDIGO_MODULE: u32 = 1;
pub const CONFIG_AX25_MODULE: u32 = 1;
pub const CONFIG_SND_YMFPCI_MODULE: u32 = 1;
pub const CONFIG_TMPFS: u32 = 1;
pub const CONFIG_MFD_LM3533_MODULE: u32 = 1;
pub const CONFIG_HP206C_MODULE: u32 = 1;
pub const CONFIG_HOSTAP_MODULE: u32 = 1;
pub const CONFIG_RADIX_TREE_MULTIORDER: u32 = 1;
pub const CONFIG_SOC_CAMERA_OV5642_MODULE: u32 = 1;
pub const CONFIG_NFT_CT_MODULE: u32 = 1;
pub const CONFIG_ANON_INODES: u32 = 1;
pub const CONFIG_CADENCE_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_USB_OHCI_HCD_PLATFORM: u32 = 1;
pub const CONFIG_SND_SOC_WM8711_MODULE: u32 = 1;
pub const CONFIG_VIDEO_EM28XX_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_936_MODULE: u32 = 1;
pub const CONFIG_HAMACHI_MODULE: u32 = 1;
pub const CONFIG_EXTCON_ARIZONA_MODULE: u32 = 1;
pub const CONFIG_ET131X_MODULE: u32 = 1;
pub const CONFIG_SURFACE_3_BUTTON_MODULE: u32 = 1;
pub const CONFIG_IR_ITE_CIR_MODULE: u32 = 1;
pub const CONFIG_WCN36XX_MODULE: u32 = 1;
pub const CONFIG_DVB_BUDGET_MODULE: u32 = 1;
pub const CONFIG_FUTEX: u32 = 1;
pub const CONFIG_CRYPTO_ANUBIS_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_AT_A2150_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_LABPC_ISA_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_HX8357D_MODULE: u32 = 1;
pub const CONFIG_VIRTIO_PCI: u32 = 1;
pub const CONFIG_TCP_CONG_NV_MODULE: u32 = 1;
pub const CONFIG_HID_SENSOR_ALS_MODULE: u32 = 1;
pub const CONFIG_MCP320X_MODULE: u32 = 1;
pub const CONFIG_MISDN_HFCMULTI_MODULE: u32 = 1;
pub const CONFIG_MMC_SPI_MODULE: u32 = 1;
pub const CONFIG_CONSOLE_LOGLEVEL_DEFAULT: u32 = 7;
pub const CONFIG_QCOM_HIDMA_MODULE: u32 = 1;
pub const CONFIG_MWAVE_MODULE: u32 = 1;
pub const CONFIG_PCMCIA_3C574_MODULE: u32 = 1;
pub const CONFIG_HISAX_AVM_A1_PCMCIA: u32 = 1;
pub const CONFIG_USB_GSPCA_SQ930X_MODULE: u32 = 1;
pub const CONFIG_RTL8192SE_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_SPACEBALL_MODULE: u32 = 1;
pub const CONFIG_REGMAP_I2C: u32 = 1;
pub const CONFIG_AD5449_MODULE: u32 = 1;
pub const CONFIG_ZPA2326_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_FAST_MULTIPLIER: u32 = 1;
pub const CONFIG_INPUT_MATRIXKMAP_MODULE: u32 = 1;
pub const CONFIG_ATH9K_DEBUGFS: u32 = 1;
pub const CONFIG_MFD_BCM590XX_MODULE: u32 = 1;
pub const CONFIG_DVB_CXD2099_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_REALTEK: u32 = 1;
pub const CONFIG_VIDEO_VIVID_CEC: u32 = 1;
pub const CONFIG_MFD_SM501_GPIO: u32 = 1;
pub const CONFIG_DVB_DM1105_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG: u32 = 1;
pub const CONFIG_MFD_RDC321X_MODULE: u32 = 1;
pub const CONFIG_AD5421_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_XPAD_FF: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_HL_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_LP8788_MODULE: u32 = 1;
pub const CONFIG_MEGARAID_SAS_MODULE: u32 = 1;
pub const CONFIG_PATA_HPT3X2N_MODULE: u32 = 1;
pub const CONFIG_INTEL_TH_MODULE: u32 = 1;
pub const CONFIG_DVB_CORE_MODULE: u32 = 1;
pub const CONFIG_NFSD_V2_ACL: u32 = 1;
pub const CONFIG_COMEDI_ME_DAQ_MODULE: u32 = 1;
pub const CONFIG_SDR_PLATFORM_DRIVERS: u32 = 1;
pub const CONFIG_CAN_JANZ_ICAN3_MODULE: u32 = 1;
pub const CONFIG_USB_NET2280_MODULE: u32 = 1;
pub const CONFIG_ISL29003_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_USER_API_MODULE: u32 = 1;
pub const CONFIG_RTC_HCTOSYS: u32 = 1;
pub const CONFIG_I2C_OCORES_MODULE: u32 = 1;
pub const CONFIG_NAU7802_MODULE: u32 = 1;
pub const CONFIG_DRM_I915_CAPTURE_ERROR: u32 = 1;
pub const CONFIG_SECURITY_NETWORK: u32 = 1;
pub const CONFIG_FMC_CHARDEV_MODULE: u32 = 1;
pub const CONFIG_DRM_VBOXVIDEO_MODULE: u32 = 1;
pub const CONFIG_SERIAL_CORE_CONSOLE: u32 = 1;
pub const CONFIG_INTEL_XWAY_PHY_MODULE: u32 = 1;
pub const CONFIG_HOTPLUG_PCI_CPCI: u32 = 1;
pub const CONFIG_ACPI_CPPC_LIB: u32 = 1;
pub const CONFIG_HUGETLB_PAGE: u32 = 1;
pub const CONFIG_MTD_SM_COMMON_MODULE: u32 = 1;
pub const CONFIG_HW_RANDOM_TPM_MODULE: u32 = 1;
pub const CONFIG_SENSORS_XGENE_MODULE: u32 = 1;
pub const CONFIG_CIFS_WEAK_PW_HASH: u32 = 1;
pub const CONFIG_DVB_SMIPCIE_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_GUNZE_MODULE: u32 = 1;
pub const CONFIG_NFC_ST_NCI_SPI_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LM78_MODULE: u32 = 1;
pub const CONFIG_SCSI_UFS_DWC_TC_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_EMULEX: u32 = 1;
pub const CONFIG_WIZNET_W5100_MODULE: u32 = 1;
pub const CONFIG_REGMAP_IRQ: u32 = 1;
pub const CONFIG_SENSORS_K10TEMP_MODULE: u32 = 1;
pub const CONFIG_USB_HID_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_AF9015_MODULE: u32 = 1;
pub const CONFIG_ISI_MODULE: u32 = 1;
pub const CONFIG_DELL_SMBIOS_MODULE: u32 = 1;
pub const CONFIG_FPGA_MODULE: u32 = 1;
pub const CONFIG_MLX5_EN_IPSEC: u32 = 1;
pub const CONFIG_UBIFS_FS_MODULE: u32 = 1;
pub const CONFIG_DRM_AMDGPU_SI: u32 = 1;
pub const CONFIG_PARIDE_PT_MODULE: u32 = 1;
pub const CONFIG_TEST_USER_COPY_MODULE: u32 = 1;
pub const CONFIG_RTL8192CU_MODULE: u32 = 1;
pub const CONFIG_ATM_DRIVERS: u32 = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_USA28: u32 = 1;
pub const CONFIG_CRYPTO_TGR192_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_RBD_MODULE: u32 = 1;
pub const CONFIG_SENSORS_HMC5843_MODULE: u32 = 1;
pub const CONFIG_SERIO_PS2MULT_MODULE: u32 = 1;
pub const CONFIG_VSOCKETS_DIAG_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_TPS6105X_MODULE: u32 = 1;
pub const CONFIG_USER_STACKTRACE_SUPPORT: u32 = 1;
pub const CONFIG_MEGARAID_MAILBOX_MODULE: u32 = 1;
pub const CONFIG_LANMEDIA_MODULE: u32 = 1;
pub const CONFIG_NF_TABLES_MODULE: u32 = 1;
pub const CONFIG_BATMAN_ADV_MCAST: u32 = 1;
pub const CONFIG_IT8712F_WDT_MODULE: u32 = 1;
pub const CONFIG_SLUB_DEBUG: u32 = 1;
pub const CONFIG_RTC_DRV_M41T80_WDT: u32 = 1;
pub const CONFIG_WIZNET_W5300_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_670X_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_MD: u32 = 1;
pub const CONFIG_UCS2_STRING: u32 = 1;
pub const CONFIG_MMC_VUB300_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_AIRCABLE_MODULE: u32 = 1;
pub const CONFIG_IP_SET_BITMAP_IP_MODULE: u32 = 1;
pub const CONFIG_GPIO_VX855_MODULE: u32 = 1;
pub const CONFIG_MAC_EMUMOUSEBTN_MODULE: u32 = 1;
pub const CONFIG_RAPIDIO_CPS_XX_MODULE: u32 = 1;
pub const CONFIG_MMC_MTK_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8978_MODULE: u32 = 1;
pub const CONFIG_DECNET_NF_GRABULATOR_MODULE: u32 = 1;
pub const CONFIG_BNXT_DCB: u32 = 1;
pub const CONFIG_HIST_TRIGGERS: u32 = 1;
pub const CONFIG_MTD_SBC_GXX_MODULE: u32 = 1;
pub const CONFIG_NFC_NCI_SPI_MODULE: u32 = 1;
pub const CONFIG_USB_F_RNDIS_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_INGRESS_MODULE: u32 = 1;
pub const CONFIG_BCMA_MODULE: u32 = 1;
pub const CONFIG_DMADEVICES: u32 = 1;
pub const CONFIG_XENFS_MODULE: u32 = 1;
pub const CONFIG_AXP288_CHARGER_MODULE: u32 = 1;
pub const CONFIG_SCA3000_MODULE: u32 = 1;
pub const CONFIG_ATH10K_SDIO_MODULE: u32 = 1;
pub const CONFIG_CORTINA_PHY_MODULE: u32 = 1;
pub const CONFIG_SCSI_AACRAID_MODULE: u32 = 1;
pub const CONFIG_MISDN_HFCUSB_MODULE: u32 = 1;
pub const CONFIG_ACPI_APEI_MEMORY_FAILURE: u32 = 1;
pub const CONFIG_BACKLIGHT_LM3639_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_EVENTS: u32 = 1;
pub const CONFIG_MOUSE_PS2_ELANTECH: u32 = 1;
pub const CONFIG_MFD_DA9062_MODULE: u32 = 1;
pub const CONFIG_PINCTRL: u32 = 1;
pub const CONFIG_HID_SENSOR_DEVICE_ROTATION_MODULE: u32 = 1;
pub const CONFIG_IPV6_NDISC_NODETYPE: u32 = 1;
pub const CONFIG_HFS_FS_MODULE: u32 = 1;
pub const CONFIG_INTEL_VBTN_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8985_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_MSM6242_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_TECHNISAT_USB2_MODULE: u32 = 1;
pub const CONFIG_PCI_LABEL: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_1251_MODULE: u32 = 1;
pub const CONFIG_USB_F_MIDI_MODULE: u32 = 1;
pub const CONFIG_EDAC_X38_MODULE: u32 = 1;
pub const CONFIG_FANOTIFY: u32 = 1;
pub const CONFIG_MEDIA_TUNER_MXL301RF_MODULE: u32 = 1;
pub const CONFIG_SPI_BUTTERFLY_MODULE: u32 = 1;
pub const CONFIG_ISDN_CAPI_CAPIDRV_MODULE: u32 = 1;
pub const CONFIG_SONYPI_COMPAT: u32 = 1;
pub const CONFIG_IP_VS_PROTO_SCTP: u32 = 1;
pub const CONFIG_SP5100_TCO_MODULE: u32 = 1;
pub const CONFIG_WIL6210_DEBUGFS: u32 = 1;
pub const CONFIG_GREYBUS_PWM_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CONNLABEL_MODULE: u32 = 1;
pub const CONFIG_SGETMASK_SYSCALL: u32 = 1;
pub const CONFIG_SATA_SIL_MODULE: u32 = 1;
pub const CONFIG_ALTERA_STAPL_MODULE: u32 = 1;
pub const CONFIG_USERFAULTFD: u32 = 1;
pub const CONFIG_CGROUP_SCHED: u32 = 1;
pub const CONFIG_SND_HDA_RECONFIG: u32 = 1;
pub const CONFIG_VIDEO_ADV7842_MODULE: u32 = 1;
pub const CONFIG_QUEUED_RWLOCKS: u32 = 1;
pub const CONFIG_SYSVIPC: u32 = 1;
pub const CONFIG_COMEDI_NI_LABPC_CS_MODULE: u32 = 1;
pub const CONFIG_HOSTAP_PLX_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_GIGANTIC_PAGE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_ECM_SUBSET: u32 = 1;
pub const CONFIG_MTD_UBI_BLOCK: u32 = 1;
pub const CONFIG_HAVE_DEBUG_KMEMLEAK: u32 = 1;
pub const CONFIG_JOYSTICK_INTERACT_MODULE: u32 = 1;
pub const CONFIG_SMSC911X_MODULE: u32 = 1;
pub const CONFIG_GPIO_MAX3191X_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DT282X_MODULE: u32 = 1;
pub const CONFIG_DVB_TDA10071_MODULE: u32 = 1;
pub const CONFIG_HDLC_CISCO_MODULE: u32 = 1;
pub const CONFIG_SQUASHFS_ZSTD: u32 = 1;
pub const CONFIG_MLX4_INFINIBAND_MODULE: u32 = 1;
pub const CONFIG_DVB_OR51211_MODULE: u32 = 1;
pub const CONFIG_RT2X00_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_863_MODULE: u32 = 1;
pub const CONFIG_SND_DESIGNWARE_I2S_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ADT7X10_MODULE: u32 = 1;
pub const CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT: u32 = 13;
pub const CONFIG_USB_G_HID_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_GPIO_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_FTP_MODULE: u32 = 1;
pub const CONFIG_NFC_MRVL_UART_MODULE: u32 = 1;
pub const CONFIG_CHELSIO_T4_MODULE: u32 = 1;
pub const CONFIG_MODULES: u32 = 1;
pub const CONFIG_RPMSG_MODULE: u32 = 1;
pub const CONFIG_IP_NF_MATCH_ECN_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_PHONET: u32 = 1;
pub const CONFIG_DWC_XLGMAC_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MAX8660_MODULE: u32 = 1;
pub const CONFIG_USB_GADGET_MODULE: u32 = 1;
pub const CONFIG_EEPROM_LEGACY_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_NES_MODULE: u32 = 1;
pub const CONFIG_FB_IMSTT: u32 = 1;
pub const CONFIG_USB_GSPCA_SPCA506_MODULE: u32 = 1;
pub const CONFIG_CAN_CC770_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_PATA_ARTOP_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_NEWTON_MODULE: u32 = 1;
pub const CONFIG_HARDLOCKUP_DETECTOR: u32 = 1;
pub const CONFIG_VIDEO_CX88_DVB_MODULE: u32 = 1;
pub const CONFIG_GPIO_DA9055_MODULE: u32 = 1;
pub const CONFIG_MQ_IOSCHED_DEADLINE_MODULE: u32 = 1;
pub const CONFIG_VIDEO_EM28XX_ALSA_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_MXL5005S_MODULE: u32 = 1;
pub const CONFIG_INPUT_TWL4030_VIBRA_MODULE: u32 = 1;
pub const CONFIG_SECURITY_DEFAULT_DISPLAY_NAME: &'static [u8; 9usize] = b"apparmor\0";
pub const CONFIG_USB_HIDDEV: u32 = 1;
pub const CONFIG_IOMMU_IOVA: u32 = 1;
pub const CONFIG_INFINIBAND_IPOIB_MODULE: u32 = 1;
pub const CONFIG_DUMMY_CONSOLE_COLUMNS: u32 = 80;
pub const CONFIG_SENSORS_APDS990X_MODULE: u32 = 1;
pub const CONFIG_USB_ETH_RNDIS: u32 = 1;
pub const CONFIG_AD7606_IFACE_PARALLEL_MODULE: u32 = 1;
pub const CONFIG_XXHASH: u32 = 1;
pub const CONFIG_DVB_SI21XX_MODULE: u32 = 1;
pub const CONFIG_PATA_WINBOND_MODULE: u32 = 1;
pub const CONFIG_SOUND_MODULE: u32 = 1;
pub const CONFIG_NFT_MASQ_MODULE: u32 = 1;
pub const CONFIG_COMEDI_RTI802_MODULE: u32 = 1;
pub const CONFIG_NFT_QUOTA_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_AUO_PIXCIR_MODULE: u32 = 1;
pub const CONFIG_JOLIET: u32 = 1;
pub const CONFIG_SERIAL_SC16IS7XX_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_VP7045_MODULE: u32 = 1;
pub const CONFIG_USB_NET2272_DMA: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE: u32 = 1;
pub const CONFIG_KPROBES_ON_FTRACE: u32 = 1;
pub const CONFIG_BNX2X_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_TDA9887_MODULE: u32 = 1;
pub const CONFIG_ADVANTECH_WDT_MODULE: u32 = 1;
pub const CONFIG_AUDIT_WATCH: u32 = 1;
pub const CONFIG_CRYPTO_TEA_MODULE: u32 = 1;
pub const CONFIG_AD5624R_SPI_MODULE: u32 = 1;
pub const CONFIG_ARCH_HIBERNATION_POSSIBLE: u32 = 1;
pub const CONFIG_SND_SOC_SI476X_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_LME2510_MODULE: u32 = 1;
pub const CONFIG_PROC_CHILDREN: u32 = 1;
pub const CONFIG_PDC_ADMA_MODULE: u32 = 1;
pub const CONFIG_SND_VXPOCKET_MODULE: u32 = 1;
pub const CONFIG_SND_USB_LINE6_MODULE: u32 = 1;
pub const CONFIG_UNIX: u32 = 1;
pub const CONFIG_USB_CATC_MODULE: u32 = 1;
pub const CONFIG_USB_NET_DRIVERS_MODULE: u32 = 1;
pub const CONFIG_QNX6FS_FS_MODULE: u32 = 1;
pub const CONFIG_AXP20X_POWER_MODULE: u32 = 1;
pub const CONFIG_NO_HZ_COMMON: u32 = 1;
pub const CONFIG_MINIX_FS_MODULE: u32 = 1;
pub const CONFIG_DRM_MIPI_DSI: u32 = 1;
pub const CONFIG_BRCMSMAC_MODULE: u32 = 1;
pub const CONFIG_XEN_DEV_EVTCHN_MODULE: u32 = 1;
pub const CONFIG_HAVE_CLK: u32 = 1;
pub const CONFIG_CRYPTO_HASH2: u32 = 1;
pub const CONFIG_CARL9170_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_CONEXANT_MODULE: u32 = 1;
pub const CONFIG_RMI4_F54: u32 = 1;
pub const CONFIG_CRYPTO_LZ4HC_MODULE: u32 = 1;
pub const CONFIG_DVB_CX24117_MODULE: u32 = 1;
pub const CONFIG_THERMAL_GOV_STEP_WISE: u32 = 1;
pub const CONFIG_SND_RME9652_MODULE: u32 = 1;
pub const CONFIG_MTD_ABSENT_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_88PM860X_MODULE: u32 = 1;
pub const CONFIG_DEFAULT_HOSTNAME: &'static [u8; 7usize] = b"(none)\0";
pub const CONFIG_SRCU: u32 = 1;
pub const CONFIG_COMMON_CLK_SI5351_MODULE: u32 = 1;
pub const CONFIG_NLS_KOI8_R_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ADT7410_MODULE: u32 = 1;
pub const CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS: u32 = 2;
pub const CONFIG_THUNDER_NIC_VF_MODULE: u32 = 1;
pub const CONFIG_IP_SET_HASH_NETPORTNET_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_SONIXB_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_RTL28XXU_MODULE: u32 = 1;
pub const CONFIG_CARDMAN_4040_MODULE: u32 = 1;
pub const CONFIG_MMC_REALTEK_PCI_MODULE: u32 = 1;
pub const CONFIG_USB_STORAGE_ISD200_MODULE: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_POWERSAVE: u32 = 1;
pub const CONFIG_USB_GSPCA_OV534_9_MODULE: u32 = 1;
pub const CONFIG_RIONET_MODULE: u32 = 1;
pub const CONFIG_NFS_FS_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_TWOFISH_X86_64_MODULE: u32 = 1;
pub const CONFIG_USB_NET_SMSC95XX_MODULE: u32 = 1;
pub const CONFIG_CRASH_DUMP: u32 = 1;
pub const CONFIG_MEMBARRIER: u32 = 1;
pub const CONFIG_FB_SM712_MODULE: u32 = 1;
pub const CONFIG_CEC_CORE_MODULE: u32 = 1;
pub const CONFIG_LEDS_LM3533_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ZX_AUD96P22_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_ADDR_TRANS: u32 = 1;
pub const CONFIG_BLK_DEV_IO_TRACE: u32 = 1;
pub const CONFIG_XPS: u32 = 1;
pub const CONFIG_RCU_PERF_TEST_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_QAT_DH895xCC_MODULE: u32 = 1;
pub const CONFIG_COMEDI_8255_PCI_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_SKBEDIT_MODULE: u32 = 1;
pub const CONFIG_VIDEO_PCI_SKELETON_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADV_PCI1723_MODULE: u32 = 1;
pub const CONFIG_INET_ESP_MODULE: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_DEVELOP: u32 = 1;
pub const CONFIG_SGL_ALLOC: u32 = 1;
pub const CONFIG_AD7816_MODULE: u32 = 1;
pub const CONFIG_HPET_TIMER: u32 = 1;
pub const CONFIG_LCD_TDO24M_MODULE: u32 = 1;
pub const CONFIG_BCH_CONST_M: u32 = 14;
pub const CONFIG_LZ4_DECOMPRESS: u32 = 1;
pub const CONFIG_INPUT_GPIO_BEEPER_MODULE: u32 = 1;
pub const CONFIG_NFC_HCI_MODULE: u32 = 1;
pub const CONFIG_GPIO_MAX732X_MODULE: u32 = 1;
pub const CONFIG_HSI_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_ZONES: u32 = 1;
pub const CONFIG_DP83848_PHY_MODULE: u32 = 1;
pub const CONFIG_EFI_RUNTIME_MAP: u32 = 1;
pub const CONFIG_NF_CONNTRACK_IPV6_MODULE: u32 = 1;
pub const CONFIG_FONT_SUPPORT: u32 = 1;
pub const CONFIG_ADVISE_SYSCALLS: u32 = 1;
pub const CONFIG_MD: u32 = 1;
pub const CONFIG_CRYPTO_ALGAPI: u32 = 1;
pub const CONFIG_FDDI: u32 = 1;
pub const CONFIG_IR_SERIAL_MODULE: u32 = 1;
pub const CONFIG_SENSORS_VT8231_MODULE: u32 = 1;
pub const CONFIG_DVB_BUDGET_CI_MODULE: u32 = 1;
pub const CONFIG_PARIDE_FIT3_MODULE: u32 = 1;
pub const CONFIG_COMEDI_KE_COUNTER_MODULE: u32 = 1;
pub const CONFIG_EDAC_I3200_MODULE: u32 = 1;
pub const CONFIG_SLUB_MEMCG_SYSFS_ON: u32 = 1;
pub const CONFIG_CEPH_FSCACHE: u32 = 1;
pub const CONFIG_INPUT_KXTJ9_MODULE: u32 = 1;
pub const CONFIG_VIDEO_ADV7604_MODULE: u32 = 1;
pub const CONFIG_SND_SEQ_MIDI_EMUL_MODULE: u32 = 1;
pub const CONFIG_BSD_PROCESS_ACCT_V3: u32 = 1;
pub const CONFIG_NET_VENDOR_WIZNET: u32 = 1;
pub const CONFIG_SOC_CAMERA_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_SCSI_DMX3191D_MODULE: u32 = 1;
pub const CONFIG_FONTS: u32 = 1;
pub const CONFIG_USB_G_DBGP_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CGROUP_MODULE: u32 = 1;
pub const CONFIG_TABLET_USB_GTCO_MODULE: u32 = 1;
pub const CONFIG_AD2S90_MODULE: u32 = 1;
pub const CONFIG_RAPIDIO_TSI57X_MODULE: u32 = 1;
pub const CONFIG_MLXSW_I2C_MODULE: u32 = 1;
pub const CONFIG_USB_CYPRESS_CY7C63_MODULE: u32 = 1;
pub const CONFIG_OPT3001_MODULE: u32 = 1;
pub const CONFIG_EEPROM_AT25_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_MID_MODULE: u32 = 1;
pub const CONFIG_RD_BZIP2: u32 = 1;
pub const CONFIG_MFD_VIPERBOARD_MODULE: u32 = 1;
pub const CONFIG_WANT_DEV_COREDUMP: u32 = 1;
pub const CONFIG_INPUT_UINPUT: u32 = 1;
pub const CONFIG_SERIAL_ARC_NR_PORTS: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_CHECKSUM_MODULE: u32 = 1;
pub const CONFIG_CHARGER_TPS65090_MODULE: u32 = 1;
pub const CONFIG_NVM_PBLK_MODULE: u32 = 1;
pub const CONFIG_PM_OPP: u32 = 1;
pub const CONFIG_IOSF_MBI_DEBUG: u32 = 1;
pub const CONFIG_UNWINDER_FRAME_POINTER: u32 = 1;
pub const CONFIG_POWER_RESET_RESTART: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_GPIO_MODULE: u32 = 1;
pub const CONFIG_RTLWIFI_USB_MODULE: u32 = 1;
pub const CONFIG_AUFS_BRANCH_MAX_127: u32 = 1;
pub const CONFIG_TCG_ATMEL_MODULE: u32 = 1;
pub const CONFIG_MLX5_ACCEL: u32 = 1;
pub const CONFIG_X86_INTEL_UMIP: u32 = 1;
pub const CONFIG_TINYDRM_MI0283QT_MODULE: u32 = 1;
pub const CONFIG_AFE4404_MODULE: u32 = 1;
pub const CONFIG_DVB_MB86A16_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_SIMPLE_MODULE: u32 = 1;
pub const CONFIG_SND_OXYGEN_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_ATKBD: u32 = 1;
pub const CONFIG_SCSI_QLA_ISCSI_MODULE: u32 = 1;
pub const CONFIG_AD5446_MODULE: u32 = 1;
pub const CONFIG_HAVE_MEMBLOCK_NODE_MAP: u32 = 1;
pub const CONFIG_X86_PLATFORM_DEVICES: u32 = 1;
pub const CONFIG_IIO_ST_MAGN_I2C_3AXIS_MODULE: u32 = 1;
pub const CONFIG_LIBNVDIMM: u32 = 1;
pub const CONFIG_NET_IP_TUNNEL_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_ADDR_TRANS_CONFIGFS: u32 = 1;
pub const CONFIG_WANXL_MODULE: u32 = 1;
pub const CONFIG_MTD_CFI_I1: u32 = 1;
pub const CONFIG_NF_NAT_MODULE: u32 = 1;
pub const CONFIG_LEDS_PWM_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2780_MODULE: u32 = 1;
pub const CONFIG_MAX_RAW_DEVS: u32 = 256;
pub const CONFIG_UBIFS_FS_ZLIB: u32 = 1;
pub const CONFIG_W83877F_WDT_MODULE: u32 = 1;
pub const CONFIG_WAFER_WDT_MODULE: u32 = 1;
pub const CONFIG_USB_U132_HCD_MODULE: u32 = 1;
pub const CONFIG_VIDEO_UPD64031A_MODULE: u32 = 1;
pub const CONFIG_BATTERY_88PM860X_MODULE: u32 = 1;
pub const CONFIG_FSI_SCOM_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_XIRCOM_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_INTEGRITY: u32 = 1;
pub const CONFIG_DVB_USB_AZ6027_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_OKI: u32 = 1;
pub const CONFIG_MOUSE_BCM5974_MODULE: u32 = 1;
pub const CONFIG_CPU_IDLE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_INTERSIL: u32 = 1;
pub const CONFIG_NTB_MODULE: u32 = 1;
pub const CONFIG_BATTERY_RX51_MODULE: u32 = 1;
pub const CONFIG_NFC_ST21NFCA_MODULE: u32 = 1;
pub const CONFIG_IP6_NF_MATCH_RPFILTER_MODULE: u32 = 1;
pub const CONFIG_NF_TABLES_INET_MODULE: u32 = 1;
pub const CONFIG_NFS_COMMON: u32 = 1;
pub const CONFIG_CHR_DEV_SCH_MODULE: u32 = 1;
pub const CONFIG_6LOWPAN_NHC_IPV6_MODULE: u32 = 1;
pub const CONFIG_REGULATOR: u32 = 1;
pub const CONFIG_SND_SOC_MSM8916_WCD_DIGITAL_MODULE: u32 = 1;
pub const CONFIG_NF_TABLES_IPV6_MODULE: u32 = 1;
pub const CONFIG_FAIR_GROUP_SCHED: u32 = 1;
pub const CONFIG_SENSORS_HIH6130_MODULE: u32 = 1;
pub const CONFIG_RT2800USB_MODULE: u32 = 1;
pub const CONFIG_BATTERY_SBS_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_HASH: u32 = 1;
pub const CONFIG_HAVE_STACK_VALIDATION: u32 = 1;
pub const CONFIG_AL3320A_MODULE: u32 = 1;
pub const CONFIG_EFI_PARTITION: u32 = 1;
pub const CONFIG_PROBE_EVENTS: u32 = 1;
pub const CONFIG_SSB_PCMCIAHOST_POSSIBLE: u32 = 1;
pub const CONFIG_TRACE_CLOCK: u32 = 1;
pub const CONFIG_TCG_TIS_I2C_INFINEON_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_HDMI_MODULE: u32 = 1;
pub const CONFIG_BCMA_BLOCKIO: u32 = 1;
pub const CONFIG_MODULE_SIG_HASH: &'static [u8; 7usize] = b"sha512\0";
pub const CONFIG_TI_ADS7950_MODULE: u32 = 1;
pub const CONFIG_PCI_BUS_ADDR_T_64BIT: u32 = 1;
pub const CONFIG_LOG_BUF_SHIFT: u32 = 18;
pub const CONFIG_PATA_IT8213_MODULE: u32 = 1;
pub const CONFIG_MEMORY_HOTREMOVE: u32 = 1;
pub const CONFIG_PM_NOTIFIER_ERROR_INJECT_MODULE: u32 = 1;
pub const CONFIG_RAPIDIO_CPS_GEN2_MODULE: u32 = 1;
pub const CONFIG_SND_CMIPCI_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ATH: u32 = 1;
pub const CONFIG_ACPI_DEBUGGER_USER: u32 = 1;
pub const CONFIG_BH1750_MODULE: u32 = 1;
pub const CONFIG_ACPI_WMI_MODULE: u32 = 1;
pub const CONFIG_HPET: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_857_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_DSCP_MODULE: u32 = 1;
pub const CONFIG_SND_EMU10K1X_MODULE: u32 = 1;
pub const CONFIG_EXTRA_FIRMWARE: &'static [u8; 1usize] = b"\0";
pub const CONFIG_NET_CLS_MATCHALL_MODULE: u32 = 1;
pub const CONFIG_TCG_TPM: u32 = 1;
pub const CONFIG_SPI_SLAVE_SYSTEM_CONTROL_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_8390: u32 = 1;
pub const CONFIG_MFD_WM5102: u32 = 1;
pub const CONFIG_LEDS_LP5562_MODULE: u32 = 1;
pub const CONFIG_IPV6_MROUTE: u32 = 1;
pub const CONFIG_XEN_PCIDEV_BACKEND_MODULE: u32 = 1;
pub const CONFIG_PROC_EVENTS: u32 = 1;
pub const CONFIG_ACPI_VIDEO_MODULE: u32 = 1;
pub const CONFIG_SENSORS_SHT3x_MODULE: u32 = 1;
pub const CONFIG_VIRT_TO_BUS: u32 = 1;
pub const CONFIG_VFAT_FS: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE: u32 = 1;
pub const CONFIG_MUSB_PIO_ONLY: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_ACPI: u32 = 1;
pub const CONFIG_IIO_ST_GYRO_SPI_3AXIS_MODULE: u32 = 1;
pub const CONFIG_EDAC_I5000_MODULE: u32 = 1;
pub const CONFIG_PID_NS: u32 = 1;
pub const CONFIG_SND_SOC_DMIC_MODULE: u32 = 1;
pub const CONFIG_MD_RAID1_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADDI_APCI_2200_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_S2MPS11_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_VMAC_MODULE: u32 = 1;
pub const CONFIG_I2C_CHT_WC_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ACPI_POWER_MODULE: u32 = 1;
pub const CONFIG_KEXEC: u32 = 1;
pub const CONFIG_ACPI_CMPC_MODULE: u32 = 1;
pub const CONFIG_IIO_CONFIGFS_MODULE: u32 = 1;
pub const CONFIG_RADIO_TEF6862_MODULE: u32 = 1;
pub const CONFIG_CRC32_SLICEBY8: u32 = 1;
pub const CONFIG_FB_DDC_MODULE: u32 = 1;
pub const CONFIG_MFD_DA9150_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DAS08_MODULE: u32 = 1;
pub const CONFIG_USB_LIBCOMPOSITE_MODULE: u32 = 1;
pub const CONFIG_SCSI_MPT2SAS_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ADAU1761_I2C_MODULE: u32 = 1;
pub const CONFIG_HVC_XEN: u32 = 1;
pub const CONFIG_SLAB_FREELIST_HARDENED: u32 = 1;
pub const CONFIG_CRYPTO_SM3_MODULE: u32 = 1;
pub const CONFIG_UWB_WHCI_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_WM9713: u32 = 1;
pub const CONFIG_FPGA_MGR_ALTERA_PS_SPI_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_FQ_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_HASWELL_MACH_MODULE: u32 = 1;
pub const CONFIG_FPGA_MGR_XILINX_SPI_MODULE: u32 = 1;
pub const CONFIG_OLD_BELKIN_DONGLE_MODULE: u32 = 1;
pub const CONFIG_VIDEO_HDPVR_MODULE: u32 = 1;
pub const CONFIG_MFD_TPS65912: u32 = 1;
pub const CONFIG_ROMFS_ON_BLOCK: u32 = 1;
pub const CONFIG_PEAQ_WMI_MODULE: u32 = 1;
pub const CONFIG_EDAC_AMD64_MODULE: u32 = 1;
pub const CONFIG_NET_SB1000_MODULE: u32 = 1;
pub const CONFIG_GPIO_ARIZONA_MODULE: u32 = 1;
pub const CONFIG_HERMES_CACHE_FW_ON_INIT: u32 = 1;
pub const CONFIG_BLK_DEV_SR: u32 = 1;
pub const CONFIG_CPU_RMAP: u32 = 1;
pub const CONFIG_SND_HWDEP_MODULE: u32 = 1;
pub const CONFIG_MODULE_SIG_SHA512: u32 = 1;
pub const CONFIG_X86_X32: u32 = 1;
pub const CONFIG_INTEL_TH_PTI_MODULE: u32 = 1;
pub const CONFIG_GENERIC_CPU: u32 = 1;
pub const CONFIG_GIGASET_M101_MODULE: u32 = 1;
pub const CONFIG_ISDN_DIVAS_PRIPCI: u32 = 1;
pub const CONFIG_GENERIC_IRQ_MATRIX_ALLOCATOR: u32 = 1;
pub const CONFIG_SND_LAYLA20_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_LOOP: u32 = 1;
pub const CONFIG_DVB_BT8XX_MODULE: u32 = 1;
pub const CONFIG_IPMI_HANDLER_MODULE: u32 = 1;
pub const CONFIG_LEDS_LM3642_MODULE: u32 = 1;
pub const CONFIG_B44_MODULE: u32 = 1;
pub const CONFIG_AMD_MEM_ENCRYPT: u32 = 1;
pub const CONFIG_DEFAULT_HUNG_TASK_TIMEOUT: u32 = 120;
pub const CONFIG_SYSV_FS_MODULE: u32 = 1;
pub const CONFIG_VIRTIO_PCI_LEGACY: u32 = 1;
pub const CONFIG_ATMEL_MODULE: u32 = 1;
pub const CONFIG_SENSORS_THMC50_MODULE: u32 = 1;
pub const CONFIG_ARCH_HIBERNATION_HEADER: u32 = 1;
pub const CONFIG_HAVE_OPTPROBES: u32 = 1;
pub const CONFIG_HAVE_FENTRY: u32 = 1;
pub const CONFIG_ATM_AMBASSADOR_MODULE: u32 = 1;
pub const CONFIG_L2TP_ETH_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADDI_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_PATA_ATIIXP_MODULE: u32 = 1;
pub const CONFIG_I8K_MODULE: u32 = 1;
pub const CONFIG_SCSI_QLOGIC_1280_MODULE: u32 = 1;
pub const CONFIG_DELL_SMO8800_MODULE: u32 = 1;
pub const CONFIG_HYPERV_UTILS_MODULE: u32 = 1;
pub const CONFIG_SYNCLINK_GT_MODULE: u32 = 1;
pub const CONFIG_CFQ_GROUP_IOSCHED: u32 = 1;
pub const CONFIG_INV_MPU6050_SPI_MODULE: u32 = 1;
pub const CONFIG_NF_NAT_IRC_MODULE: u32 = 1;
pub const CONFIG_RAPIDIO_TSI568_MODULE: u32 = 1;
pub const CONFIG_60XX_WDT_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_XC2028_MODULE: u32 = 1;
pub const CONFIG_INPUT_MISC: u32 = 1;
pub const CONFIG_SND_COMPRESS_OFFLOAD_MODULE: u32 = 1;
pub const CONFIG_IR_NUVOTON_MODULE: u32 = 1;
pub const CONFIG_SENSORS_SCH5627_MODULE: u32 = 1;
pub const CONFIG_ADIS16080_MODULE: u32 = 1;
pub const CONFIG_I2C_AMD756_MODULE: u32 = 1;
pub const CONFIG_UIO_PRUSS_MODULE: u32 = 1;
pub const CONFIG_E1000E_MODULE: u32 = 1;
pub const CONFIG_MFD_LP8788: u32 = 1;
pub const CONFIG_MS5611_MODULE: u32 = 1;
pub const CONFIG_DNET_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CAST6_AVX_X86_64_MODULE: u32 = 1;
pub const CONFIG_DVB_STV0288_MODULE: u32 = 1;
pub const CONFIG_USB_SL811_CS_MODULE: u32 = 1;
pub const CONFIG_MULTIUSER: u32 = 1;
pub const CONFIG_RTC_DRV_PCAP_MODULE: u32 = 1;
pub const CONFIG_SOC_CAMERA_MODULE: u32 = 1;
pub const CONFIG_SUSPEND: u32 = 1;
pub const CONFIG_SUNRPC_XPRT_RDMA_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SST_ACPI_MODULE: u32 = 1;
pub const CONFIG_CROSS_MEMORY_ATTACH: u32 = 1;
pub const CONFIG_MTD_NAND_ECC_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CBC: u32 = 1;
pub const CONFIG_SENSORS_LM93_MODULE: u32 = 1;
pub const CONFIG_PARIDE_ON20_MODULE: u32 = 1;
pub const CONFIG_BT_CMTP_MODULE: u32 = 1;
pub const CONFIG_VIDEO_ZORAN_LML33R10_MODULE: u32 = 1;
pub const CONFIG_KS0108_DELAY: u32 = 2;
pub const CONFIG_VIDEO_CX88_VP3054_MODULE: u32 = 1;
pub const CONFIG_MEDIA_CONTROLLER: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_HMARK_MODULE: u32 = 1;
pub const CONFIG_INPUT_MMA8450_MODULE: u32 = 1;
pub const CONFIG_MRP_MODULE: u32 = 1;
pub const CONFIG_I8253_LOCK: u32 = 1;
pub const CONFIG_SMSC_SCH311X_WDT_MODULE: u32 = 1;
pub const CONFIG_AK8975_MODULE: u32 = 1;
pub const CONFIG_AIC79XX_CMDS_PER_DEVICE: u32 = 32;
pub const CONFIG_IP6_NF_MATCH_RT_MODULE: u32 = 1;
pub const CONFIG_SCSI_IPR_MODULE: u32 = 1;
pub const CONFIG_SQUASHFS_DECOMP_SINGLE: u32 = 1;
pub const CONFIG_SERIAL_8250_RUNTIME_UARTS: u32 = 32;
pub const CONFIG_NS83820_MODULE: u32 = 1;
pub const CONFIG_TSL4531_MODULE: u32 = 1;
pub const CONFIG_KPROBES: u32 = 1;
pub const CONFIG_FS_MBCACHE: u32 = 1;
pub const CONFIG_XEN_HAVE_VPMU: u32 = 1;
pub const CONFIG_T5403_MODULE: u32 = 1;
pub const CONFIG_SENSORS_JC42_MODULE: u32 = 1;
pub const CONFIG_MD_MULTIPATH_MODULE: u32 = 1;
pub const CONFIG_DS1682_MODULE: u32 = 1;
pub const CONFIG_VIDEO_STK1160_COMMON_MODULE: u32 = 1;
pub const CONFIG_MFD_AS3711: u32 = 1;
pub const CONFIG_GFS2_FS_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_TUA9001_MODULE: u32 = 1;
pub const CONFIG_RTC_CLASS: u32 = 1;
pub const CONFIG_DVB_TUNER_DIB0070_MODULE: u32 = 1;
pub const CONFIG_NCPFS_NLS: u32 = 1;
pub const CONFIG_DRM_MGAG200_MODULE: u32 = 1;
pub const CONFIG_F2FS_FS_ENCRYPTION: u32 = 1;
pub const CONFIG_FB_MB862XX_PCI_GDC: u32 = 1;
pub const CONFIG_CRC7_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_RNG_DEFAULT: u32 = 1;
pub const CONFIG_SENSORS_LTC4215_MODULE: u32 = 1;
pub const CONFIG_SLICOSS_MODULE: u32 = 1;
pub const CONFIG_KVM_AMD_MODULE: u32 = 1;
pub const CONFIG_NET_CLS_TCINDEX_MODULE: u32 = 1;
pub const CONFIG_USB_EMI26_MODULE: u32 = 1;
pub const CONFIG_IP_VS_PROTO_ESP: u32 = 1;
pub const CONFIG_PCNET32_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_IT913X_MODULE: u32 = 1;
pub const CONFIG_GIGASET_I4L: u32 = 1;
pub const CONFIG_MWIFIEX_USB_MODULE: u32 = 1;
pub const CONFIG_SAMSUNG_Q10_MODULE: u32 = 1;
pub const CONFIG_TMPFS_XATTR: u32 = 1;
pub const CONFIG_EXT4_USE_FOR_EXT2: u32 = 1;
pub const CONFIG_EDAC_I82975X_MODULE: u32 = 1;
pub const CONFIG_PCMCIA_NMCLAN_MODULE: u32 = 1;
pub const CONFIG_NET_TEAM_MODULE: u32 = 1;
pub const CONFIG_FB_UVESA_MODULE: u32 = 1;
pub const CONFIG_INTEL_BXT_PMIC_THERMAL_MODULE: u32 = 1;
pub const CONFIG_AD5593R_MODULE: u32 = 1;
pub const CONFIG_LCD_ILI922X_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_TSC2007_MODULE: u32 = 1;
pub const CONFIG_SND_RME96_MODULE: u32 = 1;
pub const CONFIG_DCA_MODULE: u32 = 1;
pub const CONFIG_CAN_KVASER_USB_MODULE: u32 = 1;
pub const CONFIG_I2C_ALI1535_MODULE: u32 = 1;
pub const CONFIG_VOP_BUS_MODULE: u32 = 1;
pub const CONFIG_I2C_I801_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_UMEM_MODULE: u32 = 1;
pub const CONFIG_MTD_NAND_CAFE_MODULE: u32 = 1;
pub const CONFIG_BCM_NET_PHYLIB_MODULE: u32 = 1;
pub const CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS: u32 = 16;
pub const CONFIG_W1_MODULE: u32 = 1;
pub const CONFIG_VIDEO_SAA7134_ALSA_MODULE: u32 = 1;
pub const CONFIG_RT2800PCI_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_VC032X_MODULE: u32 = 1;
pub const CONFIG_OPENVSWITCH_GRE_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_F_UAC1_LEGACY: u32 = 1;
pub const CONFIG_PCMCIA_RAYCS_MODULE: u32 = 1;
pub const CONFIG_V4L2_FWNODE_MODULE: u32 = 1;
pub const CONFIG_IOMMU_HELPER: u32 = 1;
pub const CONFIG_DVB_ISL6421_MODULE: u32 = 1;
pub const CONFIG_VIDEO_AU0828_RC: u32 = 1;
pub const CONFIG_RTC_DRV_DS1374_MODULE: u32 = 1;
pub const CONFIG_MICROCODE_OLD_INTERFACE: u32 = 1;
pub const CONFIG_AUFS_INO_T_64: u32 = 1;
pub const CONFIG_SENSORS_STTS751_MODULE: u32 = 1;
pub const CONFIG_MLX5_ESWITCH: u32 = 1;
pub const CONFIG_RTC_DRV_BQ4802_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_OPA_VNIC_MODULE: u32 = 1;
pub const CONFIG_TMD_HERMES_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_BOOTROM_MODULE: u32 = 1;
pub const CONFIG_PATA_ACPI_MODULE: u32 = 1;
pub const CONFIG_GENERIC_TRACER: u32 = 1;
pub const CONFIG_CFG80211_USE_KERNEL_REGDB_KEYS: u32 = 1;
pub const CONFIG_NLS_ISO8859_5_MODULE: u32 = 1;
pub const CONFIG_DRM_VGEM_MODULE: u32 = 1;
pub const CONFIG_IP_VS_WLC_MODULE: u32 = 1;
pub const CONFIG_HAVE_FUNCTION_TRACER: u32 = 1;
pub const CONFIG_GENERIC_PHY: u32 = 1;
pub const CONFIG_ADE7758_MODULE: u32 = 1;
pub const CONFIG_MLXSW_SPECTRUM_MODULE: u32 = 1;
pub const CONFIG_CPU_ISOLATION: u32 = 1;
pub const CONFIG_NF_NAT_TFTP_MODULE: u32 = 1;
pub const CONFIG_SCR24X_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_MULTIPORT_MODULE: u32 = 1;
pub const CONFIG_CHARGER_MAX14577_MODULE: u32 = 1;
pub const CONFIG_MTD_SPI_NOR_MODULE: u32 = 1;
pub const CONFIG_STACK_VALIDATION: u32 = 1;
pub const CONFIG_CHARGER_MANAGER: u32 = 1;
pub const CONFIG_NET_SCH_NETEM_MODULE: u32 = 1;
pub const CONFIG_ACPI_PROCESSOR_AGGREGATOR_MODULE: u32 = 1;
pub const CONFIG_I2C_BCM2048_MODULE: u32 = 1;
pub const CONFIG_USB_STORAGE_REALTEK_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AC97_CODEC_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CAMELLIA_MODULE: u32 = 1;
pub const CONFIG_SND_EMU10K1_SEQ_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1307_MODULE: u32 = 1;
pub const CONFIG_I2C_SIS630_MODULE: u32 = 1;
pub const CONFIG_ARCH_SELECT_MEMORY_MODEL: u32 = 1;
pub const CONFIG_NFSD_V4: u32 = 1;
pub const CONFIG_I2C_SI4713_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_PROPERTIES: u32 = 1;
pub const CONFIG_AUFS_EXPORT: u32 = 1;
pub const CONFIG_PMBUS_MODULE: u32 = 1;
pub const CONFIG_EFI_MIXED: u32 = 1;
pub const CONFIG_VIDEO_MEYE_MODULE: u32 = 1;
pub const CONFIG_TCP_CONG_ILLINOIS_MODULE: u32 = 1;
pub const CONFIG_ZEROPLUS_FF: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_REDIRECT_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_MANAGER2: u32 = 1;
pub const CONFIG_INFINIBAND_QIB_DCA: u32 = 1;
pub const CONFIG_USB_GADGET_VBUS_DRAW: u32 = 2;
pub const CONFIG_SATA_DWC_MODULE: u32 = 1;
pub const CONFIG_NFC_MEI_PHY_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_MYRI: u32 = 1;
pub const CONFIG_KEXEC_FILE: u32 = 1;
pub const CONFIG_DRAGONRISE_FF: u32 = 1;
pub const CONFIG_CLZ_TAB: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_3M: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_EGALAX: u32 = 1;
pub const CONFIG_TYPEC_FUSB302_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_SUR40_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_EBT_DNAT_MODULE: u32 = 1;
pub const CONFIG_GENERIC_PCI_IOMAP: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_LOG_MODULE: u32 = 1;
pub const CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS: u32 = 1;
pub const CONFIG_SLUB: u32 = 1;
pub const CONFIG_SENSORS_AD7418_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_HHF_MODULE: u32 = 1;
pub const CONFIG_CONFIGFS_FS: u32 = 1;
pub const CONFIG_CRYPTO_TEST_MODULE: u32 = 1;
pub const CONFIG_MTD_UBI_MODULE: u32 = 1;
pub const CONFIG_MFD_SMSC: u32 = 1;
pub const CONFIG_MODULE_SIG_KEY: &'static [u8; 22usize] = b"certs/signing_key.pem\0";
pub const CONFIG_GREYBUS_USB_MODULE: u32 = 1;
pub const CONFIG_XZ_DEC_BCJ: u32 = 1;
pub const CONFIG_SLIP_MODULE: u32 = 1;
pub const CONFIG_PM_SLEEP: u32 = 1;
pub const CONFIG_F2FS_FS_XATTR: u32 = 1;
pub const CONFIG_SENSORS_FAM15H_POWER_MODULE: u32 = 1;
pub const CONFIG_I2C: u32 = 1;
pub const CONFIG_MFD_WM5110: u32 = 1;
pub const CONFIG_COMPAL_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_MTD: u32 = 1;
pub const CONFIG_JFFS2_ZLIB: u32 = 1;
pub const CONFIG_SCSI_CHELSIO_FCOE_MODULE: u32 = 1;
pub const CONFIG_PCMCIA_PCNET_MODULE: u32 = 1;
pub const CONFIG_EDAC_DECODE_MCE_MODULE: u32 = 1;
pub const CONFIG_SENSORS_VT1211_MODULE: u32 = 1;
pub const CONFIG_GPIO_AMDPT_MODULE: u32 = 1;
pub const CONFIG_B44_PCI: u32 = 1;
pub const CONFIG_PPP_MULTILINK: u32 = 1;
pub const CONFIG_INFINIBAND_RDMAVT_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS35L34_MODULE: u32 = 1;
pub const CONFIG_MTD_ONENAND_GENERIC_MODULE: u32 = 1;
pub const CONFIG_IPACK_BUS_MODULE: u32 = 1;
pub const CONFIG_BINFMT_SCRIPT: u32 = 1;
pub const CONFIG_HMM: u32 = 1;
pub const CONFIG_EFI_STUB: u32 = 1;
pub const CONFIG_SATA_PROMISE_MODULE: u32 = 1;
pub const CONFIG_PARPORT_1284: u32 = 1;
pub const CONFIG_MOUSE_PS2_CYPRESS: u32 = 1;
pub const CONFIG_FONT_ACORN_8x8: u32 = 1;
pub const CONFIG_SENSORS_POWR1220_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX25840_MODULE: u32 = 1;
pub const CONFIG_GENERIC_PENDING_IRQ: u32 = 1;
pub const CONFIG_I2C_AMD756_S4882_MODULE: u32 = 1;
pub const CONFIG_PARPORT_PC_MODULE: u32 = 1;
pub const CONFIG_BFQ_GROUP_IOSCHED: u32 = 1;
pub const CONFIG_NET_TEAM_MODE_LOADBALANCE_MODULE: u32 = 1;
pub const CONFIG_DEVICE_PUBLIC: u32 = 1;
pub const CONFIG_DVB_MN88472_MODULE: u32 = 1;
pub const CONFIG_PPS_CLIENT_GPIO_MODULE: u32 = 1;
pub const CONFIG_IIO_SW_TRIGGER_MODULE: u32 = 1;
pub const CONFIG_X86_NEED_RELOCS: u32 = 1;
pub const CONFIG_EARLY_PRINTK_DBGP: u32 = 1;
pub const CONFIG_VIDEO_ADV7175_MODULE: u32 = 1;
pub const CONFIG_SCSI_SRP_ATTRS_MODULE: u32 = 1;
pub const CONFIG_FRAME_POINTER: u32 = 1;
pub const CONFIG_NET_IPGRE_BROADCAST: u32 = 1;
pub const CONFIG_BT_HIDP_MODULE: u32 = 1;
pub const CONFIG_PD6729_MODULE: u32 = 1;
pub const CONFIG_KS8851_MLL_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX231XX_RC: u32 = 1;
pub const CONFIG_MOUSE_PS2_LOGIPS2PP: u32 = 1;
pub const CONFIG_MFD_BD9571MWV_MODULE: u32 = 1;
pub const CONFIG_TICK_CPU_ACCOUNTING: u32 = 1;
pub const CONFIG_COMEDI_DT2817_MODULE: u32 = 1;
pub const CONFIG_SMC_IRCC_FIR_MODULE: u32 = 1;
pub const CONFIG_SND_PCXHR_MODULE: u32 = 1;
pub const CONFIG_UFS_FS_MODULE: u32 = 1;
pub const CONFIG_VM_EVENT_COUNTERS: u32 = 1;
pub const CONFIG_MEDIA_COMMON_OPTIONS: u32 = 1;
pub const CONFIG_NFC_MICROREAD_MODULE: u32 = 1;
pub const CONFIG_HID_MAYFLASH_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_SX8654_MODULE: u32 = 1;
pub const CONFIG_RELAY: u32 = 1;
pub const CONFIG_AD9834_MODULE: u32 = 1;
pub const CONFIG_IWLDVM_MODULE: u32 = 1;
pub const CONFIG_HAVE_MMIOTRACE_SUPPORT: u32 = 1;
pub const CONFIG_SCHED_STACK_END_CHECK: u32 = 1;
pub const CONFIG_ASUS_NB_WMI_MODULE: u32 = 1;
pub const CONFIG_RMI4_F30: u32 = 1;
pub const CONFIG_USB_GSPCA_FINEPIX_MODULE: u32 = 1;
pub const CONFIG_HISAX_NETJET: u32 = 1;
pub const CONFIG_CRYPTO_ECB: u32 = 1;
pub const CONFIG_USB_GSPCA_ETOMS_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SHA512_SSSE3_MODULE: u32 = 1;
pub const CONFIG_ACPI_SYSTEM_POWER_STATES_SUPPORT: u32 = 1;
pub const CONFIG_REGULATOR_MAX77693_MODULE: u32 = 1;
pub const CONFIG_MFD_PALMAS: u32 = 1;
pub const CONFIG_WLAN_VENDOR_BROADCOM: u32 = 1;
pub const CONFIG_PM_STD_PARTITION: &'static [u8; 1usize] = b"\0";
pub const CONFIG_SQUASHFS_LZO: u32 = 1;
pub const CONFIG_SND_DYNAMIC_MINORS: u32 = 1;
pub const CONFIG_FUJITSU_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_TCM_FILEIO_MODULE: u32 = 1;
pub const CONFIG_SND_PCM_IEC958: u32 = 1;
pub const CONFIG_NET_VENDOR_XIRCOM: u32 = 1;
pub const CONFIG_GENERIC_FIND_FIRST_BIT: u32 = 1;
pub const CONFIG_SCSI_STEX_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_AG6XX: u32 = 1;
pub const CONFIG_6LOWPAN_NHC_HOP_MODULE: u32 = 1;
pub const CONFIG_HOTPLUG_PCI_CPCI_ZT5550_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_ATH3K: u32 = 1;
pub const CONFIG_NF_CONNTRACK_AMANDA_MODULE: u32 = 1;
pub const CONFIG_SND_ATIIXP_MODEM_MODULE: u32 = 1;
pub const CONFIG_HID_NTI_MODULE: u32 = 1;
pub const CONFIG_DEBUG_FS: u32 = 1;
pub const CONFIG_UNISYS_VISORBUS_MODULE: u32 = 1;
pub const CONFIG_RDMA_RXE_MODULE: u32 = 1;
pub const CONFIG_FEALNX_MODULE: u32 = 1;
pub const CONFIG_ACPI_EXTLOG_MODULE: u32 = 1;
pub const CONFIG_USB_FUNCTIONFS_RNDIS: u32 = 1;
pub const CONFIG_NET_VENDOR_AMD: u32 = 1;
pub const CONFIG_HAVE_KERNEL_LZ4: u32 = 1;
pub const CONFIG_NET_PKTGEN_MODULE: u32 = 1;
pub const CONFIG_HP_WMI_MODULE: u32 = 1;
pub const CONFIG_INTEL_ISH_HID_MODULE: u32 = 1;
pub const CONFIG_MTD_NAND_DENALI_PCI_MODULE: u32 = 1;
pub const CONFIG_TRACING_EVENTS_GPIO: u32 = 1;
pub const CONFIG_USB_SERIAL_EDGEPORT_MODULE: u32 = 1;
pub const CONFIG_DRM_TTM_MODULE: u32 = 1;
pub const CONFIG_BASE_FULL: u32 = 1;
pub const CONFIG_FB_CFB_IMAGEBLIT: u32 = 1;
pub const CONFIG_MAX5487_MODULE: u32 = 1;
pub const CONFIG_ZLIB_DEFLATE: u32 = 1;
pub const CONFIG_NFT_REJECT_INET_MODULE: u32 = 1;
pub const CONFIG_SUNRPC_MODULE: u32 = 1;
pub const CONFIG_SOLARIS_X86_PARTITION: u32 = 1;
pub const CONFIG_MLXSW_CORE_MODULE: u32 = 1;
pub const CONFIG_ARCNET_RAW_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_TSC2007_IIO: u32 = 1;
pub const CONFIG_ARCH_DISCARD_MEMBLOCK: u32 = 1;
pub const CONFIG_PMIC_DA903X: u32 = 1;
pub const CONFIG_SCSI_DH_RDAC_MODULE: u32 = 1;
pub const CONFIG_SENSORS_W83795_MODULE: u32 = 1;
pub const CONFIG_BATTERY_BQ27XXX_MODULE: u32 = 1;
pub const CONFIG_X86_P4_CLOCKMOD_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ADAU1761_SPI_MODULE: u32 = 1;
pub const CONFIG_INPUT_ATI_REMOTE2_MODULE: u32 = 1;
pub const CONFIG_CNIC_MODULE: u32 = 1;
pub const CONFIG_ACPI_TABLE_UPGRADE: u32 = 1;
pub const CONFIG_RSI_SDIO_MODULE: u32 = 1;
pub const CONFIG_OSF_PARTITION: u32 = 1;
pub const CONFIG_ARCH_USES_HIGH_VMA_FLAGS: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_864_MODULE: u32 = 1;
pub const CONFIG_IIO_BUFFER: u32 = 1;
pub const CONFIG_TOUCHSCREEN_CY8CTMG110_MODULE: u32 = 1;
pub const CONFIG_IWL3945_MODULE: u32 = 1;
pub const CONFIG_IP_VS_LBLCR_MODULE: u32 = 1;
pub const CONFIG_GPIO_SYSFS: u32 = 1;
pub const CONFIG_HP_WIRELESS_MODULE: u32 = 1;
pub const CONFIG_USB_YUREX_MODULE: u32 = 1;
pub const CONFIG_XEN_BACKEND: u32 = 1;
pub const CONFIG_FW_LOADER: u32 = 1;
pub const CONFIG_IIO_SW_DEVICE_MODULE: u32 = 1;
pub const CONFIG_LITELINK_DONGLE_MODULE: u32 = 1;
pub const CONFIG_USB_G_DBGP_SERIAL: u32 = 1;
pub const CONFIG_IP6_NF_NAT_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_WM8350_MODULE: u32 = 1;
pub const CONFIG_LTC2471_MODULE: u32 = 1;
pub const CONFIG_RANDOMIZE_MEMORY_PHYSICAL_PADDING: u32 = 10;
pub const CONFIG_SENSORS_ADS7828_MODULE: u32 = 1;
pub const CONFIG_KALLSYMS: u32 = 1;
pub const CONFIG_COMMON_CLK: u32 = 1;
pub const CONFIG_USB_GSPCA_SPCA501_MODULE: u32 = 1;
pub const CONFIG_HOTPLUG_PCI_PCIE: u32 = 1;
pub const CONFIG_BMG160_I2C_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_RV8803_MODULE: u32 = 1;
pub const CONFIG_PCI: u32 = 1;
pub const CONFIG_RTC_HCTOSYS_DEVICE: &'static [u8; 5usize] = b"rtc0\0";
pub const CONFIG_CRYPTO_XTS: u32 = 1;
pub const CONFIG_SENSORS_ZL6100_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RL6231_MODULE: u32 = 1;
pub const CONFIG_PWM: u32 = 1;
pub const CONFIG_BATTERY_DS2781_MODULE: u32 = 1;
pub const CONFIG_CHARGER_PCF50633_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_RECENT_MODULE: u32 = 1;
pub const CONFIG_DECOMPRESS_XZ: u32 = 1;
pub const CONFIG_SERIAL_DEV_CTRL_TTYPORT: u32 = 1;
pub const CONFIG_BT_BCM_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_PKTTYPE_MODULE: u32 = 1;
pub const CONFIG_PCI_QUIRKS: u32 = 1;
pub const CONFIG_INFINIBAND_USNIC_MODULE: u32 = 1;
pub const CONFIG_MII_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_TCA8418_MODULE: u32 = 1;
pub const CONFIG_SIGNALFD: u32 = 1;
pub const CONFIG_REGULATOR_MAX8997_MODULE: u32 = 1;
pub const CONFIG_NET_CORE: u32 = 1;
pub const CONFIG_MOUSE_PS2_ALPS: u32 = 1;
pub const CONFIG_VIDEO_CPIA2_MODULE: u32 = 1;
pub const CONFIG_KEXEC_CORE: u32 = 1;
pub const CONFIG_HAVE_UNSTABLE_SCHED_CLOCK: u32 = 1;
pub const CONFIG_EXT4_FS: u32 = 1;
pub const CONFIG_MAC80211_DEBUGFS: u32 = 1;
pub const CONFIG_NET_SCH_DRR_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT298_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LTC4151_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_EBT_802_3_MODULE: u32 = 1;
pub const CONFIG_DELL_SMBIOS_SMM: u32 = 1;
pub const CONFIG_CPU5_WDT_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_VMWARE_PVRDMA_MODULE: u32 = 1;
pub const CONFIG_MEMORY_BALLOON: u32 = 1;
pub const CONFIG_COMEDI_NI_65XX_MODULE: u32 = 1;
pub const CONFIG_MMC_USDHI6ROL0_MODULE: u32 = 1;
pub const CONFIG_SERIAL_SC16IS7XX_SPI: u32 = 1;
pub const CONFIG_FB_LE80578_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX88_BLACKBIRD_MODULE: u32 = 1;
pub const CONFIG_MFD_SEC_CORE: u32 = 1;
pub const CONFIG_SND_SOC_PCM512x_SPI_MODULE: u32 = 1;
pub const CONFIG_HAVE_HW_BREAKPOINT: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_DEFERRED_STRUCT_PAGE_INIT: u32 = 1;
pub const CONFIG_KRETPROBES: u32 = 1;
pub const CONFIG_SND_JACK_INPUT_DEV: u32 = 1;
pub const CONFIG_MTD_LPDDR_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SHA1: u32 = 1;
pub const CONFIG_USB_FOTG210_HCD_MODULE: u32 = 1;
pub const CONFIG_MFD_MT6397_MODULE: u32 = 1;
pub const CONFIG_GPIO_104_DIO_48E_MODULE: u32 = 1;
pub const CONFIG_QUOTACTL_COMPAT: u32 = 1;
pub const CONFIG_HID_PENMOUNT_MODULE: u32 = 1;
pub const CONFIG_IPMI_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_MD_CLUSTER_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_JOYDUMP_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_USER_ACCESS_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_MT7530_MODULE: u32 = 1;
pub const CONFIG_VMWARE_VMCI_MODULE: u32 = 1;
pub const CONFIG_CHELSIO_T4_DCB: u32 = 1;
pub const CONFIG_BPQETHER_MODULE: u32 = 1;
pub const CONFIG_USB_ADUTUX_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_NOKIA_MODULE: u32 = 1;
pub const CONFIG_VIDEO_UDA1342_MODULE: u32 = 1;
pub const CONFIG_HSI_BOARDINFO: u32 = 1;
pub const CONFIG_KGDB_LOW_LEVEL_TRAP: u32 = 1;
pub const CONFIG_MT7601U_MODULE: u32 = 1;
pub const CONFIG_CAN_C_CAN_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_ARCH_WANT_GENERAL_HUGETLB: u32 = 1;
pub const CONFIG_SENSORS_SMSC47M192_MODULE: u32 = 1;
pub const CONFIG_ADT7316_SPI_MODULE: u32 = 1;
pub const CONFIG_BCH_CONST_PARAMS: u32 = 1;
pub const CONFIG_FB_TFT_SSD1305_MODULE: u32 = 1;
pub const CONFIG_NLS_KOI8_U_MODULE: u32 = 1;
pub const CONFIG_RADIO_SHARK2_MODULE: u32 = 1;
pub const CONFIG_CRC8_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_ZONED: u32 = 1;
pub const CONFIG_SND_SOC_CS42L51_MODULE: u32 = 1;
pub const CONFIG_SENSORS_SCH5636_MODULE: u32 = 1;
pub const CONFIG_PKCS7_TEST_KEY_MODULE: u32 = 1;
pub const CONFIG_USB_BELKIN: u32 = 1;
pub const CONFIG_XZ_DEC: u32 = 1;
pub const CONFIG_NET_DSA_QCA8K_MODULE: u32 = 1;
pub const CONFIG_SATA_PMP: u32 = 1;
pub const CONFIG_SMS_SIANO_DEBUGFS: u32 = 1;
pub const CONFIG_IPW2100_MONITOR: u32 = 1;
pub const CONFIG_QLA3XXX_MODULE: u32 = 1;
pub const CONFIG_RTL8192U_MODULE: u32 = 1;
pub const CONFIG_CAN_VCAN_MODULE: u32 = 1;
pub const CONFIG_SBNI_MODULE: u32 = 1;
pub const CONFIG_DPTF_POWER_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_FIRMWARE_MODULE: u32 = 1;
pub const CONFIG_ATH_COMMON_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_TI: u32 = 1;
pub const CONFIG_CROS_EC_LPC_MODULE: u32 = 1;
pub const CONFIG_LOCKD_V4: u32 = 1;
pub const CONFIG_SENSORS_LTC2945_MODULE: u32 = 1;
pub const CONFIG_DUMMY_MODULE: u32 = 1;
pub const CONFIG_FB_XGI_MODULE: u32 = 1;
pub const CONFIG_CODA_FS_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2431_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_ALACRITECH: u32 = 1;
pub const CONFIG_I2C_MUX_MLXCPLD_MODULE: u32 = 1;
pub const CONFIG_LEDS_LM3530_MODULE: u32 = 1;
pub const CONFIG_DVB_TUNER_CX24113_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_EBT_MARK_T_MODULE: u32 = 1;
pub const CONFIG_WATCHDOG: u32 = 1;
pub const CONFIG_BATTERY_MAX17042_MODULE: u32 = 1;
pub const CONFIG_SCSI_ADVANSYS_MODULE: u32 = 1;
pub const CONFIG_DVB_B2C2_FLEXCOP_PCI_MODULE: u32 = 1;
pub const CONFIG_RING_BUFFER_ALLOW_SWAP: u32 = 1;
pub const CONFIG_HAS_IOMEM: u32 = 1;
pub const CONFIG_SND_RAWMIDI_MODULE: u32 = 1;
pub const CONFIG_HOTPLUG_PCI_ACPI_IBM_MODULE: u32 = 1;
pub const CONFIG_MFD_ARIZONA_SPI_MODULE: u32 = 1;
pub const CONFIG_NF_LOG_IPV6_MODULE: u32 = 1;
pub const CONFIG_DE4X5_MODULE: u32 = 1;
pub const CONFIG_IEEE802154_SOCKET_MODULE: u32 = 1;
pub const CONFIG_TRACING_MAP: u32 = 1;
pub const CONFIG_CRYPTO_RSA: u32 = 1;
pub const CONFIG_USB_GSPCA_STK1135_MODULE: u32 = 1;
pub const CONFIG_8139TOO_8129: u32 = 1;
pub const CONFIG_SND_HDA_INPUT_BEEP_MODE: u32 = 0;
pub const CONFIG_VIRT_DRIVERS: u32 = 1;
pub const CONFIG_AUFS_SBILIST: u32 = 1;
pub const CONFIG_SENSORS_LTC4222_MODULE: u32 = 1;
pub const CONFIG_COMEDI_PCL724_MODULE: u32 = 1;
pub const CONFIG_IP_VS_OVF_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_INTEL: u32 = 1;
pub const CONFIG_FB_AUO_K1900_MODULE: u32 = 1;
pub const CONFIG_IIO_TIGHTLOOP_TRIGGER_MODULE: u32 = 1;
pub const CONFIG_IR_FINTEK_MODULE: u32 = 1;
pub const CONFIG_GENERIC_IRQ_PROBE: u32 = 1;
pub const CONFIG_ATH6KL_USB_MODULE: u32 = 1;
pub const CONFIG_FUSION_LOGGING: u32 = 1;
pub const CONFIG_ABP060MG_MODULE: u32 = 1;
pub const CONFIG_USB_NET_CDC_EEM_MODULE: u32 = 1;
pub const CONFIG_BRCM_TRACING: u32 = 1;
pub const CONFIG_USB_STORAGE_SDDR09_MODULE: u32 = 1;
pub const CONFIG_GPIO_EXAR_MODULE: u32 = 1;
pub const CONFIG_HYPERV_STORAGE_MODULE: u32 = 1;
pub const CONFIG_IP_NF_MATCH_TTL_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_MCS_MODULE: u32 = 1;
pub const CONFIG_ASYNC_RAID6_RECOV_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_STA32X_MODULE: u32 = 1;
pub const CONFIG_SI7020_MODULE: u32 = 1;
pub const CONFIG_QCOM_EMAC_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_ACOMP2: u32 = 1;
pub const CONFIG_FB_TFT_SSD1289_MODULE: u32 = 1;
pub const CONFIG_EDD_OFF: u32 = 1;
pub const CONFIG_PWM_LPSS_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_GART_IOMMU: u32 = 1;
pub const CONFIG_CHARGER_RT9455_MODULE: u32 = 1;
pub const CONFIG_SCSI_SYM53C8XX_MAX_TAGS: u32 = 64;
pub const CONFIG_FB_CARMINE_MODULE: u32 = 1;
pub const CONFIG_CW1200_WLAN_SPI_MODULE: u32 = 1;
pub const CONFIG_NFTL_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_ADC_MODULE: u32 = 1;
pub const CONFIG_PCI_MMCONFIG: u32 = 1;
pub const CONFIG_VSOCKMON_MODULE: u32 = 1;
pub const CONFIG_PM_TRACE: u32 = 1;
pub const CONFIG_SND_SOC_STA350_MODULE: u32 = 1;
pub const CONFIG_SCSI_AM53C974_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_TRACE_MODULE: u32 = 1;
pub const CONFIG_HVC_IRQ: u32 = 1;
pub const CONFIG_IAQCORE_MODULE: u32 = 1;
pub const CONFIG_IWLWIFI_DEVICE_TRACING: u32 = 1;
pub const CONFIG_ATM_ZATM_MODULE: u32 = 1;
pub const CONFIG_ACPI_NFIT_MODULE: u32 = 1;
pub const CONFIG_USB_GADGETFS_MODULE: u32 = 1;
pub const CONFIG_IRDA_ULTRA: u32 = 1;
pub const CONFIG_SND_SOC_NAU8810_MODULE: u32 = 1;
pub const CONFIG_SND_RME32_MODULE: u32 = 1;
pub const CONFIG_PROC_KCORE: u32 = 1;
pub const CONFIG_RETPOLINE: u32 = 1;
pub const CONFIG_RTC_DRV_X1205_MODULE: u32 = 1;
pub const CONFIG_MTD_MAP_BANK_WIDTH_1: u32 = 1;
pub const CONFIG_LPC_ICH_MODULE: u32 = 1;
pub const CONFIG_NUMA: u32 = 1;
pub const CONFIG_IP6_NF_MATCH_FRAG_MODULE: u32 = 1;
pub const CONFIG_HDC100X_MODULE: u32 = 1;
pub const CONFIG_LEDS_MT6323_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_CYBERJACK_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_PRIO_MODULE: u32 = 1;
pub const CONFIG_JSA1212_MODULE: u32 = 1;
pub const CONFIG_SCHED_HRTICK: u32 = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_USA28XB: u32 = 1;
pub const CONFIG_TOUCHSCREEN_EXC3000_MODULE: u32 = 1;
pub const CONFIG_SATA_ULI_MODULE: u32 = 1;
pub const CONFIG_DRM_I915_GVT: u32 = 1;
pub const CONFIG_DVB_DRXK_MODULE: u32 = 1;
pub const CONFIG_MMA7455_SPI_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_IUU_MODULE: u32 = 1;
pub const CONFIG_VIDEO_GO7007_USB_S2250_BOARD_MODULE: u32 = 1;
pub const CONFIG_EPOLL: u32 = 1;
pub const CONFIG_FB_MATROX_G: u32 = 1;
pub const CONFIG_SCSI_AIC79XX_MODULE: u32 = 1;
pub const CONFIG_NET_IFE_MODULE: u32 = 1;
pub const CONFIG_RADIO_MAXIRADIO_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_LZO: u32 = 1;
pub const CONFIG_SND_PCM_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_TWOFISH_AVX_X86_64_MODULE: u32 = 1;
pub const CONFIG_LIRC_ZILOG_MODULE: u32 = 1;
pub const CONFIG_TCM_USER2_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DEFAULT_BUF_MAXSIZE_KB: u32 = 20480;
pub const CONFIG_BRIDGE_EBT_SNAT_MODULE: u32 = 1;
pub const CONFIG_SATA_MOBILE_LPM_POLICY: u32 = 0;
pub const CONFIG_TCG_TIS_ST33ZP24_SPI_MODULE: u32 = 1;
pub const CONFIG_SND_AU8820_MODULE: u32 = 1;
pub const CONFIG_RAPIDIO: u32 = 1;
pub const CONFIG_INFINIBAND_OCRDMA_MODULE: u32 = 1;
pub const CONFIG_DA280_MODULE: u32 = 1;
pub const CONFIG_SND_SEQ_MIDI_EVENT_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ES7134_MODULE: u32 = 1;
pub const CONFIG_GIRBIL_DONGLE_MODULE: u32 = 1;
pub const CONFIG_VIDEO_DT3155_MODULE: u32 = 1;
pub const CONFIG_SDIO_UART_MODULE: u32 = 1;
pub const CONFIG_NFC_MRVL_SPI_MODULE: u32 = 1;
pub const CONFIG_KVM_COMPAT: u32 = 1;
pub const CONFIG_PARTITION_ADVANCED: u32 = 1;
pub const CONFIG_EZX_PCAP: u32 = 1;
pub const CONFIG_SENSORS_SCH56XX_COMMON_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_DCCP_MODULE: u32 = 1;
pub const CONFIG_ICPLUS_PHY_MODULE: u32 = 1;
pub const CONFIG_CGROUP_HUGETLB: u32 = 1;
pub const CONFIG_UNIXWARE_DISKLABEL: u32 = 1;
pub const CONFIG_SCTP_DEFAULT_COOKIE_HMAC_SHA1: u32 = 1;
pub const CONFIG_USB_U_ETHER_MODULE: u32 = 1;
pub const CONFIG_X86_NUMACHIP: u32 = 1;
pub const CONFIG_COMEDI_USBDUXFAST_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_LP872X_MODULE: u32 = 1;
pub const CONFIG_EXTCON_AXP288_MODULE: u32 = 1;
pub const CONFIG_BT_BNEP_MC_FILTER: u32 = 1;
pub const CONFIG_CRYPTO_CRC32_MODULE: u32 = 1;
pub const CONFIG_SCSI_ISCSI_ATTRS_MODULE: u32 = 1;
pub const CONFIG_MTD_NAND_DENALI_MODULE: u32 = 1;
pub const CONFIG_HAVE_NET_DSA: u32 = 1;
pub const CONFIG_USB_SERIAL_EMPEG_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_MAX7359_MODULE: u32 = 1;
pub const CONFIG_MTD_SPINAND_ONDIEECC: u32 = 1;
pub const CONFIG_IR_SONY_DECODER_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_852_MODULE: u32 = 1;
pub const CONFIG_TCG_TIS: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_IDEALTEK: u32 = 1;
pub const CONFIG_VIDEO_PVRUSB2_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_TAG_KSZ: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_COMMENT_MODULE: u32 = 1;
pub const CONFIG_NFS_SWAP: u32 = 1;
pub const CONFIG_USB_ISP116X_HCD_MODULE: u32 = 1;
pub const CONFIG_I2C_ISCH_MODULE: u32 = 1;
pub const CONFIG_USB_NET_RNDIS_HOST_MODULE: u32 = 1;
pub const CONFIG_NET: u32 = 1;
pub const CONFIG_ATARI_PARTITION: u32 = 1;
pub const CONFIG_MS5611_I2C_MODULE: u32 = 1;
pub const CONFIG_SQUASHFS_FILE_DIRECT: u32 = 1;
pub const CONFIG_USB_OHCI_HCD_PCI: u32 = 1;
pub const CONFIG_INPUT_EVDEV: u32 = 1;
pub const CONFIG_AIM_SOUND_MODULE: u32 = 1;
pub const CONFIG_SND_JACK: u32 = 1;
pub const CONFIG_AD5933_MODULE: u32 = 1;
pub const CONFIG_DDR: u32 = 1;
pub const CONFIG_IDEAPAD_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_SECURITY_PATH: u32 = 1;
pub const CONFIG_GPIO_AXP209_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_TCPMSS_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_SSD1351_MODULE: u32 = 1;
pub const CONFIG_B43LEGACY_DMA: u32 = 1;
pub const CONFIG_LIDAR_LITE_V2_MODULE: u32 = 1;
pub const CONFIG_BMP280_SPI_MODULE: u32 = 1;
pub const CONFIG_ACPI_SLEEP: u32 = 1;
pub const CONFIG_REGULATOR_TPS65132_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_VIRTUAL_CONSUMER_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_DSCP_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_WP512_MODULE: u32 = 1;
pub const CONFIG_CFAG12864B_RATE: u32 = 20;
pub const CONFIG_C2PORT_DURAMAR_2150_MODULE: u32 = 1;
pub const CONFIG_HID_DRAGONRISE_MODULE: u32 = 1;
pub const CONFIG_X86_ESPFIX64: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CONNTRACK_MODULE: u32 = 1;
pub const CONFIG_GPIO_RDC321X_MODULE: u32 = 1;
pub const CONFIG_SERIAL_KGDB_NMI: u32 = 1;
pub const CONFIG_VMIVME_7805_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADQ12B_MODULE: u32 = 1;
pub const CONFIG_VIDEO_BT848_MODULE: u32 = 1;
pub const CONFIG_BLOCK_COMPAT: u32 = 1;
pub const CONFIG_ITCO_WDT_MODULE: u32 = 1;
pub const CONFIG_AMD_XGBE_DCB: u32 = 1;
pub const CONFIG_COMEDI_NI_LABPC_MODULE: u32 = 1;
pub const CONFIG_IR_IGUANA_MODULE: u32 = 1;
pub const CONFIG_CHARGER_LP8788_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_RATEEST_MODULE: u32 = 1;
pub const CONFIG_SPI_LOOPBACK_TEST_MODULE: u32 = 1;
pub const CONFIG_FW_LOADER_USER_HELPER: u32 = 1;
pub const CONFIG_SND_ALOOP_MODULE: u32 = 1;
pub const CONFIG_ATH9K_STATION_STATISTICS: u32 = 1;
pub const CONFIG_USB_KBD_MODULE: u32 = 1;
pub const CONFIG_HPFS_FS_MODULE: u32 = 1;
pub const CONFIG_PINMUX: u32 = 1;
pub const CONFIG_USB_LD_MODULE: u32 = 1;
pub const CONFIG_MTD_GEN_PROBE_MODULE: u32 = 1;
pub const CONFIG_QUOTA_TREE_MODULE: u32 = 1;
pub const CONFIG_FB_VIA_MODULE: u32 = 1;
pub const CONFIG_CAIF_NETDEV_MODULE: u32 = 1;
pub const CONFIG_INPUT_PCSPKR_MODULE: u32 = 1;
pub const CONFIG_IRQ_DOMAIN_HIERARCHY: u32 = 1;
pub const CONFIG_HVC_XEN_FRONTEND: u32 = 1;
pub const CONFIG_DVB_AV7110_OSD: u32 = 1;
pub const CONFIG_SERIO_PCIPS2_MODULE: u32 = 1;
pub const CONFIG_MPILIB: u32 = 1;
pub const CONFIG_USB_NET_CDCETHER_MODULE: u32 = 1;
pub const CONFIG_MMA9551_MODULE: u32 = 1;
pub const CONFIG_PACKET: u32 = 1;
pub const CONFIG_MODULE_SRCVERSION_ALL: u32 = 1;
pub const CONFIG_FIREWIRE_SERIAL_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_M48T86_MODULE: u32 = 1;
pub const CONFIG_XFRM_ALGO_MODULE: u32 = 1;
pub const CONFIG_SND_SIMPLE_CARD_UTILS_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_TIMESTAMP: u32 = 1;
pub const CONFIG_SCIF_MODULE: u32 = 1;
pub const CONFIG_RMI4_I2C_MODULE: u32 = 1;
pub const CONFIG_HAVE_CLK_PREPARE: u32 = 1;
pub const CONFIG_VIDEO_CX88_MPEG_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_AKCIPHER2: u32 = 1;
pub const CONFIG_TAHVO_USB_MODULE: u32 = 1;
pub const CONFIG_NODES_SHIFT: u32 = 10;
pub const CONFIG_SENSORS_SMM665_MODULE: u32 = 1;
pub const CONFIG_MWIFIEX_SDIO_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_IPRANGE_MODULE: u32 = 1;
pub const CONFIG_INTEL_IOATDMA_MODULE: u32 = 1;
pub const CONFIG_NET_CLS_BASIC_MODULE: u32 = 1;
pub const CONFIG_AXP288_ADC_MODULE: u32 = 1;
pub const CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE: u32 = 1;
pub const CONFIG_BACKLIGHT_LM3533_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2405_MODULE: u32 = 1;
pub const CONFIG_MMC_SDHCI_XENON_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_GENERIC_MODULE: u32 = 1;
pub const CONFIG_AUFS_BR_HFSPLUS: u32 = 1;
pub const CONFIG_AD5764_MODULE: u32 = 1;
pub const CONFIG_I2C_TINY_USB_MODULE: u32 = 1;
pub const CONFIG_NETROM_MODULE: u32 = 1;
pub const CONFIG_MMC35240_MODULE: u32 = 1;
pub const CONFIG_FUSION_SPI_MODULE: u32 = 1;
pub const CONFIG_BTRFS_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_SND_HDA_CORE_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_OV534_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_TCA6416_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DT3000_MODULE: u32 = 1;
pub const CONFIG_FRONTSWAP: u32 = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_MPR: u32 = 1;
pub const CONFIG_HTS221_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_GL861_MODULE: u32 = 1;
pub const CONFIG_DRM_I915_GVT_KVMGT_MODULE: u32 = 1;
pub const CONFIG_IMA_APPRAISE: u32 = 1;
pub const CONFIG_ALTERA_MSGDMA_MODULE: u32 = 1;
pub const CONFIG_DUMMY_CONSOLE_ROWS: u32 = 25;
pub const CONFIG_MFD_ARIZONA_I2C_MODULE: u32 = 1;
pub const CONFIG_USB_XHCI_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_TLV320AIC23_I2C_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_TFTP_MODULE: u32 = 1;
pub const CONFIG_NFS_V3_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_MAX6902_MODULE: u32 = 1;
pub const CONFIG_MFD_MAX8997: u32 = 1;
pub const CONFIG_PHY_TUSB1210_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_ANYSEE_MODULE: u32 = 1;
pub const CONFIG_HISAX_HFC_SX: u32 = 1;
pub const CONFIG_HAVE_KVM_IRQFD: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_949_MODULE: u32 = 1;
pub const CONFIG_DVB_CX24110_MODULE: u32 = 1;
pub const CONFIG_SENSORS_TMP102_MODULE: u32 = 1;
pub const CONFIG_NOP_TRACER: u32 = 1;
pub const CONFIG_BACKLIGHT_LCD_SUPPORT: u32 = 1;
pub const CONFIG_LOOPBACK_TARGET_MODULE: u32 = 1;
pub const CONFIG_ISL29020_MODULE: u32 = 1;
pub const CONFIG_SENSORS_TSL2563_MODULE: u32 = 1;
pub const CONFIG_HID_CORSAIR_MODULE: u32 = 1;
pub const CONFIG_PWM_CRC: u32 = 1;
pub const CONFIG_SND_HDA_PATCH_LOADER: u32 = 1;
pub const CONFIG_XEN_XENBUS_FRONTEND: u32 = 1;
pub const CONFIG_INET: u32 = 1;
pub const CONFIG_CRYPTO_PCRYPT_MODULE: u32 = 1;
pub const CONFIG_HID_SENSOR_PRESS_MODULE: u32 = 1;
pub const CONFIG_COMEDI_CB_PCIMDDA_MODULE: u32 = 1;
pub const CONFIG_IP_ROUTE_VERBOSE: u32 = 1;
pub const CONFIG_XZ_DEC_POWERPC: u32 = 1;
pub const CONFIG_PCMCIA_WL3501_MODULE: u32 = 1;
pub const CONFIG_USB_MAX3421_HCD_MODULE: u32 = 1;
pub const CONFIG_DVB_RTL2832_MODULE: u32 = 1;
pub const CONFIG_INTEL_PCH_THERMAL_MODULE: u32 = 1;
pub const CONFIG_USB_MUSB_HDRC_MODULE: u32 = 1;
pub const CONFIG_VIRTIO_NET_MODULE: u32 = 1;
pub const CONFIG_MEMORY_NOTIFIER_ERROR_INJECT_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_SIS_I2C_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_ADDRTYPE_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_HUAWEI: u32 = 1;
pub const CONFIG_PREVENT_FIRMWARE_BUILD: u32 = 1;
pub const CONFIG_SERIAL_8250_PNP: u32 = 1;
pub const CONFIG_USB_NET_MCS7830_MODULE: u32 = 1;
pub const CONFIG_VIDEOBUF2_DVB_MODULE: u32 = 1;
pub const CONFIG_SND_ENS1371_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_TWOFISH_MODULE: u32 = 1;
pub const CONFIG_FREEZER: u32 = 1;
pub const CONFIG_SENSORS_I5500_MODULE: u32 = 1;
pub const CONFIG_USB_F_SUBSET_MODULE: u32 = 1;
pub const CONFIG_FIREWIRE_NET_MODULE: u32 = 1;
pub const CONFIG_HAVE_HARDLOCKUP_DETECTOR_PERF: u32 = 1;
pub const CONFIG_COMEDI_ADV_PCI1724_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2413_MODULE: u32 = 1;
pub const CONFIG_USB_TEST_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_MAX11801_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8737_MODULE: u32 = 1;
pub const CONFIG_ADAPTEC_STARFIRE_MODULE: u32 = 1;
pub const CONFIG_BT_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_BCM590XX_MODULE: u32 = 1;
pub const CONFIG_BT_HCIVHCI_MODULE: u32 = 1;
pub const CONFIG_INPUT_CM109_MODULE: u32 = 1;
pub const CONFIG_AXP288_FUEL_GAUGE_MODULE: u32 = 1;
pub const CONFIG_PCI_DOMAINS: u32 = 1;
pub const CONFIG_EFI_VARS: u32 = 1;
pub const CONFIG_CEC_PLATFORM_DRIVERS: u32 = 1;
pub const CONFIG_USB_SWITCH_FSA9480_MODULE: u32 = 1;
pub const CONFIG_MS5637_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_88PM800_MODULE: u32 = 1;
pub const CONFIG_NFT_QUEUE_MODULE: u32 = 1;
pub const CONFIG_LCD_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_MXL111SF_MODULE: u32 = 1;
pub const CONFIG_SENSORS_IT87_MODULE: u32 = 1;
pub const CONFIG_LPC_SCH_MODULE: u32 = 1;
pub const CONFIG_NET_CLS_ACT: u32 = 1;
pub const CONFIG_MLX90614_MODULE: u32 = 1;
pub const CONFIG_REED_SOLOMON_MODULE: u32 = 1;
pub const CONFIG_CIFS_DFS_UPCALL: u32 = 1;
pub const CONFIG_NET_VENDOR_CHELSIO: u32 = 1;
pub const CONFIG_LZ4HC_COMPRESS_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADL_PCI6208_MODULE: u32 = 1;
pub const CONFIG_HDLC_RAW_ETH_MODULE: u32 = 1;
pub const CONFIG_COMEDI_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_LEWISBURG_MODULE: u32 = 1;
pub const CONFIG_EFIVAR_FS: u32 = 1;
pub const CONFIG_BRIDGE_EBT_BROUTE_MODULE: u32 = 1;
pub const CONFIG_USB_NET_SMSC75XX_MODULE: u32 = 1;
pub const CONFIG_LNET_SELFTEST_MODULE: u32 = 1;
pub const CONFIG_BE2NET_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_TPS80031_MODULE: u32 = 1;
pub const CONFIG_PARPORT_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_VMAP_STACK: u32 = 1;
pub const CONFIG_VORTEX_MODULE: u32 = 1;
pub const CONFIG_IPVTAP_MODULE: u32 = 1;
pub const CONFIG_SPEAKUP_SYNTH_DECTLK_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_IPVS_MODULE: u32 = 1;
pub const CONFIG_TIPC_MEDIA_UDP: u32 = 1;
pub const CONFIG_VMWARE_VMCI_VSOCKETS_MODULE: u32 = 1;
pub const CONFIG_X86_DEBUGCTLMSR: u32 = 1;
pub const CONFIG_HDLC_MODULE: u32 = 1;
pub const CONFIG_NET_CLS_BPF_MODULE: u32 = 1;
pub const CONFIG_ATM_SOLOS_MODULE: u32 = 1;
pub const CONFIG_8139TOO_PIO: u32 = 1;
pub const CONFIG_NET_DSA_TAG_BRCM_PREPEND: u32 = 1;
pub const CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN: &'static [u8; 11usize] = b"kernel.org\0";
pub const CONFIG_IP_SET_MAX: u32 = 256;
pub const CONFIG_HAPPYMEAL_MODULE: u32 = 1;
pub const CONFIG_HID_WACOM_MODULE: u32 = 1;
pub const CONFIG_USB_F_ACM_MODULE: u32 = 1;
pub const CONFIG_QLCNIC_DCB: u32 = 1;
pub const CONFIG_SCIF_BUS_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_CP210X_MODULE: u32 = 1;
pub const CONFIG_SND_PCMCIA: u32 = 1;
pub const CONFIG_HMM_MIRROR: u32 = 1;
pub const CONFIG_NET_SCH_SFQ_MODULE: u32 = 1;
pub const CONFIG_RTC_LIB: u32 = 1;
pub const CONFIG_DEVFREQ_GOV_POWERSAVE: u32 = 1;
pub const CONFIG_NET_SCH_CBS_MODULE: u32 = 1;
pub const CONFIG_NVDIMM_DAX: u32 = 1;
pub const CONFIG_X86_LOCAL_APIC: u32 = 1;
pub const CONFIG_USB_GOKU_MODULE: u32 = 1;
pub const CONFIG_USB_UEAGLEATM_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_POLICY_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADV_PCI1760_MODULE: u32 = 1;
pub const CONFIG_MWL8K_MODULE: u32 = 1;
pub const CONFIG_MTD_MT81xx_NOR_MODULE: u32 = 1;
pub const CONFIG_HAVE_KPROBES: u32 = 1;
pub const CONFIG_NUMA_BALANCING_DEFAULT_ENABLED: u32 = 1;
pub const CONFIG_FB_TFT_AGM1264K_FL_MODULE: u32 = 1;
pub const CONFIG_SND_DESIGNWARE_PCM: u32 = 1;
pub const CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS: u32 = 1;
pub const CONFIG_HDM_I2C_MODULE: u32 = 1;
pub const CONFIG_FB_INTEL_MODULE: u32 = 1;
pub const CONFIG_TPS65010_MODULE: u32 = 1;
pub const CONFIG_IP_ROUTE_CLASSID: u32 = 1;
pub const CONFIG_MOUSE_SYNAPTICS_I2C_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_TEE_MODULE: u32 = 1;
pub const CONFIG_SND_USB_VARIAX_MODULE: u32 = 1;
pub const CONFIG_HPWDT_NMI_DECODING: u32 = 1;
pub const CONFIG_R8822BE_MODULE: u32 = 1;
pub const CONFIG_ENC28J60_MODULE: u32 = 1;
pub const CONFIG_MOUSE_PS2_TOUCHKIT: u32 = 1;
pub const CONFIG_PWM_LP3943_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_XSENS_MT_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX88_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_ITM: u32 = 1;
pub const CONFIG_CRYPTO_AES: u32 = 1;
pub const CONFIG_BACKLIGHT_LP855X_MODULE: u32 = 1;
pub const CONFIG_DVB_DIB7000P_MODULE: u32 = 1;
pub const CONFIG_GPIOLIB: u32 = 1;
pub const CONFIG_MFD_TI_AM335X_TSCADC_MODULE: u32 = 1;
pub const CONFIG_SSB_MODULE: u32 = 1;
pub const CONFIG_ZONE_DEVICE: u32 = 1;
pub const CONFIG_REGULATOR_ISL6271A_MODULE: u32 = 1;
pub const CONFIG_FUTEX_PI: u32 = 1;
pub const CONFIG_FB_MATROX_I2C_MODULE: u32 = 1;
pub const CONFIG_BMC150_ACCEL_SPI_MODULE: u32 = 1;
pub const CONFIG_I2C_STUB_MODULE: u32 = 1;
pub const CONFIG_EXTCON_MAX8997_MODULE: u32 = 1;
pub const CONFIG_DM_BIO_PRISON_MODULE: u32 = 1;
pub const CONFIG_INPUT_DRV2667_HAPTICS_MODULE: u32 = 1;
pub const CONFIG_GENERIC_CPU_VULNERABILITIES: u32 = 1;
pub const CONFIG_VIDEO_EM28XX_RC_MODULE: u32 = 1;
pub const CONFIG_NFT_LIMIT_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_WITHIN_STACK_FRAMES: u32 = 1;
pub const CONFIG_RADIO_TEA5764_MODULE: u32 = 1;
pub const CONFIG_AQTION_MODULE: u32 = 1;
pub const CONFIG_DVB_LNBH25_MODULE: u32 = 1;
pub const CONFIG_KEYS_COMPAT: u32 = 1;
pub const CONFIG_PINCTRL_MCP23S08_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_SPCA1528_MODULE: u32 = 1;
pub const CONFIG_LEDS_TLC591XX_MODULE: u32 = 1;
pub const CONFIG_FB_SVGALIB_MODULE: u32 = 1;
pub const CONFIG_BMC150_MAGN_MODULE: u32 = 1;
pub const CONFIG_PARPORT_AX88796_MODULE: u32 = 1;
pub const CONFIG_TI_ADC128S052_MODULE: u32 = 1;
pub const CONFIG_AD2S1210_MODULE: u32 = 1;
pub const CONFIG_HID_PID: u32 = 1;
pub const CONFIG_NV_TCO_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_QT2_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_PCM179X_MODULE: u32 = 1;
pub const CONFIG_SMSC9420_MODULE: u32 = 1;
pub const CONFIG_COMEDI_PCI_DRIVERS_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX6639_MODULE: u32 = 1;
pub const CONFIG_GAMEPORT_MODULE: u32 = 1;
pub const CONFIG_ISO9660_FS_MODULE: u32 = 1;
pub const CONFIG_SKY2_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_NAT_MODULE: u32 = 1;
pub const CONFIG_AD7793_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_H4: u32 = 1;
pub const CONFIG_LEDS_NIC78BX_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_F_MIDI: u32 = 1;
pub const CONFIG_INPUT_GPIO_TILT_POLLED_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS3232_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_PCM3168A_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MC13783_MODULE: u32 = 1;
pub const CONFIG_CROS_KBD_LED_BACKLIGHT_MODULE: u32 = 1;
pub const CONFIG_SND_PCM_ELD: u32 = 1;
pub const CONFIG_XEN_WDT_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_M920X_MODULE: u32 = 1;
pub const CONFIG_UIO_MODULE: u32 = 1;
pub const CONFIG_HID_WALTOP_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_LM3630A_MODULE: u32 = 1;
pub const CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR: u32 = 1;
pub const CONFIG_SOC_CAMERA_MT9T031_MODULE: u32 = 1;
pub const CONFIG_ADIS16136_MODULE: u32 = 1;
pub const CONFIG_GPIO_RC5T583: u32 = 1;
pub const CONFIG_VIDEO_ADV7170_MODULE: u32 = 1;
pub const CONFIG_UIO_DMEM_GENIRQ_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_TAS5086_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_AQUANTIA: u32 = 1;
pub const CONFIG_SCSI_VIRTIO_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_MARK: u32 = 1;
pub const CONFIG_IDLE_PAGE_TRACKING: u32 = 1;
pub const CONFIG_HVC_DRIVER: u32 = 1;
pub const CONFIG_BLK_DEV_PCIESSD_MTIP32XX_MODULE: u32 = 1;
pub const CONFIG_NETFILTER: u32 = 1;
pub const CONFIG_NFT_REJECT_IPV4_MODULE: u32 = 1;
pub const CONFIG_RC_LOOPBACK_MODULE: u32 = 1;
pub const CONFIG_ISDN_DRV_AVMB1_T1PCI_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_HASHLIMIT_MODULE: u32 = 1;
pub const CONFIG_MODULE_SIG: u32 = 1;
pub const CONFIG_BRIDGE_EBT_AMONG_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DT2814_MODULE: u32 = 1;
pub const CONFIG_B53_MODULE: u32 = 1;
pub const CONFIG_ATH9K_WOW: u32 = 1;
pub const CONFIG_B43_PIO: u32 = 1;
pub const CONFIG_BACKLIGHT_88PM860X_MODULE: u32 = 1;
pub const CONFIG_X86_DEV_DMA_OPS: u32 = 1;
pub const CONFIG_B43_BUSES_BCMA_AND_SSB: u32 = 1;
pub const CONFIG_ADIS16201_MODULE: u32 = 1;
pub const CONFIG_USB_R8A66597_HCD_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_TWL4030_MODULE: u32 = 1;
pub const CONFIG_X86_MSR_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_KASAN: u32 = 1;
pub const CONFIG_NET_VENDOR_SMSC: u32 = 1;
pub const CONFIG_BACKLIGHT_PM8941_WLED_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_NETLINK_ACCT_MODULE: u32 = 1;
pub const CONFIG_COMEDI_8254_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CLUSTER_MODULE: u32 = 1;
pub const CONFIG_USB_KC2190: u32 = 1;
pub const CONFIG_R6040_MODULE: u32 = 1;
pub const CONFIG_USB_MDC800_MODULE: u32 = 1;
pub const CONFIG_AIRO_CS_MODULE: u32 = 1;
pub const CONFIG_6LOWPAN_MODULE: u32 = 1;
pub const CONFIG_VIPERBOARD_ADC_MODULE: u32 = 1;
pub const CONFIG_HWMON_VID_MODULE: u32 = 1;
pub const CONFIG_SERIO_SERPORT_MODULE: u32 = 1;
pub const CONFIG_FB_BOOT_VESA_SUPPORT: u32 = 1;
pub const CONFIG_ISDN_PPP_VJ: u32 = 1;
pub const CONFIG_COMEDI_ME4000_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_950_MODULE: u32 = 1;
pub const CONFIG_DVB_STV0297_MODULE: u32 = 1;
pub const CONFIG_DVB_TTUSB_DEC_MODULE: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_ONESHOT_MODULE: u32 = 1;
pub const CONFIG_HAVE_NMI: u32 = 1;
pub const CONFIG_LIRC_MODULE: u32 = 1;
pub const CONFIG_INPUT_PWM_BEEPER_MODULE: u32 = 1;
pub const CONFIG_SCSI_AIC94XX_MODULE: u32 = 1;
pub const CONFIG_BT_BNEP_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_QFQ_MODULE: u32 = 1;
pub const CONFIG_DVB_TDA826X_MODULE: u32 = 1;
pub const CONFIG_COMEDI_MPC624_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_RAM_COUNT: u32 = 16;
pub const CONFIG_SCSI_FUTURE_DOMAIN_MODULE: u32 = 1;
pub const CONFIG_IXGBEVF_MODULE: u32 = 1;
pub const CONFIG_SND_AC97_POWER_SAVE_DEFAULT: u32 = 0;
pub const CONFIG_TABLET_SERIAL_WACOM4_MODULE: u32 = 1;
pub const CONFIG_THINKPAD_ACPI_DEBUGFACILITIES: u32 = 1;
pub const CONFIG_DVB_NGENE_MODULE: u32 = 1;
pub const CONFIG_RD_XZ: u32 = 1;
pub const CONFIG_IP_MROUTE: u32 = 1;
pub const CONFIG_INET_XFRM_MODE_TUNNEL_MODULE: u32 = 1;
pub const CONFIG_VIDEO_MXB_MODULE: u32 = 1;
pub const CONFIG_SYSTEM_EXTRA_CERTIFICATE: u32 = 1;
pub const CONFIG_X86_SMAP: u32 = 1;
pub const CONFIG_SND_SOC_TLV320AIC23_MODULE: u32 = 1;
pub const CONFIG_VGA_CONSOLE: u32 = 1;
pub const CONFIG_DEVFREQ_THERMAL: u32 = 1;
pub const CONFIG_NF_NAT_NEEDED: u32 = 1;
pub const CONFIG_CRYPTO_ECDH_MODULE: u32 = 1;
pub const CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS: u32 = 1;
pub const CONFIG_TINYDRM_MIPI_DBI_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_TUNNEL_KEY_MODULE: u32 = 1;
pub const CONFIG_HID_RMI_MODULE: u32 = 1;
pub const CONFIG_USB_F_UAC1_LEGACY_MODULE: u32 = 1;
pub const CONFIG_ATA_VERBOSE_ERROR: u32 = 1;
pub const CONFIG_ISDN_DRV_AVMB1_B1PCMCIA_MODULE: u32 = 1;
pub const CONFIG_XEN_BLKDEV_FRONTEND: u32 = 1;
pub const CONFIG_NF_CONNTRACK_SNMP_MODULE: u32 = 1;
pub const CONFIG_RTLHALMAC_ST_MODULE: u32 = 1;
pub const CONFIG_CM3232_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_AUDIO_MODULE: u32 = 1;
pub const CONFIG_SND_DRIVERS: u32 = 1;
pub const CONFIG_HISAX_S0BOX: u32 = 1;
pub const CONFIG_USB_SERIAL_BELKIN_MODULE: u32 = 1;
pub const CONFIG_W1_MASTER_DS2490_MODULE: u32 = 1;
pub const CONFIG_PRINTK_NMI: u32 = 1;
pub const CONFIG_MEDIA_TUNER_MT2266_MODULE: u32 = 1;
pub const CONFIG_NLS_MAC_GREEK_MODULE: u32 = 1;
pub const CONFIG_NET_FLOW_LIMIT: u32 = 1;
pub const CONFIG_XFS_FS_MODULE: u32 = 1;
pub const CONFIG_SENSORS_DME1737_MODULE: u32 = 1;
pub const CONFIG_INPUT_KEYSPAN_REMOTE_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_PAC7302_MODULE: u32 = 1;
pub const CONFIG_LOCKDEP_SUPPORT: u32 = 1;
pub const CONFIG_X86_MCE_INJECT_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_ELO_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_869_MODULE: u32 = 1;
pub const CONFIG_SENSORS_NCT7904_MODULE: u32 = 1;
pub const CONFIG_SND_AZT3328_MODULE: u32 = 1;
pub const CONFIG_NF_LOG_BRIDGE_MODULE: u32 = 1;
pub const CONFIG_SND_AC97_POWER_SAVE: u32 = 1;
pub const CONFIG_IP6_NF_TARGET_MASQUERADE_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_PALMAS_MODULE: u32 = 1;
pub const CONFIG_NFT_REDIR_MODULE: u32 = 1;
pub const CONFIG_SATA_VIA_MODULE: u32 = 1;
pub const CONFIG_COMEDI_PCMMIO_MODULE: u32 = 1;
pub const CONFIG_ACPI_PROCESSOR_IDLE: u32 = 1;
pub const CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION: u32 = 1;
pub const CONFIG_NO_HZ: u32 = 1;
pub const CONFIG_INTEL_SOC_PMIC: u32 = 1;
pub const CONFIG_ARCH_WANT_HUGE_PMD_SHARE: u32 = 1;
pub const CONFIG_BMI160_MODULE: u32 = 1;
pub const CONFIG_POSIX_MQUEUE: u32 = 1;
pub const CONFIG_NOUVEAU_DEBUG: u32 = 5;
pub const CONFIG_MLX5_FPGA: u32 = 1;
pub const CONFIG_NETFILTER_INGRESS: u32 = 1;
pub const CONFIG_SND_SOC_TOPOLOGY: u32 = 1;
pub const CONFIG_TOUCHSCREEN_TOUCHIT213_MODULE: u32 = 1;
pub const CONFIG_GPIO_DWAPB_MODULE: u32 = 1;
pub const CONFIG_LTC2632_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_PFUZE100_MODULE: u32 = 1;
pub const CONFIG_ARCH_WANTS_DYNAMIC_TASK_STRUCT: u32 = 1;
pub const CONFIG_FB_PM2_FIFO_DISCONNECT: u32 = 1;
pub const CONFIG_TOUCHSCREEN_STMFTS_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LM83_MODULE: u32 = 1;
pub const CONFIG_USB_NET_CDC_MBIM_MODULE: u32 = 1;
pub const CONFIG_SENSORS_TMP108_MODULE: u32 = 1;
pub const CONFIG_PMC_ATOM: u32 = 1;
pub const CONFIG_ACENIC_MODULE: u32 = 1;
pub const CONFIG_ARCH_MIGHT_HAVE_PC_SERIO: u32 = 1;
pub const CONFIG_PSTORE_RAM_MODULE: u32 = 1;
pub const CONFIG_COMEDI_PCM3724_MODULE: u32 = 1;
pub const CONFIG_LEDS_BLINKM_MODULE: u32 = 1;
pub const CONFIG_INPUT_PWM_VIBRA_MODULE: u32 = 1;
pub const CONFIG_CPU_FREQ_STAT: u32 = 1;
pub const CONFIG_JFS_STATISTICS: u32 = 1;
pub const CONFIG_ISCSI_IBFT_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_DAQ_700_CS_MODULE: u32 = 1;
pub const CONFIG_SPI_PXA2XX_MODULE: u32 = 1;
pub const CONFIG_PCMCIA_SMC91C92_MODULE: u32 = 1;
pub const CONFIG_WILC1000_HW_OOB_INTR: u32 = 1;
pub const CONFIG_SND_SOC_DIO2125_MODULE: u32 = 1;
pub const CONFIG_BT_HCIDTL1_MODULE: u32 = 1;
pub const CONFIG_TIFM_CORE_MODULE: u32 = 1;
pub const CONFIG_XEN_PRIVCMD_MODULE: u32 = 1;
pub const CONFIG_FUSION_SAS_MODULE: u32 = 1;
pub const CONFIG_GENERIC_STRNCPY_FROM_USER: u32 = 1;
pub const CONFIG_CHR_DEV_OSST_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_SSD1331_MODULE: u32 = 1;
pub const CONFIG_MTD_BLKDEVS_MODULE: u32 = 1;
pub const CONFIG_GPIO_KEMPLD_MODULE: u32 = 1;
pub const CONFIG_DVB_TDA10086_MODULE: u32 = 1;
pub const CONFIG_HP100_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_3W_XXXX_RAID_MODULE: u32 = 1;
pub const CONFIG_MEMSTICK_R592_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_MQPRIO_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_NETMAP_MODULE: u32 = 1;
pub const CONFIG_FSI_MODULE: u32 = 1;
pub const CONFIG_MLX5_CORE_EN_DCB: u32 = 1;
pub const CONFIG_VIDEO_VPX3220_MODULE: u32 = 1;
pub const CONFIG_APDS9802ALS_MODULE: u32 = 1;
pub const CONFIG_DVB_NXT6000_MODULE: u32 = 1;
pub const CONFIG_SPMI_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_NITROX_MODULE: u32 = 1;
pub const CONFIG_MANTIS_CORE_MODULE: u32 = 1;
pub const CONFIG_PATA_MARVELL_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CAMELLIA_AESNI_AVX_X86_64_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_SCTP_MODULE: u32 = 1;
pub const CONFIG_SERIO_GPIO_PS2_MODULE: u32 = 1;
pub const CONFIG_SATA_SIL24_MODULE: u32 = 1;
pub const CONFIG_RTL8723BS_MODULE: u32 = 1;
pub const CONFIG_SMS_SIANO_RC: u32 = 1;
pub const CONFIG_SND_SOC_CS42L52_MODULE: u32 = 1;
pub const CONFIG_CRASH_CORE: u32 = 1;
pub const CONFIG_ISL29125_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_DEC: u32 = 1;
pub const CONFIG_MDIO_CAVIUM_MODULE: u32 = 1;
pub const CONFIG_NLS_ISO8859_15_MODULE: u32 = 1;
pub const CONFIG_HID_SENSOR_MAGNETOMETER_3D_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_EETI_MODULE: u32 = 1;
pub const CONFIG_SENSORS_VIA686A_MODULE: u32 = 1;
pub const CONFIG_INET6_ESP_MODULE: u32 = 1;
pub const CONFIG_HOSTAP_PCI_MODULE: u32 = 1;
pub const CONFIG_IP_VS_WRR_MODULE: u32 = 1;
pub const CONFIG_INTEL_IOMMU_SVM: u32 = 1;
pub const CONFIG_AUTOFS4_FS_MODULE: u32 = 1;
pub const CONFIG_NET_NSH_MODULE: u32 = 1;
pub const CONFIG_ATH5K_MODULE: u32 = 1;
pub const CONFIG_VIDEO_FB_IVTV_MODULE: u32 = 1;
pub const CONFIG_ACPI_BUTTON: u32 = 1;
pub const CONFIG_LEDS_LM355x_MODULE: u32 = 1;
pub const CONFIG_ILLEGAL_POINTER_VALUE: i64 = -2401263026318606336;
pub const CONFIG_CRYPTO_DEV_CCP_CRYPTO_MODULE: u32 = 1;
pub const CONFIG_SYSCTL_SYSCALL: u32 = 1;
pub const CONFIG_UIO_NETX_MODULE: u32 = 1;
pub const CONFIG_PDA_POWER_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_SET_MODULE: u32 = 1;
pub const CONFIG_NLS_MAC_CROATIAN_MODULE: u32 = 1;
pub const CONFIG_SFC_MTD: u32 = 1;
pub const CONFIG_FMC_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_MAX98090_MODULE: u32 = 1;
pub const CONFIG_TASKSTATS: u32 = 1;
pub const CONFIG_EXTCON_GPIO_MODULE: u32 = 1;
pub const CONFIG_ARCNET_1201_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_932_MODULE: u32 = 1;
pub const CONFIG_INTEL_PMC_IPC_MODULE: u32 = 1;
pub const CONFIG_MCB_MODULE: u32 = 1;
pub const CONFIG_RT2X00_LIB_MMIO_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CRC32C_INTEL: u32 = 1;
pub const CONFIG_WILC1000_MODULE: u32 = 1;
pub const CONFIG_NLS_MAC_ICELAND_MODULE: u32 = 1;
pub const CONFIG_SND_ATMEL_SOC_MODULE: u32 = 1;
pub const CONFIG_MEDIA_SUBDRV_AUTOSELECT: u32 = 1;
pub const CONFIG_TOUCHSCREEN_TSC200X_CORE_MODULE: u32 = 1;
pub const CONFIG_CAN_PLX_PCI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT5677_SPI_MODULE: u32 = 1;
pub const CONFIG_USB_FUNCTIONFS_GENERIC: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_BYTCR_RT5651_MACH_MODULE: u32 = 1;
pub const CONFIG_JFS_POSIX_ACL: u32 = 1;
pub const CONFIG_I2C_ALI1563_MODULE: u32 = 1;
pub const CONFIG_IP6_NF_FILTER_MODULE: u32 = 1;
pub const CONFIG_DELL_WMI_DESCRIPTOR_MODULE: u32 = 1;
pub const CONFIG_SYSTEM_DATA_VERIFICATION: u32 = 1;
pub const CONFIG_CRAMFS_MTD: u32 = 1;
pub const CONFIG_EFI_ESRT: u32 = 1;
pub const CONFIG_INPUT_MOUSEDEV_SCREEN_X: u32 = 1024;
pub const CONFIG_NEED_DMA_MAP_STATE: u32 = 1;
pub const CONFIG_FB_TFT_ILI9340_MODULE: u32 = 1;
pub const CONFIG_IIO_TRIGGERED_EVENT_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_MODULE: u32 = 1;
pub const CONFIG_SENSORS_G762_MODULE: u32 = 1;
pub const CONFIG_IIO_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_PREALLOC_SIZE: u32 = 64;
pub const CONFIG_GARP_MODULE: u32 = 1;
pub const CONFIG_PCMCIA_AHA152X_MODULE: u32 = 1;
pub const CONFIG_INPUT_TWL6040_VIBRA_MODULE: u32 = 1;
pub const CONFIG_RT2500USB_MODULE: u32 = 1;
pub const CONFIG_YENTA_ENE_TUNE: u32 = 1;
pub const CONFIG_MOUSE_PS2_LIFEBOOK: u32 = 1;
pub const CONFIG_SERIO_LIBPS2: u32 = 1;
pub const CONFIG_BLK_DEV_DRBD_MODULE: u32 = 1;
pub const CONFIG_IP_VS_PROTO_TCP: u32 = 1;
pub const CONFIG_QED_OOO: u32 = 1;
pub const CONFIG_ISCSI_BOOT_SYSFS_MODULE: u32 = 1;
pub const CONFIG_X86_CPUID_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_RED_MODULE: u32 = 1;
pub const CONFIG_PCI_ATMEL_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_NFACCT_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CONNBYTES_MODULE: u32 = 1;
pub const CONFIG_KDB_CONTINUE_CATASTROPHIC: u32 = 0;
pub const CONFIG_LNET_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_METRO_MODULE: u32 = 1;
pub const CONFIG_USB_PRINTER_MODULE: u32 = 1;
pub const CONFIG_HISAX_DIEHLDIVA: u32 = 1;
pub const CONFIG_FONT_8x8: u32 = 1;
pub const CONFIG_SSB_SPROM: u32 = 1;
pub const CONFIG_AUFS_DIRREN: u32 = 1;
pub const CONFIG_USB_GSPCA_PAC207_MODULE: u32 = 1;
pub const CONFIG_RAPIDIO_RXS_GEN3_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_ATHEROS: u32 = 1;
pub const CONFIG_TRANSPARENT_HUGE_PAGECACHE: u32 = 1;
pub const CONFIG_USB_SERIAL_IR_MODULE: u32 = 1;
pub const CONFIG_IIO_CROS_EC_BARO_MODULE: u32 = 1;
pub const CONFIG_FB_SIMPLE: u32 = 1;
pub const CONFIG_SKGE_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DT9812_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_ACT8865_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AK4104_MODULE: u32 = 1;
pub const CONFIG_INPUT_DA9055_ONKEY_MODULE: u32 = 1;
pub const CONFIG_TCM_PSCSI_MODULE: u32 = 1;
pub const CONFIG_RELOCATABLE: u32 = 1;
pub const CONFIG_DMARD10_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_POLY1305_MODULE: u32 = 1;
pub const CONFIG_QUEUED_SPINLOCKS: u32 = 1;
pub const CONFIG_XOR_BLOCKS_MODULE: u32 = 1;
pub const CONFIG_AD8801_MODULE: u32 = 1;
pub const CONFIG_HID_TWINHAN_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_HMM: u32 = 1;
pub const CONFIG_NFS_V4_1_MIGRATION: u32 = 1;
pub const CONFIG_SENSORS_NTC_THERMISTOR_MODULE: u32 = 1;
pub const CONFIG_SPI_OC_TINY_MODULE: u32 = 1;
pub const CONFIG_AS3935_MODULE: u32 = 1;
pub const CONFIG_MISDN_L1OIP_MODULE: u32 = 1;
pub const CONFIG_DVB_PT1_MODULE: u32 = 1;
pub const CONFIG_DMIID: u32 = 1;
pub const CONFIG_NET_VENDOR_SUN: u32 = 1;
pub const CONFIG_ARCH_HAS_MEM_ENCRYPT: u32 = 1;
pub const CONFIG_PANIC_TIMEOUT: u32 = 0;
pub const CONFIG_ASUS_WMI_MODULE: u32 = 1;
pub const CONFIG_SENSORS_DS1621_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_IMG_PARALLEL_OUT_MODULE: u32 = 1;
pub const CONFIG_PC104: u32 = 1;
pub const CONFIG_MMC_TOSHIBA_PCI_MODULE: u32 = 1;
pub const CONFIG_QUOTA_NETLINK_INTERFACE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_BDW_RT5677_MACH_MODULE: u32 = 1;
pub const CONFIG_INPUT_JOYSTICK: u32 = 1;
pub const CONFIG_QNX4FS_FS_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_SIMP_MODULE: u32 = 1;
pub const CONFIG_USB_OXU210HP_HCD_MODULE: u32 = 1;
pub const CONFIG_RT2X00_LIB_MODULE: u32 = 1;
pub const CONFIG_USB_DWC2: u32 = 1;
pub const CONFIG_HID_BATTERY_STRENGTH: u32 = 1;
pub const CONFIG_PM_GENERIC_DOMAINS_SLEEP: u32 = 1;
pub const CONFIG_YAM_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_DS28E17_MODULE: u32 = 1;
pub const CONFIG_MACB_PCI_MODULE: u32 = 1;
pub const CONFIG_DM_VERITY_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_ECN_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_STV0680_MODULE: u32 = 1;
pub const CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT: u32 = 1;
pub const CONFIG_SYSTEM_BLACKLIST_HASH_LIST: &'static [u8; 1usize] = b"\0";
pub const CONFIG_TYPEC_TCPM_MODULE: u32 = 1;
pub const CONFIG_ATH9K_PCOEM: u32 = 1;
pub const CONFIG_SND_FM801_TEA575X_BOOL: u32 = 1;
pub const CONFIG_USB_STORAGE_SDDR55_MODULE: u32 = 1;
pub const CONFIG_PPDEV_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS4271_SPI_MODULE: u32 = 1;
pub const CONFIG_SENSORS_TPS53679_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_S6D02A1_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_BAYTRAIL_MODULE: u32 = 1;
pub const CONFIG_IP_NF_TARGET_TTL_MODULE: u32 = 1;
pub const CONFIG_AMILO_RFKILL_MODULE: u32 = 1;
pub const CONFIG_NF_NAT_MASQUERADE_IPV4_MODULE: u32 = 1;
pub const CONFIG_ISDN_DRV_AVMB1_B1PCI_MODULE: u32 = 1;
pub const CONFIG_LWTUNNEL_BPF: u32 = 1;
pub const CONFIG_CFG80211_DEFAULT_PS: u32 = 1;
pub const CONFIG_NFT_META_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8974_MODULE: u32 = 1;
pub const CONFIG_BUILD_BIN2C: u32 = 1;
pub const CONFIG_GENERIC_IOMAP: u32 = 1;
pub const CONFIG_IEEE802154_FAKELB_MODULE: u32 = 1;
pub const CONFIG_USBIP_HOST_MODULE: u32 = 1;
pub const CONFIG_CHARGER_BQ24190_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_WACOM_W8001_MODULE: u32 = 1;
pub const CONFIG_IIO_ST_PRESS_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADL_PCI7X3X_MODULE: u32 = 1;
pub const CONFIG_DVB_PLUTO2_MODULE: u32 = 1;
pub const CONFIG_RTL8723AE_MODULE: u32 = 1;
pub const CONFIG_DECOMPRESS_LZ4: u32 = 1;
pub const CONFIG_SND_SOC_ADAU7002_MODULE: u32 = 1;
pub const CONFIG_THUNDER_NIC_RGX_MODULE: u32 = 1;
pub const CONFIG_XEN_FBDEV_FRONTEND_MODULE: u32 = 1;
pub const CONFIG_GPIO_DLN2_MODULE: u32 = 1;
pub const CONFIG_SPARSEMEM_MANUAL: u32 = 1;
pub const CONFIG_DVB_AV7110_MODULE: u32 = 1;
pub const CONFIG_DMI_SCAN_MACHINE_NON_EFI_FALLBACK: u32 = 1;
pub const CONFIG_DVB_OR51132_MODULE: u32 = 1;
pub const CONFIG_RT2X00_LIB_FIRMWARE: u32 = 1;
pub const CONFIG_DL2K_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_MMS114_MODULE: u32 = 1;
pub const CONFIG_SXGBE_ETH_MODULE: u32 = 1;
pub const CONFIG_BPF_SYSCALL: u32 = 1;
pub const CONFIG_SMP: u32 = 1;
pub const CONFIG_IR_SIR_MODULE: u32 = 1;
pub const CONFIG_FB_KYRO_MODULE: u32 = 1;
pub const CONFIG_DVB_ZL10353_MODULE: u32 = 1;
pub const CONFIG_MFD_INTEL_LPSS_ACPI_MODULE: u32 = 1;
pub const CONFIG_TTY: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_TIME_MODULE: u32 = 1;
pub const CONFIG_IP_VS_MODULE: u32 = 1;
pub const CONFIG_HAVE_KERNEL_GZIP: u32 = 1;
pub const CONFIG_TYPEC_TCPCI_MODULE: u32 = 1;
pub const CONFIG_ZSMALLOC: u32 = 1;
pub const CONFIG_I2C_MLXCPLD_MODULE: u32 = 1;
pub const CONFIG_DM_UEVENT: u32 = 1;
pub const CONFIG_CAN_ESD_USB2_MODULE: u32 = 1;
pub const CONFIG_CAIF_VIRTIO_MODULE: u32 = 1;
pub const CONFIG_USB_MV_UDC_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_I825XX: u32 = 1;
pub const CONFIG_MMA7660_MODULE: u32 = 1;
pub const CONFIG_USB_XUSBATM_MODULE: u32 = 1;
pub const CONFIG_PNP: u32 = 1;
pub const CONFIG_RTC_DRV_RP5C01_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_MAC_MODULE: u32 = 1;
pub const CONFIG_I2C_NFORCE2_S4985_MODULE: u32 = 1;
pub const CONFIG_THUNDER_NIC_BGX_MODULE: u32 = 1;
pub const CONFIG_SENSORS_NCT6775_MODULE: u32 = 1;
pub const CONFIG_YELLOWFIN_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_TPS6507X_MODULE: u32 = 1;
pub const CONFIG_DW_DMAC_CORE_MODULE: u32 = 1;
pub const CONFIG_COMEDI_AMPLC_DIO200_ISA_MODULE: u32 = 1;
pub const CONFIG_QED_ISCSI: u32 = 1;
pub const CONFIG_NET_ACT_PEDIT_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_NFLOG_MODULE: u32 = 1;
pub const CONFIG_VIDEO_BT819_MODULE: u32 = 1;
pub const CONFIG_DVB_ZD1301_DEMOD_MODULE: u32 = 1;
pub const CONFIG_DA9150_GPADC_MODULE: u32 = 1;
pub const CONFIG_XFRM_OFFLOAD: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_JASTEC: u32 = 1;
pub const CONFIG_GENERIC_ALLOCATOR: u32 = 1;
pub const CONFIG_OPENVSWITCH_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1390_MODULE: u32 = 1;
pub const CONFIG_L2TP_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_DA9052_MODULE: u32 = 1;
pub const CONFIG_DVB_B2C2_FLEXCOP_USB_MODULE: u32 = 1;
pub const CONFIG_TCP_CONG_WESTWOOD_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_M41T93_MODULE: u32 = 1;
pub const CONFIG_KALLSYMS_ALL: u32 = 1;
pub const CONFIG_ATM_FORE200E_TX_RETRY: u32 = 16;
pub const CONFIG_HID_AUREAL_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_SPCA561_MODULE: u32 = 1;
pub const CONFIG_IPMI_SSIF_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_SDIO_MODULE: u32 = 1;
pub const CONFIG_DRM_GMA600: u32 = 1;
pub const CONFIG_SQUASHFS_LZ4: u32 = 1;
pub const CONFIG_DLN2_ADC_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_PCM3168A_I2C_MODULE: u32 = 1;
pub const CONFIG_LIBCRC32C_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_MATRIX_MODULE: u32 = 1;
pub const CONFIG_RSI_USB_MODULE: u32 = 1;
pub const CONFIG_HAVE_BOOTMEM_INFO_NODE: u32 = 1;
pub const CONFIG_MFD_PCF50633_MODULE: u32 = 1;
pub const CONFIG_GENERIC_BUG: u32 = 1;
pub const CONFIG_CRYPTO_SHA256: u32 = 1;
pub const CONFIG_HAVE_FTRACE_MCOUNT_RECORD: u32 = 1;
pub const CONFIG_JOYSTICK_GUILLEMOT_MODULE: u32 = 1;
pub const CONFIG_MLXSW_MINIMAL_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1307_HWMON: u32 = 1;
pub const CONFIG_BRIDGE_VLAN_FILTERING: u32 = 1;
pub const CONFIG_VIDEO_AU0828_MODULE: u32 = 1;
pub const CONFIG_WL18XX_MODULE: u32 = 1;
pub const CONFIG_POSIX_TIMERS: u32 = 1;
pub const CONFIG_INET_TCP_DIAG_MODULE: u32 = 1;
pub const CONFIG_HID_SONY_MODULE: u32 = 1;
pub const CONFIG_VIDEO_PVRUSB2_DVB: u32 = 1;
pub const CONFIG_USB_F_PRINTER_MODULE: u32 = 1;
pub const CONFIG_MEMSTICK_REALTEK_PCI_MODULE: u32 = 1;
pub const CONFIG_PCI_PASID: u32 = 1;
pub const CONFIG_CRYPTO_BLOWFISH_X86_64_MODULE: u32 = 1;
pub const CONFIG_HW_CONSOLE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_NITROX_CNN55XX_MODULE: u32 = 1;
pub const CONFIG_MDIO_BITBANG_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_IPT_MODULE: u32 = 1;
pub const CONFIG_DVB_AS102_MODULE: u32 = 1;
pub const CONFIG_HAVE_KVM_IRQ_ROUTING: u32 = 1;
pub const CONFIG_BPF_STREAM_PARSER: u32 = 1;
pub const CONFIG_LEDS_MLXCPLD_MODULE: u32 = 1;
pub const CONFIG_PARIDE_ON26_MODULE: u32 = 1;
pub const CONFIG_SCSI_BNX2X_FCOE_MODULE: u32 = 1;
pub const CONFIG_MTD_UBI_GLUEBI_MODULE: u32 = 1;
pub const CONFIG_RAS: u32 = 1;
pub const CONFIG_COMMON_CLK_CDCE706_MODULE: u32 = 1;
pub const CONFIG_AD5761_MODULE: u32 = 1;
pub const CONFIG_VIDEO_GO7007_LOADER_MODULE: u32 = 1;
pub const CONFIG_SOC_CAMERA_TW9910_MODULE: u32 = 1;
pub const CONFIG_SOC_CAMERA_MT9V022_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DA9052_MODULE: u32 = 1;
pub const CONFIG_USB_ETH_EEM: u32 = 1;
pub const CONFIG_KEYBOARD_TWL4030_MODULE: u32 = 1;
pub const CONFIG_IPX_MODULE: u32 = 1;
pub const CONFIG_HYPERV_NET_MODULE: u32 = 1;
pub const CONFIG_REGMAP_SPMI_MODULE: u32 = 1;
pub const CONFIG_DEVMEM: u32 = 1;
pub const CONFIG_SMSC_PHY_MODULE: u32 = 1;
pub const CONFIG_BATTERY_MAX1721X_MODULE: u32 = 1;
pub const CONFIG_HP_ACCEL_MODULE: u32 = 1;
pub const CONFIG_MOUSE_PS2_FOCALTECH: u32 = 1;
pub const CONFIG_CAN_EMS_PCI_MODULE: u32 = 1;
pub const CONFIG_SCSI_BNX2_ISCSI_MODULE: u32 = 1;
pub const CONFIG_OMFS_FS_MODULE: u32 = 1;
pub const CONFIG_TCG_TIS_I2C_NUVOTON_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_ZC3XX_MODULE: u32 = 1;
pub const CONFIG_SND_ES1968_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_DA9062_MODULE: u32 = 1;
pub const CONFIG_SND_SPI: u32 = 1;
pub const CONFIG_EUROTECH_WDT_MODULE: u32 = 1;
pub const CONFIG_I2C_DLN2_MODULE: u32 = 1;
pub const CONFIG_MLX5_CORE_MODULE: u32 = 1;
pub const CONFIG_NFT_LOG_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_ADP8870_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_MTOUCH_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_EBT_IP_MODULE: u32 = 1;
pub const CONFIG_PARIDE_EPAT_MODULE: u32 = 1;
pub const CONFIG_HID_MONTEREY_MODULE: u32 = 1;
pub const CONFIG_CGROUP_RDMA: u32 = 1;
pub const CONFIG_FB_UDL_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_CYPRESS_M8_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ES8328_SPI_MODULE: u32 = 1;
pub const CONFIG_FB_NEOMAGIC_MODULE: u32 = 1;
pub const CONFIG_HID_EZKEY_MODULE: u32 = 1;
pub const CONFIG_PADATA: u32 = 1;
pub const CONFIG_IOSCHED_NOOP: u32 = 1;
pub const CONFIG_USB_PULSE8_CEC_MODULE: u32 = 1;
pub const CONFIG_THERMAL_GOV_USER_SPACE: u32 = 1;
pub const CONFIG_DVB_S5H1409_MODULE: u32 = 1;
pub const CONFIG_IPW2200_QOS: u32 = 1;
pub const CONFIG_SCSI_LOWLEVEL_PCMCIA: u32 = 1;
pub const CONFIG_XEN_TMEM_MODULE: u32 = 1;
pub const CONFIG_ATH9K_COMMON_DEBUG: u32 = 1;
pub const CONFIG_EFI_CAPSULE_LOADER_MODULE: u32 = 1;
pub const CONFIG_JFFS2_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_INPUT_DA9052_ONKEY_MODULE: u32 = 1;
pub const CONFIG_DM_THIN_PROVISIONING_MODULE: u32 = 1;
pub const CONFIG_IPMI_DMI_DECODE: u32 = 1;
pub const CONFIG_HAVE_UID16: u32 = 1;
pub const CONFIG_SERIAL_NONSTANDARD: u32 = 1;
pub const CONFIG_RT61PCI_MODULE: u32 = 1;
pub const CONFIG_COMPAT_OLD_SIGACTION: u32 = 1;
pub const CONFIG_PATA_JMICRON_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2438_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_TSC_SERIO_MODULE: u32 = 1;
pub const CONFIG_RTC_NVMEM: u32 = 1;
pub const CONFIG_SCSI_OSD_ULD_MODULE: u32 = 1;
pub const CONFIG_X86_FEATURE_NAMES: u32 = 1;
pub const CONFIG_JOYSTICK_XPAD_LEDS: u32 = 1;
pub const CONFIG_SENSORS_TC74_MODULE: u32 = 1;
pub const CONFIG_IPW2100_MODULE: u32 = 1;
pub const CONFIG_SCSI_PPA_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_PWM_MODULE: u32 = 1;
pub const CONFIG_BT_MRVL_MODULE: u32 = 1;
pub const CONFIG_QUOTACTL: u32 = 1;
pub const CONFIG_RTC_DRV_RX8581_MODULE: u32 = 1;
pub const CONFIG_V4L2_MEM2MEM_DEV_MODULE: u32 = 1;
pub const CONFIG_FB_SAVAGE_I2C: u32 = 1;
pub const CONFIG_PARAVIRT: u32 = 1;
pub const CONFIG_TWL4030_MADC_MODULE: u32 = 1;
pub const CONFIG_WQ_POWER_EFFICIENT_DEFAULT: u32 = 1;
pub const CONFIG_HP03_MODULE: u32 = 1;
pub const CONFIG_SFC_FALCON_MTD: u32 = 1;
pub const CONFIG_INTEL_MENLOW_MODULE: u32 = 1;
pub const CONFIG_ISDN_CAPI_CAPI20_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CRYPTD_MODULE: u32 = 1;
pub const CONFIG_SCSI_EATA_MAX_TAGS: u32 = 16;
pub const CONFIG_NF_SOCKET_IPV4_MODULE: u32 = 1;
pub const CONFIG_SPARSEMEM_ALLOC_MEM_MAP_TOGETHER: u32 = 1;
pub const CONFIG_HAVE_IOREMAP_PROT: u32 = 1;
pub const CONFIG_CRYPTO_CHACHA20_X86_64_MODULE: u32 = 1;
pub const CONFIG_RPMSG_QCOM_GLINK_NATIVE_MODULE: u32 = 1;
pub const CONFIG_PHY_CPCAP_USB_MODULE: u32 = 1;
pub const CONFIG_CM32181_MODULE: u32 = 1;
pub const CONFIG_DVB_STV6111_MODULE: u32 = 1;
pub const CONFIG_USBIP_VHCI_HCD_MODULE: u32 = 1;
pub const CONFIG_PATA_RZ1000_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_ADP8860_MODULE: u32 = 1;
pub const CONFIG_MAX8925_POWER_MODULE: u32 = 1;
pub const CONFIG_CAPI_TRACE: u32 = 1;
pub const CONFIG_DEBUG_KERNEL: u32 = 1;
pub const CONFIG_MTD_RAM_MODULE: u32 = 1;
pub const CONFIG_RTL8192DE_MODULE: u32 = 1;
pub const CONFIG_ACPI_TOSHIBA_MODULE: u32 = 1;
pub const CONFIG_GAMEPORT_NS558_MODULE: u32 = 1;
pub const CONFIG_INV_MPU6050_IIO_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_F8153X_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MT6311_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LTC2978_REGULATOR: u32 = 1;
pub const CONFIG_DM_ZONED_MODULE: u32 = 1;
pub const CONFIG_SENSORS_TC654_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX2341X_MODULE: u32 = 1;
pub const CONFIG_I2C_VIPERBOARD_MODULE: u32 = 1;
pub const CONFIG_CHARLCD_MODULE: u32 = 1;
pub const CONFIG_LOCALVERSION: &'static [u8; 1usize] = b"\0";
pub const CONFIG_NCPFS_IOCTL_LOCKING: u32 = 1;
pub const CONFIG_REISERFS_FS_SECURITY: u32 = 1;
pub const CONFIG_DVB_STV6110x_MODULE: u32 = 1;
pub const CONFIG_PATA_IT821X_MODULE: u32 = 1;
pub const CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK: u32 = 1;
pub const CONFIG_ACERHDF_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_BROADWELL_MACH_MODULE: u32 = 1;
pub const CONFIG_RADIO_ADAPTERS: u32 = 1;
pub const CONFIG_REGULATOR_QCOM_SPMI_MODULE: u32 = 1;
pub const CONFIG_MEMTEST: u32 = 1;
pub const CONFIG_KEYBOARD_XTKBD_MODULE: u32 = 1;
pub const CONFIG_HAVE_PCSPKR_PLATFORM: u32 = 1;
pub const CONFIG_NFS_FSCACHE: u32 = 1;
pub const CONFIG_MAC80211_MESH: u32 = 1;
pub const CONFIG_MMC_WBSD_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_TOPRO_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_MARS_MODULE: u32 = 1;
pub const CONFIG_CAN_RAW_MODULE: u32 = 1;
pub const CONFIG_DVB_SI2165_MODULE: u32 = 1;
pub const CONFIG_CRYPTO: u32 = 1;
pub const CONFIG_I2C_MUX_PCA954x_MODULE: u32 = 1;
pub const CONFIG_FUNCTION_TRACER: u32 = 1;
pub const CONFIG_FB_MATROX_MILLENIUM: u32 = 1;
pub const CONFIG_SENSORS_EMC6W201_MODULE: u32 = 1;
pub const CONFIG_USB_TRANCEVIBRATOR_MODULE: u32 = 1;
pub const CONFIG_SCHED_DEBUG: u32 = 1;
pub const CONFIG_NFT_CHAIN_NAT_IPV4_MODULE: u32 = 1;
pub const CONFIG_SECURITY_SMACK_APPEND_SIGNALS: u32 = 1;
pub const CONFIG_USB_STKWEBCAM_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_BROCADE: u32 = 1;
pub const CONFIG_BTRFS_FS_MODULE: u32 = 1;
pub const CONFIG_BLK_WBT_MQ: u32 = 1;
pub const CONFIG_DEFAULT_MMAP_MIN_ADDR: u32 = 65536;
pub const CONFIG_SYSTEM_TRUSTED_KEYS: &'static [u8; 27usize] = b"debian/canonical-certs.pem\0";
pub const CONFIG_SND_USB_6FIRE_MODULE: u32 = 1;
pub const CONFIG_PERF_EVENTS_INTEL_UNCORE: u32 = 1;
pub const CONFIG_SND_HDA_HWDEP: u32 = 1;
pub const CONFIG_INPUT_AD714X_I2C_MODULE: u32 = 1;
pub const CONFIG_I2C_SIS96X_MODULE: u32 = 1;
pub const CONFIG_INET_RAW_DIAG_MODULE: u32 = 1;
pub const CONFIG_MMC_TIFM_SD_MODULE: u32 = 1;
pub const CONFIG_GFS2_FS_LOCKING_DLM: u32 = 1;
pub const CONFIG_MEDIA_TUNER_TDA18218_MODULE: u32 = 1;
pub const CONFIG_IP_NF_IPTABLES_MODULE: u32 = 1;
pub const CONFIG_ZPA2326_SPI_MODULE: u32 = 1;
pub const CONFIG_MISC_RTSX_USB_MODULE: u32 = 1;
pub const CONFIG_HISAX_HFC4S8S_MODULE: u32 = 1;
pub const CONFIG_VSOCKETS_MODULE: u32 = 1;
pub const CONFIG_GPIO_F7188X_MODULE: u32 = 1;
pub const CONFIG_BT_BNEP_PROTO_FILTER: u32 = 1;
pub const CONFIG_DYNAMIC_FTRACE_WITH_REGS: u32 = 1;
pub const CONFIG_NTB_SWITCHTEC_MODULE: u32 = 1;
pub const CONFIG_PCIE_PTM: u32 = 1;
pub const CONFIG_IWLWIFI_LEDS: u32 = 1;
pub const CONFIG_USB_CHIPIDEA_HOST: u32 = 1;
pub const CONFIG_MFD_RETU_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_QLOGIC: u32 = 1;
pub const CONFIG_SPI_GPIO_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_CPIA1_MODULE: u32 = 1;
pub const CONFIG_PARIDE_PF_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS42L42_MODULE: u32 = 1;
pub const CONFIG_HSI_CHAR_MODULE: u32 = 1;
pub const CONFIG_MPLS_IPTUNNEL_MODULE: u32 = 1;
pub const CONFIG_VIDEOBUF2_DMA_CONTIG_MODULE: u32 = 1;
pub const CONFIG_USB_XHCI_HCD: u32 = 1;
pub const CONFIG_VIRTIO: u32 = 1;
pub const CONFIG_HAVE_DMA_API_DEBUG: u32 = 1;
pub const CONFIG_REGULATOR_TPS65910_MODULE: u32 = 1;
pub const CONFIG_HISAX_16_3: u32 = 1;
pub const CONFIG_DEFAULT_CUBIC: u32 = 1;
pub const CONFIG_CAN_KVASER_PCI_MODULE: u32 = 1;
pub const CONFIG_YENTA_TI: u32 = 1;
pub const CONFIG_COMEDI_NI_660X_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS35L32_MODULE: u32 = 1;
pub const CONFIG_MFD_SM501_MODULE: u32 = 1;
pub const CONFIG_AD7606_MODULE: u32 = 1;
pub const CONFIG_HID_SAMSUNG_MODULE: u32 = 1;
pub const CONFIG_SPI_XCOMM_MODULE: u32 = 1;
pub const CONFIG_SFC_MCDI_LOGGING: u32 = 1;
pub const CONFIG_PARMAN_MODULE: u32 = 1;
pub const CONFIG_IP_SET_LIST_SET_MODULE: u32 = 1;
pub const CONFIG_TCM_IBLOCK_MODULE: u32 = 1;
pub const CONFIG_IP_PIMSM_V2: u32 = 1;
pub const CONFIG_BACKLIGHT_ARCXCNN_MODULE: u32 = 1;
pub const CONFIG_CFS_BANDWIDTH: u32 = 1;
pub const CONFIG_WM831X_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_TAG_TRAILER: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_CA0132_DSP: u32 = 1;
pub const CONFIG_XFRM_STATISTICS: u32 = 1;
pub const CONFIG_GPIO_GENERIC_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_X86_MCE_THRESHOLD: u32 = 1;
pub const CONFIG_MTD_SCB2_FLASH_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TW2804_MODULE: u32 = 1;
pub const CONFIG_VIA_RHINE_MMIO: u32 = 1;
pub const CONFIG_USB_ISIGHTFW_MODULE: u32 = 1;
pub const CONFIG_JME_MODULE: u32 = 1;
pub const CONFIG_USB_LINK_LAYER_TEST_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_CMEDIA_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_SAMPLE_MODULE: u32 = 1;
pub const CONFIG_NFC_TRF7970A_MODULE: u32 = 1;
pub const CONFIG_DMA_VIRTUAL_CHANNELS_MODULE: u32 = 1;
pub const CONFIG_SCSI_WD719X_MODULE: u32 = 1;
pub const CONFIG_DVB_PLATFORM_DRIVERS: u32 = 1;
pub const CONFIG_YENTA_O2: u32 = 1;
pub const CONFIG_GENERIC_MSI_IRQ_DOMAIN: u32 = 1;
pub const CONFIG_SND_SEQ_HRTIMER_DEFAULT: u32 = 1;
pub const CONFIG_USB_ARCH_HAS_HCD: u32 = 1;
pub const CONFIG_NFT_CHAIN_ROUTE_IPV6_MODULE: u32 = 1;
pub const CONFIG_DVB_DIB3000MC_MODULE: u32 = 1;
pub const CONFIG_STRICT_DEVMEM: u32 = 1;
pub const CONFIG_CACHEFILES_MODULE: u32 = 1;
pub const CONFIG_DVB_MXL5XX_MODULE: u32 = 1;
pub const CONFIG_PATA_OLDPIIX_MODULE: u32 = 1;
pub const CONFIG_I2C_KEMPLD_MODULE: u32 = 1;
pub const CONFIG_GENERIC_IRQ_SHOW: u32 = 1;
pub const CONFIG_TINYDRM_REPAPER_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_SI3054_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_PCF50633_MODULE: u32 = 1;
pub const CONFIG_LCD_ILI9320_MODULE: u32 = 1;
pub const CONFIG_MFD_MAX8925: u32 = 1;
pub const CONFIG_NFC_MICROREAD_I2C_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_ELF_RANDOMIZE: u32 = 1;
pub const CONFIG_9P_FS_MODULE: u32 = 1;
pub const CONFIG_MD_AUTODETECT: u32 = 1;
pub const CONFIG_ASUS_WIRELESS_MODULE: u32 = 1;
pub const CONFIG_AD7766_MODULE: u32 = 1;
pub const CONFIG_PANIC_ON_OOPS_VALUE: u32 = 0;
pub const CONFIG_JOYSTICK_A3D_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_SAMSUNG: u32 = 1;
pub const CONFIG_SND_SOC_CS4270_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ATK0110_MODULE: u32 = 1;
pub const CONFIG_IIO_MS_SENSORS_I2C_MODULE: u32 = 1;
pub const CONFIG_FB_VIA_X_COMPATIBILITY: u32 = 1;
pub const CONFIG_SFC_SRIOV: u32 = 1;
pub const CONFIG_SERIAL_SCCNXP: u32 = 1;
pub const CONFIG_TCP_CONG_HSTCP_MODULE: u32 = 1;
pub const CONFIG_BATTERY_BQ27XXX_I2C_MODULE: u32 = 1;
pub const CONFIG_SCSI_MOD: u32 = 1;
pub const CONFIG_SCSI_SMARTPQI_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_ATMEL_MXT_T37: u32 = 1;
pub const CONFIG_SND_SOC_SSM2602_MODULE: u32 = 1;
pub const CONFIG_SCSI_DPT_I2O_MODULE: u32 = 1;
pub const CONFIG_INPUT_88PM860X_ONKEY_MODULE: u32 = 1;
pub const CONFIG_I2C_CROS_EC_TUNNEL_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_MICREL: u32 = 1;
pub const CONFIG_AUDIT_TREE: u32 = 1;
pub const CONFIG_FB_PM2_MODULE: u32 = 1;
pub const CONFIG_GIGASET_M105_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_UPD161704_MODULE: u32 = 1;
pub const CONFIG_MPLS_ROUTING_MODULE: u32 = 1;
pub const CONFIG_F2FS_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_FWTTY_MAX_TOTAL_PORTS: u32 = 64;
pub const CONFIG_VIDEOBUF2_DMA_SG_MODULE: u32 = 1;
pub const CONFIG_HISAX_HFC_PCI: u32 = 1;
pub const CONFIG_ARCH_HAS_ADD_PAGES: u32 = 1;
pub const CONFIG_JOYSTICK_ZHENHUA_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_AURORA: u32 = 1;
pub const CONFIG_USB_SERIAL_SPCP8X5_MODULE: u32 = 1;
pub const CONFIG_WILC1000_SDIO_MODULE: u32 = 1;
pub const CONFIG_MAX5481_MODULE: u32 = 1;
pub const CONFIG_HID_ITE_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AK5386_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_CYTTSP4_I2C_MODULE: u32 = 1;
pub const CONFIG_HID_SENSOR_PROX_MODULE: u32 = 1;
pub const CONFIG_RC_DECODERS: u32 = 1;
pub const CONFIG_B43_LEDS: u32 = 1;
pub const CONFIG_P54_USB_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_MK712_MODULE: u32 = 1;
pub const CONFIG_FB_ATY_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_CYTTSP4_CORE_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_KINECT_MODULE: u32 = 1;
pub const CONFIG_NET_9P_XEN_MODULE: u32 = 1;
pub const CONFIG_SPEAKUP_SYNTH_DECEXT_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_WISHBONE_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DAQBOARD2000_MODULE: u32 = 1;
pub const CONFIG_TPS68470_PMIC_OPREGION: u32 = 1;
pub const CONFIG_LEDS_CLASS_FLASH_MODULE: u32 = 1;
pub const CONFIG_USB_NET_HUAWEI_CDC_NCM_MODULE: u32 = 1;
pub const CONFIG_OPROFILE_MODULE: u32 = 1;
pub const CONFIG_SCSI_ESAS2R_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX25821_ALSA_MODULE: u32 = 1;
pub const CONFIG_GPIO_PISOSR_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CRC32C: u32 = 1;
pub const CONFIG_SERIAL_CORE: u32 = 1;
pub const CONFIG_IIO_ST_SENSORS_I2C_MODULE: u32 = 1;
pub const CONFIG_LOCK_DOWN_KERNEL: u32 = 1;
pub const CONFIG_FUSE_FS: u32 = 1;
pub const CONFIG_HID_SENSOR_HUMIDITY_MODULE: u32 = 1;
pub const CONFIG_BUILDTIME_EXTABLE_SORT: u32 = 1;
pub const CONFIG_USB_CONFIGFS_SERIAL: u32 = 1;
pub const CONFIG_UID16: u32 = 1;
pub const CONFIG_DW_DMAC_MODULE: u32 = 1;
pub const CONFIG_ETHOC_MODULE: u32 = 1;
pub const CONFIG_INTEL_RDT: u32 = 1;
pub const CONFIG_SND_SOC_PCM512x_MODULE: u32 = 1;
pub const CONFIG_ACPI_HED: u32 = 1;
pub const CONFIG_HAVE_DEBUG_STACKOVERFLOW: u32 = 1;
pub const CONFIG_HID_MICROSOFT_MODULE: u32 = 1;
pub const CONFIG_RTLLIB_MODULE: u32 = 1;
pub const CONFIG_LIVEPATCH: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_BYT_CHT_ES8316_MACH_MODULE: u32 = 1;
pub const CONFIG_ARCH_PHYS_ADDR_T_64BIT: u32 = 1;
pub const CONFIG_PCC: u32 = 1;
pub const CONFIG_RTC_DRV_S35390A_MODULE: u32 = 1;
pub const CONFIG_HAVE_KRETPROBES: u32 = 1;
pub const CONFIG_SYSTEM_EXTRA_CERTIFICATE_SIZE: u32 = 4096;
pub const CONFIG_HYPERV_BALLOON_MODULE: u32 = 1;
pub const CONFIG_SCSI_IMM_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LM25066_MODULE: u32 = 1;
pub const CONFIG_ASSOCIATIVE_ARRAY: u32 = 1;
pub const CONFIG_USB_CONFIGFS_F_UVC: u32 = 1;
pub const CONFIG_HSA_AMD_MODULE: u32 = 1;
pub const CONFIG_AGP_VIA: u32 = 1;
pub const CONFIG_NF_DEFRAG_IPV6_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_CONEX_MODULE: u32 = 1;
pub const CONFIG_MICREL_PHY_MODULE: u32 = 1;
pub const CONFIG_DRM_LOAD_EDID_FIRMWARE: u32 = 1;
pub const CONFIG_VIDEO_DEV_MODULE: u32 = 1;
pub const CONFIG_KS0108_MODULE: u32 = 1;
pub const CONFIG_SGI_IOC4_MODULE: u32 = 1;
pub const CONFIG_NFS_V4_MODULE: u32 = 1;
pub const CONFIG_MFD_WM831X: u32 = 1;
pub const CONFIG_PMIC_ADP5520: u32 = 1;
pub const CONFIG_RPMSG_QCOM_GLINK_RPM_MODULE: u32 = 1;
pub const CONFIG_IRCOMM_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_TPS80031_MODULE: u32 = 1;
pub const CONFIG_PPP_FILTER: u32 = 1;
pub const CONFIG_DYNAMIC_FTRACE: u32 = 1;
pub const CONFIG_MAILBOX: u32 = 1;
pub const CONFIG_VIDEO_MT9M111_MODULE: u32 = 1;
pub const CONFIG_INPUT_LEDS_MODULE: u32 = 1;
pub const CONFIG_RCU_NEED_SEGCBLIST: u32 = 1;
pub const CONFIG_MTD_SLRAM_MODULE: u32 = 1;
pub const CONFIG_INLINE_READ_UNLOCK: u32 = 1;
pub const CONFIG_DEBUG_WX: u32 = 1;
pub const CONFIG_MTD_ROM_MODULE: u32 = 1;
pub const CONFIG_PATA_PDC2027X_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LTC2978_MODULE: u32 = 1;
pub const CONFIG_HAS_DMA: u32 = 1;
pub const CONFIG_INTEL_IPS_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS43130_MODULE: u32 = 1;
pub const CONFIG_NF_CT_PROTO_SCTP: u32 = 1;
pub const CONFIG_EDAC: u32 = 1;
pub const CONFIG_USB_SERIAL_VISOR_MODULE: u32 = 1;
pub const CONFIG_MTD_PMC551_MODULE: u32 = 1;
pub const CONFIG_BROADCOM_PHY_MODULE: u32 = 1;
pub const CONFIG_COMEDI_PCMUIO_MODULE: u32 = 1;
pub const CONFIG_DVB_AS102_FE_MODULE: u32 = 1;
pub const CONFIG_IO_DELAY_TYPE_NONE: u32 = 3;
pub const CONFIG_SND_SOC_CS42XX8_I2C_MODULE: u32 = 1;
pub const CONFIG_SCSI: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_PANIC: u32 = 1;
pub const CONFIG_DVB_CXD2841ER_MODULE: u32 = 1;
pub const CONFIG_GENWQE_PLATFORM_ERROR_RECOVERY: u32 = 0;
pub const CONFIG_FB_CFB_FILLRECT: u32 = 1;
pub const CONFIG_RT2800_LIB_MMIO_MODULE: u32 = 1;
pub const CONFIG_HYPERV_MODULE: u32 = 1;
pub const CONFIG_AT76C50X_USB_MODULE: u32 = 1;
pub const CONFIG_QCOM_SPMI_IADC_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_WM8994_MODULE: u32 = 1;
pub const CONFIG_FUNCTION_GRAPH_TRACER: u32 = 1;
pub const CONFIG_NF_NAT_PPTP_MODULE: u32 = 1;
pub const CONFIG_HID_CHICONY_MODULE: u32 = 1;
pub const CONFIG_NLS_MAC_ROMAN_MODULE: u32 = 1;
pub const CONFIG_HID_MODULE: u32 = 1;
pub const CONFIG_HW_RANDOM_AMD_MODULE: u32 = 1;
pub const CONFIG_SND_SST_IPC_MODULE: u32 = 1;
pub const CONFIG_AUFS_XATTR: u32 = 1;
pub const CONFIG_VIDEO_VIVID_MODULE: u32 = 1;
pub const CONFIG_RMI4_SMB_MODULE: u32 = 1;
pub const CONFIG_LIBERTAS_THINFIRM_USB_MODULE: u32 = 1;
pub const CONFIG_AMD_XGBE_MODULE: u32 = 1;
pub const CONFIG_CGROUP_NET_PRIO: u32 = 1;
pub const CONFIG_RANDOMIZE_BASE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_F_UAC1: u32 = 1;
pub const CONFIG_USB_DWC3_DUAL_ROLE: u32 = 1;
pub const CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_BXT_DA7219_MAX98357A_MACH_MODULE: u32 = 1;
pub const CONFIG_PWM_TWL_LED_MODULE: u32 = 1;
pub const CONFIG_SLIP_SMART: u32 = 1;
pub const CONFIG_IXGB_MODULE: u32 = 1;
pub const CONFIG_NLS_ISO8859_9_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_ZFORCE_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_BPF_MODULE: u32 = 1;
pub const CONFIG_FIRMWARE_EDID: u32 = 1;
pub const CONFIG_SND_SERIAL_U16550_MODULE: u32 = 1;
pub const CONFIG_AMD_IOMMU_V2_MODULE: u32 = 1;
pub const CONFIG_USB_ARMLINUX: u32 = 1;
pub const CONFIG_I2C_SMBUS_MODULE: u32 = 1;
pub const CONFIG_IP_VS_PE_SIP_MODULE: u32 = 1;
pub const CONFIG_MEMSTICK_REALTEK_USB_MODULE: u32 = 1;
pub const CONFIG_PLATFORM_SI4713_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_GF2K_MODULE: u32 = 1;
pub const CONFIG_RTLWIFI_MODULE: u32 = 1;
pub const CONFIG_TCG_TIS_ST33ZP24_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_BXT_RT298_MACH_MODULE: u32 = 1;
pub const CONFIG_LP8788_ADC_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_MEN_MCB_MODULE: u32 = 1;
pub const CONFIG_EDAC_GHES: u32 = 1;
pub const CONFIG_CLKDEV_LOOKUP: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_DEFAULT_ON_MODULE: u32 = 1;
pub const CONFIG_MXM_WMI_MODULE: u32 = 1;
pub const CONFIG_FONT_8x16: u32 = 1;
pub const CONFIG_PSTORE_ZLIB_COMPRESS: u32 = 1;
pub const CONFIG_NET_VENDOR_MELLANOX: u32 = 1;
pub const CONFIG_SERIAL_8250_MOXA_MODULE: u32 = 1;
pub const CONFIG_MAC80211_HWSIM_MODULE: u32 = 1;
pub const CONFIG_DVB_LGDT330X_MODULE: u32 = 1;
pub const CONFIG_INTEL_MIC_X100_DMA_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_MANY_PORTS: u32 = 1;
pub const CONFIG_VT_CONSOLE_SLEEP: u32 = 1;
pub const CONFIG_LIBFC_MODULE: u32 = 1;
pub const CONFIG_X86_MCE_INTEL: u32 = 1;
pub const CONFIG_X86_64: u32 = 1;
pub const CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG: u32 = 1;
pub const CONFIG_RTC_DRV_CMOS: u32 = 1;
pub const CONFIG_CRYPTO_USER_API_AEAD_MODULE: u32 = 1;
pub const CONFIG_PCI_LOCKLESS_CONFIG: u32 = 1;
pub const CONFIG_PTP_1588_CLOCK_MODULE: u32 = 1;
pub const CONFIG_NF_DUP_NETDEV_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_MAX98927_MODULE: u32 = 1;
pub const CONFIG_IEEE802154_DRIVERS_MODULE: u32 = 1;
pub const CONFIG_ADFS_FS_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_RV3029_HWMON: u32 = 1;
pub const CONFIG_TCP_CONG_BBR_MODULE: u32 = 1;
pub const CONFIG_LNET_MAX_PAYLOAD: u32 = 1048576;
pub const CONFIG_TOUCHSCREEN_USB_IRTOUCH: u32 = 1;
pub const CONFIG_PATA_AMD_MODULE: u32 = 1;
pub const CONFIG_USB_PWC_MODULE: u32 = 1;
pub const CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE: u32 = 3;
pub const CONFIG_SENSORS_AD7414_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_TDA8290_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADV_PCI_DIO_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_PANJIT: u32 = 1;
pub const CONFIG_RT2800PCI_RT53XX: u32 = 1;
pub const CONFIG_BONDING_MODULE: u32 = 1;
pub const CONFIG_SECURITY_TOMOYO_ACTIVATION_TRIGGER: &'static [u8; 11usize] = b"/sbin/init\0";
pub const CONFIG_HTS221_I2C_MODULE: u32 = 1;
pub const CONFIG_MLXSW_SPECTRUM_DCB: u32 = 1;
pub const CONFIG_MEDIA_TUNER_TDA18212_MODULE: u32 = 1;
pub const CONFIG_MCP3422_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_EM3027_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_CACHE_LINE_SIZE: u32 = 1;
pub const CONFIG_6LOWPAN_NHC_DEST_MODULE: u32 = 1;
pub const CONFIG_VEML6070_MODULE: u32 = 1;
pub const CONFIG_VIDEO_SAA7134_RC: u32 = 1;
pub const CONFIG_JBD2: u32 = 1;
pub const CONFIG_COMEDI_AMPLC_PC236_PCI_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ASB100_MODULE: u32 = 1;
pub const CONFIG_SND_INTEL8X0_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_ATMIO_MODULE: u32 = 1;
pub const CONFIG_PATA_NS87415_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ADAU1761_MODULE: u32 = 1;
pub const CONFIG_USBIP_CORE_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DAC02_MODULE: u32 = 1;
pub const CONFIG_ATH10K_TRACING: u32 = 1;
pub const CONFIG_ATM_BR2684_MODULE: u32 = 1;
pub const CONFIG_SPARSEMEM_VMEMMAP: u32 = 1;
pub const CONFIG_CRYPTO_CAMELLIA_X86_64_MODULE: u32 = 1;
pub const CONFIG_IB700_WDT_MODULE: u32 = 1;
pub const CONFIG_MMC_USHC_MODULE: u32 = 1;
pub const CONFIG_COMEDI_CB_PCIDAS64_MODULE: u32 = 1;
pub const CONFIG_SPI_TLE62X0_MODULE: u32 = 1;
pub const CONFIG_INET6_IPCOMP_MODULE: u32 = 1;
pub const CONFIG_SONY_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_QLCNIC_MODULE: u32 = 1;
pub const CONFIG_FB_SIS_315: u32 = 1;
pub const CONFIG_TPS6507X_MODULE: u32 = 1;
pub const CONFIG_IRDA_FAST_RR: u32 = 1;
pub const CONFIG_HISAX_W6692: u32 = 1;
pub const CONFIG_NET_VENDOR_MARVELL: u32 = 1;
pub const CONFIG_PHYLIB: u32 = 1;
pub const CONFIG_IGB_DCA: u32 = 1;
pub const CONFIG_NFP_APP_FLOWER: u32 = 1;
pub const CONFIG_SENSORS_IBM_CFFPS_MODULE: u32 = 1;
pub const CONFIG_CIFS_SMB311: u32 = 1;
pub const CONFIG_CRYPTO_SHA1_SSSE3_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_GPIO_MODULE: u32 = 1;
pub const CONFIG_IPV6_TUNNEL_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LM77_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2760_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_NVIDIA: u32 = 1;
pub const CONFIG_ARCH_MEMORY_PROBE: u32 = 1;
pub const CONFIG_X86_AMD_FREQ_SENSITIVITY_MODULE: u32 = 1;
pub const CONFIG_DVB_TDA665x_MODULE: u32 = 1;
pub const CONFIG_HAVE_GENERIC_GUP: u32 = 1;
pub const CONFIG_VIDEO_SAA7164_MODULE: u32 = 1;
pub const CONFIG_NFC_MRVL_USB_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_874_MODULE: u32 = 1;
pub const CONFIG_FB_CMDLINE: u32 = 1;
pub const CONFIG_OPTIMIZE_INLINING: u32 = 1;
pub const CONFIG_LOCK_DOWN_IN_EFI_SECURE_BOOT: u32 = 1;
pub const CONFIG_ULTRIX_PARTITION: u32 = 1;
pub const CONFIG_IRQ_DOMAIN: u32 = 1;
pub const CONFIG_NET_DSA_MODULE: u32 = 1;
pub const CONFIG_VIRTIO_BALLOON: u32 = 1;
pub const CONFIG_HOTPLUG_PCI_CPCI_GENERIC_MODULE: u32 = 1;
pub const CONFIG_IMA: u32 = 1;
pub const CONFIG_LSM_MMAP_MIN_ADDR: u32 = 0;
pub const CONFIG_SCSI_ARCMSR_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_AMD: u32 = 1;
pub const CONFIG_INTEGRITY_AUDIT: u32 = 1;
pub const CONFIG_COMEDI_AMPLC_DIO200_MODULE: u32 = 1;
pub const CONFIG_PVPANIC_MODULE: u32 = 1;
pub const CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADDRESS: u32 = 0;
pub const CONFIG_CAN_PEAK_PCI_MODULE: u32 = 1;
pub const CONFIG_PPS_CLIENT_LDISC_MODULE: u32 = 1;
pub const CONFIG_BLK_CMDLINE_PARSER: u32 = 1;
pub const CONFIG_ARCH_HAS_DEBUG_VIRTUAL: u32 = 1;
pub const CONFIG_MTD_ONENAND_2X_PROGRAM: u32 = 1;
pub const CONFIG_MEDIA_TUNER_MT20XX_MODULE: u32 = 1;
pub const CONFIG_NET_TULIP: u32 = 1;
pub const CONFIG_IIO_HRTIMER_TRIGGER_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_SP_CCP: u32 = 1;
pub const CONFIG_JFFS2_RTIME: u32 = 1;
pub const CONFIG_ZX_TDM_MODULE: u32 = 1;
pub const CONFIG_IPC_NS: u32 = 1;
pub const CONFIG_CRYPTO_GLUE_HELPER_X86_MODULE: u32 = 1;
pub const CONFIG_DEVFREQ_GOV_PASSIVE: u32 = 1;
pub const CONFIG_HISAX_FRITZ_PCIPNP_MODULE: u32 = 1;
pub const CONFIG_DVB_HORUS3A_MODULE: u32 = 1;
pub const CONFIG_RMI4_F34: u32 = 1;
pub const CONFIG_MISC_FILESYSTEMS: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_BITS_MIN: u32 = 28;
pub const CONFIG_FTRACE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CONNLIMIT_MODULE: u32 = 1;
pub const CONFIG_ATP_MODULE: u32 = 1;
pub const CONFIG_X86_THERMAL_VECTOR: u32 = 1;
pub const CONFIG_IP_NF_SECURITY_MODULE: u32 = 1;
pub const CONFIG_IP_NF_RAW_MODULE: u32 = 1;
pub const CONFIG_HAVE_CC_STACKPROTECTOR: u32 = 1;
pub const CONFIG_IP_NF_ARPFILTER_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_LP8788_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_ETT_TC45USB: u32 = 1;
pub const CONFIG_COMPAT_32: u32 = 1;
pub const CONFIG_W1_CON: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_SOCKET_MODULE: u32 = 1;
pub const CONFIG_HYPERV_TSCPAGE: u32 = 1;
pub const CONFIG_FB_ASILIANT: u32 = 1;
pub const CONFIG_PPPOL2TP_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_TLS8204_MODULE: u32 = 1;
pub const CONFIG_SYNCLINK_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_ADP5588_MODULE: u32 = 1;
pub const CONFIG_CLOCKSOURCE_WATCHDOG: u32 = 1;
pub const CONFIG_R8712U_MODULE: u32 = 1;
pub const CONFIG_HID_TOPSEED_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_RC5T583_MODULE: u32 = 1;
pub const CONFIG_B43_PHY_HT: u32 = 1;
pub const CONFIG_FB_VT8623_MODULE: u32 = 1;
pub const CONFIG_HISAX_MAX_CARDS: u32 = 8;
pub const CONFIG_AD7606_IFACE_SPI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_KBL_RT5663_RT5514_MAX98927_MACH_MODULE: u32 = 1;
pub const CONFIG_LEDS_DA9052_MODULE: u32 = 1;
pub const CONFIG_LEDS_BRIGHTNESS_HW_CHANGED: u32 = 1;
pub const CONFIG_DECOMPRESS_BZIP2: u32 = 1;
pub const CONFIG_RT2800PCI_RT33XX: u32 = 1;
pub const CONFIG_CORDIC_MODULE: u32 = 1;
pub const CONFIG_ATH9K_RFKILL: u32 = 1;
pub const CONFIG_COMEDI_CB_PCIDAS_MODULE: u32 = 1;
pub const CONFIG_FB_TRIDENT_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_AXP20X_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ADM1029_MODULE: u32 = 1;
pub const CONFIG_IIO_ST_SENSORS_CORE_MODULE: u32 = 1;
pub const CONFIG_KSM: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_UPROBES: u32 = 1;
pub const CONFIG_EXPORTFS_BLOCK_OPS: u32 = 1;
pub const CONFIG_DRM_DP_AUX_CHARDEV: u32 = 1;
pub const CONFIG_NET_VENDOR_STMICRO: u32 = 1;
pub const CONFIG_EDAC_I3000_MODULE: u32 = 1;
pub const CONFIG_PARPORT_PC_FIFO: u32 = 1;
pub const CONFIG_DECNET_MODULE: u32 = 1;
pub const CONFIG_TOPSTAR_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_AGP_SIS_MODULE: u32 = 1;
pub const CONFIG_NF_NAT_H323_MODULE: u32 = 1;
pub const CONFIG_XZ_DEC_SPARC: u32 = 1;
pub const CONFIG_IMA_LSM_RULES: u32 = 1;
pub const CONFIG_JOYSTICK_TURBOGRAFX_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SKYLAKE_MODULE: u32 = 1;
pub const CONFIG_ARCH_SPARSEMEM_DEFAULT: u32 = 1;
pub const CONFIG_MLXSW_PCI_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DMM32AT_MODULE: u32 = 1;
pub const CONFIG_MOST_MODULE: u32 = 1;
pub const CONFIG_USB_NET_QMI_WWAN_MODULE: u32 = 1;
pub const CONFIG_NET_TEAM_MODE_ROUNDROBIN_MODULE: u32 = 1;
pub const CONFIG_BOARD_TPCI200_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_RT5033_MODULE: u32 = 1;
pub const CONFIG_INPUT_CMA3000_MODULE: u32 = 1;
pub const CONFIG_EDAC_IE31200_MODULE: u32 = 1;
pub const CONFIG_IR_ENE_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_S6D1121_MODULE: u32 = 1;
pub const CONFIG_ALIM1535_WDT_MODULE: u32 = 1;
pub const CONFIG_GIGASET_BASE_MODULE: u32 = 1;
pub const CONFIG_INLINE_READ_UNLOCK_IRQ: u32 = 1;
pub const CONFIG_HID_HYPERV_MOUSE_MODULE: u32 = 1;
pub const CONFIG_GACT_PROB: u32 = 1;
pub const CONFIG_MISDN_ISAR_MODULE: u32 = 1;
pub const CONFIG_REALTEK_PHY_MODULE: u32 = 1;
pub const CONFIG_PROC_VMCORE: u32 = 1;
pub const CONFIG_HID_A4TECH_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_MC44S803_MODULE: u32 = 1;
pub const CONFIG_RTC_MC146818_LIB: u32 = 1;
pub const CONFIG_KMX61_MODULE: u32 = 1;
pub const CONFIG_NFC_PN544_MEI_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_QCA: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_860_MODULE: u32 = 1;
pub const CONFIG_INTEL_MEI_WDT_MODULE: u32 = 1;
pub const CONFIG_GPIO_TPIC2810_MODULE: u32 = 1;
pub const CONFIG_AD799X_MODULE: u32 = 1;
pub const CONFIG_SND_MONA_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_ESP_MODULE: u32 = 1;
pub const CONFIG_NIU_MODULE: u32 = 1;
pub const CONFIG_AD8366_MODULE: u32 = 1;
pub const CONFIG_MOUSE_PS2_VMMOUSE: u32 = 1;
pub const CONFIG_IP_NF_TARGET_NETMAP_MODULE: u32 = 1;
pub const CONFIG_DST_CACHE: u32 = 1;
pub const CONFIG_USB_GSPCA_SPCA505_MODULE: u32 = 1;
pub const CONFIG_NF_REJECT_IPV6_MODULE: u32 = 1;
pub const CONFIG_RCU_CPU_STALL_TIMEOUT: u32 = 60;
pub const CONFIG_BACKLIGHT_ADP5520_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_SQ905C_MODULE: u32 = 1;
pub const CONFIG_842_COMPRESS_MODULE: u32 = 1;
pub const CONFIG_SATA_VITESSE_MODULE: u32 = 1;
pub const CONFIG_USB_ZR364XX_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_MV88E6XXX_MODULE: u32 = 1;
pub const CONFIG_CHECKPOINT_RESTORE: u32 = 1;
pub const CONFIG_PRINTER_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_ISL1208_MODULE: u32 = 1;
pub const CONFIG_RTLPHYDM_ST_MODULE: u32 = 1;
pub const CONFIG_MFD_MENF21BMC_MODULE: u32 = 1;
pub const CONFIG_ISDN_DIVAS_DIVACAPI_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS4265_MODULE: u32 = 1;
pub const CONFIG_SND_VERBOSE_PROCFS: u32 = 1;
pub const CONFIG_SENSORS_HMC5843_SPI_MODULE: u32 = 1;
pub const CONFIG_SND_FIREWIRE_LIB_MODULE: u32 = 1;
pub const CONFIG_INT340X_THERMAL_MODULE: u32 = 1;
pub const CONFIG_DA9052_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_CFG80211_DEBUGFS: u32 = 1;
pub const CONFIG_TYPEC_TPS6598X_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_BCM: u32 = 1;
pub const CONFIG_HAVE_ARCH_COMPAT_MMAP_BASES: u32 = 1;
pub const CONFIG_MAX9611_MODULE: u32 = 1;
pub const CONFIG_LAPB_MODULE: u32 = 1;
pub const CONFIG_IIO_ST_GYRO_3AXIS_MODULE: u32 = 1;
pub const CONFIG_SECURITY_TOMOYO_MAX_ACCEPT_ENTRY: u32 = 2048;
pub const CONFIG_IP_ROUTE_MULTIPATH: u32 = 1;
pub const CONFIG_AM2315_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_PCF2123_MODULE: u32 = 1;
pub const CONFIG_ISDN_DIVAS_USERIDI_MODULE: u32 = 1;
pub const CONFIG_INTEL_MIC_CARD_MODULE: u32 = 1;
pub const CONFIG_DVB_LNBP21_MODULE: u32 = 1;
pub const CONFIG_XEN_NETDEV_FRONTEND: u32 = 1;
pub const CONFIG_DVB_TDA10048_MODULE: u32 = 1;
pub const CONFIG_INPUT_FF_MEMLESS_MODULE: u32 = 1;
pub const CONFIG_PARAVIRT_CLOCK: u32 = 1;
pub const CONFIG_SND_SOC_FSL_SAI_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_F_PRINTER: u32 = 1;
pub const CONFIG_SENSORS_W83627HF_MODULE: u32 = 1;
pub const CONFIG_CHR_DEV_SG: u32 = 1;
pub const CONFIG_USB_CDC_PHONET_MODULE: u32 = 1;
pub const CONFIG_IP_SET_HASH_NET_MODULE: u32 = 1;
pub const CONFIG_SECTION_MISMATCH_WARN_ONLY: u32 = 1;
pub const CONFIG_NET_SCH_DSMARK_MODULE: u32 = 1;
pub const CONFIG_SND_AD1889_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_SMSC_LAN9303_MDIO_MODULE: u32 = 1;
pub const CONFIG_MISC_RTSX_MODULE: u32 = 1;
pub const CONFIG_SSB_DRIVER_PCICORE_POSSIBLE: u32 = 1;
pub const CONFIG_MISDN_AVMFRITZ_MODULE: u32 = 1;
pub const CONFIG_MDIO_DEVICE: u32 = 1;
pub const CONFIG_X86_RESERVE_LOW: u32 = 64;
pub const CONFIG_SMS_SDIO_DRV_MODULE: u32 = 1;
pub const CONFIG_NFSD_PNFS: u32 = 1;
pub const CONFIG_NEED_SG_DMA_LENGTH: u32 = 1;
pub const CONFIG_INPUT_AXP20X_PEK_MODULE: u32 = 1;
pub const CONFIG_SND_MPU401_MODULE: u32 = 1;
pub const CONFIG_DVB_CX24116_MODULE: u32 = 1;
pub const CONFIG_POWER_RESET: u32 = 1;
pub const CONFIG_CRYPTO_XCBC_MODULE: u32 = 1;
pub const CONFIG_NF_NAT_AMANDA_MODULE: u32 = 1;
pub const CONFIG_IPW2200_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_EBT_MARK_MODULE: u32 = 1;
pub const CONFIG_NFT_SET_RBTREE_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_QT2160_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ADT7411_MODULE: u32 = 1;
pub const CONFIG_IXGBE_DCA: u32 = 1;
pub const CONFIG_IP6_NF_MATCH_IPV6HEADER_MODULE: u32 = 1;
pub const CONFIG_MACVLAN_MODULE: u32 = 1;
pub const CONFIG_FWTTY_MAX_CARD_PORTS: u32 = 32;
pub const CONFIG_TPS6105X_MODULE: u32 = 1;
pub const CONFIG_TI_ADC084S021_MODULE: u32 = 1;
pub const CONFIG_PATA_PDC_OLD_MODULE: u32 = 1;
pub const CONFIG_L2TP_V3: u32 = 1;
pub const CONFIG_I2C_MUX_REG_MODULE: u32 = 1;
pub const CONFIG_RTL8723_COMMON_MODULE: u32 = 1;
pub const CONFIG_CHELSIO_T1_1G: u32 = 1;
pub const CONFIG_BPF_JIT: u32 = 1;
pub const CONFIG_INV_MPU6050_I2C_MODULE: u32 = 1;
pub const CONFIG_IIO_INTERRUPT_TRIGGER_MODULE: u32 = 1;
pub const CONFIG_SENSORS_INA2XX_MODULE: u32 = 1;
pub const CONFIG_WLCORE_SDIO_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SHA512_MB_MODULE: u32 = 1;
pub const CONFIG_FB_ARK_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_IFORCE_MODULE: u32 = 1;
pub const CONFIG_PCIEASPM_DEFAULT: u32 = 1;
pub const CONFIG_SND_SOC_WM8524_MODULE: u32 = 1;
pub const CONFIG_PROFILING: u32 = 1;
pub const CONFIG_PCF50633_ADC_MODULE: u32 = 1;
pub const CONFIG_INTERVAL_TREE: u32 = 1;
pub const CONFIG_FB_TFT_ST7735R_MODULE: u32 = 1;
pub const CONFIG_ARCNET_MODULE: u32 = 1;
pub const CONFIG_MLX_CPLD_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8731_MODULE: u32 = 1;
pub const CONFIG_IOSF_MBI: u32 = 1;
pub const CONFIG_I2C_ALI15X3_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX31785_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_AMAZON: u32 = 1;
pub const CONFIG_SPARSEMEM: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2805_MODULE: u32 = 1;
pub const CONFIG_INET6_XFRM_MODE_TRANSPORT_MODULE: u32 = 1;
pub const CONFIG_LEDS_LP5523_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_FAN53555_MODULE: u32 = 1;
pub const CONFIG_NVME_FC_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADDI_APCI_2032_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_ARC4_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_DA9210_MODULE: u32 = 1;
pub const CONFIG_HD44780_MODULE: u32 = 1;
pub const CONFIG_INPUT_REGULATOR_HAPTIC_MODULE: u32 = 1;
pub const CONFIG_CAN_MCBA_USB_MODULE: u32 = 1;
pub const CONFIG_IEEE802154_6LOWPAN_MODULE: u32 = 1;
pub const CONFIG_VHOST_NET_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TEA6415C_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ATMEL: u32 = 1;
pub const CONFIG_SENSORS_ASPEED_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AMD_CZ_RT5645_MACH_MODULE: u32 = 1;
pub const CONFIG_DVB_STV0900_MODULE: u32 = 1;
pub const CONFIG_I2C_NFORCE2_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_DIGI_ACCELEPORT_MODULE: u32 = 1;
pub const CONFIG_USB_GL860_MODULE: u32 = 1;
pub const CONFIG_GRACE_PERIOD_MODULE: u32 = 1;
pub const CONFIG_SLHC: u32 = 1;
pub const CONFIG_R8188EU_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_TEHUTI: u32 = 1;
pub const CONFIG_QED_RDMA: u32 = 1;
pub const CONFIG_REGULATOR_LTC3589_MODULE: u32 = 1;
pub const CONFIG_SCSI_UFSHCD_PCI_MODULE: u32 = 1;
pub const CONFIG_SND_ALS300_MODULE: u32 = 1;
pub const CONFIG_ADT7316_I2C_MODULE: u32 = 1;
pub const CONFIG_ALTERA_TSE_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_GPIO_POLLED_MODULE: u32 = 1;
pub const CONFIG_E1000E_HWTS: u32 = 1;
pub const CONFIG_CRYPTO_MANAGER: u32 = 1;
pub const CONFIG_PHY_SAMSUNG_USB2_MODULE: u32 = 1;
pub const CONFIG_INTEL_MEI_TXE_MODULE: u32 = 1;
pub const CONFIG_SCSI_IPR_TRACE: u32 = 1;
pub const CONFIG_NET_SCH_HTB_MODULE: u32 = 1;
pub const CONFIG_EEPROM_AT24_MODULE: u32 = 1;
pub const CONFIG_UIO_SERCOS3_MODULE: u32 = 1;
pub const CONFIG_HID_CP2112_MODULE: u32 = 1;
pub const CONFIG_HOSTAP_FIRMWARE_NVRAM: u32 = 1;
pub const CONFIG_PPP_BSDCOMP_MODULE: u32 = 1;
pub const CONFIG_SCHED_SMT: u32 = 1;
pub const CONFIG_DVB_USB_TTUSB2_MODULE: u32 = 1;
pub const CONFIG_MTD_NAND_MODULE: u32 = 1;
pub const CONFIG_EDAC_SUPPORT: u32 = 1;
pub const CONFIG_CIFS_STATS: u32 = 1;
pub const CONFIG_RT_MUTEXES: u32 = 1;
pub const CONFIG_LOCK_SPIN_ON_OWNER: u32 = 1;
pub const CONFIG_REGULATOR_LTC3676_MODULE: u32 = 1;
pub const CONFIG_WLCORE_MODULE: u32 = 1;
pub const CONFIG_HID_ORTEK_MODULE: u32 = 1;
pub const CONFIG_VIDEO_V4L2_TPG_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_MARK_MODULE: u32 = 1;
pub const CONFIG_HID_ASUS_MODULE: u32 = 1;
pub const CONFIG_DRM_GEM_CMA_HELPER: u32 = 1;
pub const CONFIG_AR5523_MODULE: u32 = 1;
pub const CONFIG_DEVICE_PRIVATE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_MXL5007T_MODULE: u32 = 1;
pub const CONFIG_CX_ECAT_MODULE: u32 = 1;
pub const CONFIG_DRM_I2C_SIL164_MODULE: u32 = 1;
pub const CONFIG_MD_LINEAR_MODULE: u32 = 1;
pub const CONFIG_SATA_INIC162X_MODULE: u32 = 1;
pub const CONFIG_HUGETLBFS: u32 = 1;
pub const CONFIG_CHECK_SIGNATURE: u32 = 1;
pub const CONFIG_DVB_TDA10021_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX231XX_DVB_MODULE: u32 = 1;
pub const CONFIG_SLAB_MERGE_DEFAULT: u32 = 1;
pub const CONFIG_KERNFS: u32 = 1;
pub const CONFIG_X86_INTEL_MPX: u32 = 1;
pub const CONFIG_WL1251_MODULE: u32 = 1;
pub const CONFIG_I2C_ALGOBIT_MODULE: u32 = 1;
pub const CONFIG_IPV6_SUBTREES: u32 = 1;
pub const CONFIG_MMC_BLOCK_MODULE: u32 = 1;
pub const CONFIG_BATTERY_AXP20X_MODULE: u32 = 1;
pub const CONFIG_NET_CLS_FW_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_CCP: u32 = 1;
pub const CONFIG_KVM_MODULE: u32 = 1;
pub const CONFIG_PAGE_COUNTER: u32 = 1;
pub const CONFIG_KEYBOARD_DLINK_DIR685_MODULE: u32 = 1;
pub const CONFIG_SND_SIMPLE_CARD_MODULE: u32 = 1;
pub const CONFIG_ABX500_CORE: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2781_MODULE: u32 = 1;
pub const CONFIG_VIDEO_SAA7185_MODULE: u32 = 1;
pub const CONFIG_SND_PCI: u32 = 1;
pub const CONFIG_VIDEO_SAA7134_DVB_MODULE: u32 = 1;
pub const CONFIG_ATM_FORE200E_DEBUG: u32 = 0;
pub const CONFIG_EXPERT: u32 = 1;
pub const CONFIG_TOUCHSCREEN_PCAP_MODULE: u32 = 1;
pub const CONFIG_ISDN_DRV_HISAX_MODULE: u32 = 1;
pub const CONFIG_DVB_NETUP_UNIDVB_MODULE: u32 = 1;
pub const CONFIG_ATL1C_MODULE: u32 = 1;
pub const CONFIG_IR_SANYO_DECODER_MODULE: u32 = 1;
pub const CONFIG_DMAR_TABLE: u32 = 1;
pub const CONFIG_MFD_INTEL_LPSS_PCI_MODULE: u32 = 1;
pub const CONFIG_HW_RANDOM_INTEL_MODULE: u32 = 1;
pub const CONFIG_LCD_LTV350QV_MODULE: u32 = 1;
pub const CONFIG_LXT_PHY_MODULE: u32 = 1;
pub const CONFIG_CFG80211_CRDA_SUPPORT: u32 = 1;
pub const CONFIG_FB_MB862XX_MODULE: u32 = 1;
pub const CONFIG_VIDEO_MT9V011_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ALC5623_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_IMG: u32 = 1;
pub const CONFIG_CAN_M_CAN_MODULE: u32 = 1;
pub const CONFIG_WIRELESS: u32 = 1;
pub const CONFIG_WEXT_PROC: u32 = 1;
pub const CONFIG_BCMA_DRIVER_PCI: u32 = 1;
pub const CONFIG_SQUASHFS: u32 = 1;
pub const CONFIG_DRM_TINYDRM_MODULE: u32 = 1;
pub const CONFIG_6LOWPAN_NHC_MODULE: u32 = 1;
pub const CONFIG_EDAC_I7CORE_MODULE: u32 = 1;
pub const CONFIG_RMNET_MODULE: u32 = 1;
pub const CONFIG_HZ_250: u32 = 1;
pub const CONFIG_FB_N411_MODULE: u32 = 1;
pub const CONFIG_X86_IO_APIC: u32 = 1;
pub const CONFIG_ARCH_HAS_STRICT_KERNEL_RWX: u32 = 1;
pub const CONFIG_NFT_DUP_IPV6_MODULE: u32 = 1;
pub const CONFIG_DELL_WMI_AIO_MODULE: u32 = 1;
pub const CONFIG_SND_ALS4000_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_KONICA_MODULE: u32 = 1;
pub const CONFIG_TCG_TIS_I2C_ATMEL_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8770_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_TBF_MODULE: u32 = 1;
pub const CONFIG_BT_HCIBTUSB_MODULE: u32 = 1;
pub const CONFIG_FRAME_VECTOR: u32 = 1;
pub const CONFIG_PKCS7_MESSAGE_PARSER: u32 = 1;
pub const CONFIG_USB_NET_CH9200_MODULE: u32 = 1;
pub const CONFIG_USB_LED_TRIG: u32 = 1;
pub const CONFIG_FB_TFT_ILI9481_MODULE: u32 = 1;
pub const CONFIG_DVB_CX22702_MODULE: u32 = 1;
pub const CONFIG_KGDB: u32 = 1;
pub const CONFIG_MICROCHIP_KSZ_SPI_DRIVER_MODULE: u32 = 1;
pub const CONFIG_LTR501_MODULE: u32 = 1;
pub const CONFIG_SERIO_RAW_MODULE: u32 = 1;
pub const CONFIG_TASK_IO_ACCOUNTING: u32 = 1;
pub const CONFIG_MISC_RTSX_PCI_MODULE: u32 = 1;
pub const CONFIG_FAT_DEFAULT_IOCHARSET: &'static [u8; 10usize] = b"iso8859-1\0";
pub const CONFIG_USBIP_VHCI_NR_HCS: u32 = 1;
pub const CONFIG_UWB_MODULE: u32 = 1;
pub const CONFIG_ASYNC_XOR_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_MASS_STORAGE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SST_TOPLEVEL_MODULE: u32 = 1;
pub const CONFIG_ISDN_CAPI_MIDDLEWARE: u32 = 1;
pub const CONFIG_NET_CLS_RSVP_MODULE: u32 = 1;
pub const CONFIG_TIPC_MODULE: u32 = 1;
pub const CONFIG_MEMORY_HOTPLUG_SPARSE: u32 = 1;
pub const CONFIG_FB_TFT_ILI9163_MODULE: u32 = 1;
pub const CONFIG_DVB_STB6100_MODULE: u32 = 1;
pub const CONFIG_W83977F_WDT_MODULE: u32 = 1;
pub const CONFIG_MD_RAID0_MODULE: u32 = 1;
pub const CONFIG_FRAME_WARN: u32 = 1024;
pub const CONFIG_NET_VENDOR_AGERE: u32 = 1;
pub const CONFIG_SND_FIREFACE_MODULE: u32 = 1;
pub const CONFIG_USB_NET_CDC_NCM_MODULE: u32 = 1;
pub const CONFIG_HID_GENERIC_MODULE: u32 = 1;
pub const CONFIG_ACT200L_DONGLE_MODULE: u32 = 1;
pub const CONFIG_FB_SIS_300: u32 = 1;
pub const CONFIG_X86_VSYSCALL_EMULATION: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_BITS: u32 = 28;
pub const CONFIG_DUMMY_IRQ_MODULE: u32 = 1;
pub const CONFIG_USB_DWC2_HOST: u32 = 1;
pub const CONFIG_USB_HACKRF_MODULE: u32 = 1;
pub const CONFIG_AD7303_MODULE: u32 = 1;
pub const CONFIG_HP_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DAS08_ISA_MODULE: u32 = 1;
pub const CONFIG_MTD_DATAFLASH_OTP: u32 = 1;
pub const CONFIG_HID_RETRODE_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_ZONE_DEVICE: u32 = 1;
pub const CONFIG_COMEDI_USB_DRIVERS_MODULE: u32 = 1;
pub const CONFIG_BCM87XX_PHY_MODULE: u32 = 1;
pub const CONFIG_I2C_DESIGNWARE_PCI_MODULE: u32 = 1;
pub const CONFIG_USB_ETH_MODULE: u32 = 1;
pub const CONFIG_PATA_SCH_MODULE: u32 = 1;
pub const CONFIG_VIDEO_VIM2M_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_ILI9320_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ADAU1701_MODULE: u32 = 1;
pub const CONFIG_BATTERY_TWL4030_MADC_MODULE: u32 = 1;
pub const CONFIG_GENERIC_HWEIGHT: u32 = 1;
pub const CONFIG_INITRAMFS_SOURCE: &'static [u8; 1usize] = b"\0";
pub const CONFIG_VIDEO_TW5864_MODULE: u32 = 1;
pub const CONFIG_RTL_CARDS_MODULE: u32 = 1;
pub const CONFIG_PATA_NETCELL_MODULE: u32 = 1;
pub const CONFIG_X86_MCELOG_LEGACY: u32 = 1;
pub const CONFIG_INPUT_IMS_PCU_MODULE: u32 = 1;
pub const CONFIG_DHT11_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1374_WDT: u32 = 1;
pub const CONFIG_ATM_CLIP_MODULE: u32 = 1;
pub const CONFIG_COMEDI_RTD520_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_SIGMATEL_MODULE: u32 = 1;
pub const CONFIG_CGROUPS: u32 = 1;
pub const CONFIG_MFD_AXP20X_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT5670_MODULE: u32 = 1;
pub const CONFIG_SND_USB_CAIAQ_INPUT: u32 = 1;
pub const CONFIG_MMC: u32 = 1;
pub const CONFIG_LZO_COMPRESS: u32 = 1;
pub const CONFIG_DAX: u32 = 1;
pub const CONFIG_USB_F_PHONET_MODULE: u32 = 1;
pub const CONFIG_VIRTIO_INPUT_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_MMAP_RND_COMPAT_BITS: u32 = 1;
pub const CONFIG_DELL_RBTN_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_GUNZE: u32 = 1;
pub const CONFIG_CRYPTO_SEQIV: u32 = 1;
pub const CONFIG_NI903X_WDT_MODULE: u32 = 1;
pub const CONFIG_GPIO_XRA1403_MODULE: u32 = 1;
pub const CONFIG_BRCMFMAC_MODULE: u32 = 1;
pub const CONFIG_COMEDI_QUATECH_DAQP_CS_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_AD7877_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_POWER_SAVE_DEFAULT: u32 = 0;
pub const CONFIG_TTY_PRINTK: u32 = 1;
pub const CONFIG_9P_FSCACHE: u32 = 1;
pub const CONFIG_HID_LOGITECH_MODULE: u32 = 1;
pub const CONFIG_SND_INDIGODJX_MODULE: u32 = 1;
pub const CONFIG_ISDN_I4L_MODULE: u32 = 1;
pub const CONFIG_ARCNET_COM90xx_MODULE: u32 = 1;
pub const CONFIG_VME_BUS: u32 = 1;
pub const CONFIG_DM_LOG_USERSPACE_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_GAMECON_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_USER_API_RNG_MODULE: u32 = 1;
pub const CONFIG_SCSI_ENCLOSURE_MODULE: u32 = 1;
pub const CONFIG_HAVE_GCC_PLUGINS: u32 = 1;
pub const CONFIG_CAPI_EICON: u32 = 1;
pub const CONFIG_DVB_SP887X_MODULE: u32 = 1;
pub const CONFIG_STACKTRACE: u32 = 1;
pub const CONFIG_NET_EMATCH_CANID_MODULE: u32 = 1;
pub const CONFIG_TAHVO_USB_HOST_BY_DEFAULT: u32 = 1;
pub const CONFIG_SENSORS_LM92_MODULE: u32 = 1;
pub const CONFIG_EXTCON: u32 = 1;
pub const CONFIG_COMEDI_ADDI_APCI_3120_MODULE: u32 = 1;
pub const CONFIG_CHELSIO_LIB_MODULE: u32 = 1;
pub const CONFIG_SCSI_SAS_LIBSAS_MODULE: u32 = 1;
pub const CONFIG_ISCSI_TARGET_MODULE: u32 = 1;
pub const CONFIG_IMA_MEASURE_PCR_IDX: u32 = 10;
pub const CONFIG_HAVE_ACPI_APEI: u32 = 1;
pub const CONFIG_ARCNET_RIM_I_MODULE: u32 = 1;
pub const CONFIG_OPROFILE_NMI_TIMER: u32 = 1;
pub const CONFIG_PATA_RADISYS_MODULE: u32 = 1;
pub const CONFIG_TOSHIBA_HAPS_MODULE: u32 = 1;
pub const CONFIG_IPV6_GRE_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_IDLETIMER_MODULE: u32 = 1;
pub const CONFIG_FB_ATY128_MODULE: u32 = 1;
pub const CONFIG_GPIO_TPS65086_MODULE: u32 = 1;
pub const CONFIG_VFIO_PCI_INTX: u32 = 1;
pub const CONFIG_BMG160_MODULE: u32 = 1;
pub const CONFIG_UIO_AEC_MODULE: u32 = 1;
pub const CONFIG_SCSI_PM8001_MODULE: u32 = 1;
pub const CONFIG_SOC_CAMERA_IMX074_MODULE: u32 = 1;
pub const CONFIG_USB_NET_RNDIS_WLAN_MODULE: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC: u32 = 1;
pub const CONFIG_VIDEO_TUNER_MODULE: u32 = 1;
pub const CONFIG_IFB_MODULE: u32 = 1;
pub const CONFIG_IIO_ST_ACCEL_3AXIS_MODULE: u32 = 1;
pub const CONFIG_USB_FUNCTIONFS_ETH: u32 = 1;
pub const CONFIG_TCS3472_MODULE: u32 = 1;
pub const CONFIG_LEDS_LP3944_MODULE: u32 = 1;
pub const CONFIG_USB_SEVSEG_MODULE: u32 = 1;
pub const CONFIG_SND_MPU401_UART_MODULE: u32 = 1;
pub const CONFIG_IPV6_VTI_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DRBG: u32 = 1;
pub const CONFIG_RTC_DRV_PCF8563_MODULE: u32 = 1;
pub const CONFIG_SND_MAX_CARDS: u32 = 32;
pub const CONFIG_PPTP_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_MSI001_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_V2_MODULE: u32 = 1;
pub const CONFIG_SENSORS_SMSC47M1_MODULE: u32 = 1;
pub const CONFIG_SND_USB_US122L_MODULE: u32 = 1;
pub const CONFIG_USB_CDC_COMPOSITE_MODULE: u32 = 1;
pub const CONFIG_USB_DSBR_MODULE: u32 = 1;
pub const CONFIG_ISCSI_IBFT_FIND: u32 = 1;
pub const CONFIG_KGDB_KDB: u32 = 1;
pub const CONFIG_DCB: u32 = 1;
pub const CONFIG_PCIPCWATCHDOG_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ADMTEK: u32 = 1;
pub const CONFIG_MLX5_MPFS: u32 = 1;
pub const CONFIG_CGROUP_CPUACCT: u32 = 1;
pub const CONFIG_USB_SERIAL_OTI6858_MODULE: u32 = 1;
pub const CONFIG_ACTISYS_DONGLE_MODULE: u32 = 1;
pub const CONFIG_SERIAL_SC16IS7XX_CORE_MODULE: u32 = 1;
pub const CONFIG_MCP4531_MODULE: u32 = 1;
pub const CONFIG_VIDEO_GO7007_USB_MODULE: u32 = 1;
pub const CONFIG_CAN_BCM_MODULE: u32 = 1;
pub const CONFIG_HAS_IOPORT_MAP: u32 = 1;
pub const CONFIG_TI_CPSW_ALE_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ES8328_I2C_MODULE: u32 = 1;
pub const CONFIG_X86_CMPXCHG64: u32 = 1;
pub const CONFIG_VIDEO_SAA7146_VV_MODULE: u32 = 1;
pub const CONFIG_DA9062_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_CARL9170_HWRNG: u32 = 1;
pub const CONFIG_NLMON_MODULE: u32 = 1;
pub const CONFIG_ATH10K_PCI_MODULE: u32 = 1;
pub const CONFIG_CAN_PEAK_PCMCIA_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_VIA: u32 = 1;
pub const CONFIG_UBIFS_FS_SECURITY: u32 = 1;
pub const CONFIG_USB_ATM_MODULE: u32 = 1;
pub const CONFIG_ISA_DMA_API: u32 = 1;
pub const CONFIG_PCMCIA_FDOMAIN_MODULE: u32 = 1;
pub const CONFIG_HZ: u32 = 250;
pub const CONFIG_IIO_SIMPLE_DUMMY_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_SHARE_IRQ: u32 = 1;
pub const CONFIG_UCB1400_CORE_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_VLAN_MODULE: u32 = 1;
pub const CONFIG_IXGBE_HWMON: u32 = 1;
pub const CONFIG_USB_RTL8152_MODULE: u32 = 1;
pub const CONFIG_NEED_MULTIPLE_NODES: u32 = 1;
pub const CONFIG_ECHO_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_F_UAC2: u32 = 1;
pub const CONFIG_I2C_HELPER_AUTO: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_U32_MODULE: u32 = 1;
pub const CONFIG_COMEDI_AMPLC_DIO200_PCI_MODULE: u32 = 1;
pub const CONFIG_VIDEO_SONY_BTF_MPX_MODULE: u32 = 1;
pub const CONFIG_INTEGRITY_TRUSTED_KEYRING: u32 = 1;
pub const CONFIG_SQUASHFS_ZLIB: u32 = 1;
pub const CONFIG_VIDEO_CX23885_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_USA49WLC: u32 = 1;
pub const CONFIG_AGP_INTEL: u32 = 1;
pub const CONFIG_INLINE_SPIN_UNLOCK_IRQ: u32 = 1;
pub const CONFIG_NLS_ISO8859_4_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_AD7879_I2C_MODULE: u32 = 1;
pub const CONFIG_INTEL_OAKTRAIL_MODULE: u32 = 1;
pub const CONFIG_SND_MTS64_MODULE: u32 = 1;
pub const CONFIG_ADE7759_MODULE: u32 = 1;
pub const CONFIG_FB_BACKLIGHT: u32 = 1;
pub const CONFIG_RTC_DRV_RX8025_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_NR_UARTS: u32 = 48;
pub const CONFIG_ARCH_HAS_STRICT_MODULE_RWX: u32 = 1;
pub const CONFIG_TCP_CONG_DCTCP_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_MAX8997_MODULE: u32 = 1;
pub const CONFIG_NET_EMATCH_IPSET_MODULE: u32 = 1;
pub const CONFIG_TI_AM335X_ADC_MODULE: u32 = 1;
pub const CONFIG_AD7291_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_SRPT_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_RMD160_MODULE: u32 = 1;
pub const CONFIG_IR_IMON_MODULE: u32 = 1;
pub const CONFIG_BCM7XXX_PHY_MODULE: u32 = 1;
pub const CONFIG_PATA_HPT366_MODULE: u32 = 1;
pub const CONFIG_NET_EGRESS: u32 = 1;
pub const CONFIG_SCSI_EATA_MODULE: u32 = 1;
pub const CONFIG_XEN_AUTO_XLATE: u32 = 1;
pub const CONFIG_RMI4_CORE_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_ARC: u32 = 1;
pub const CONFIG_SCHED_MC_PRIO: u32 = 1;
pub const CONFIG_IP_SET_HASH_MAC_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_BD663474_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_ENGINE_MODULE: u32 = 1;
pub const CONFIG_INET_AH_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ATXP1_MODULE: u32 = 1;
pub const CONFIG_HID_LENOVO_MODULE: u32 = 1;
pub const CONFIG_HAVE_USER_RETURN_NOTIFIER: u32 = 1;
pub const CONFIG_SND_SOC_ADAU17X1_MODULE: u32 = 1;
pub const CONFIG_MTD_UBI_BEB_LIMIT: u32 = 20;
pub const CONFIG_DEFAULT_IOSCHED: &'static [u8; 4usize] = b"cfq\0";
pub const CONFIG_DRM_I2C_CH7006_MODULE: u32 = 1;
pub const CONFIG_TABLET_USB_KBTAB_MODULE: u32 = 1;
pub const CONFIG_UDF_FS_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1343_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_BYTCR_RT5640_MACH_MODULE: u32 = 1;
pub const CONFIG_IPV6_MIP6_MODULE: u32 = 1;
pub const CONFIG_ADIS16060_MODULE: u32 = 1;
pub const CONFIG_MARVELL_PHY_MODULE: u32 = 1;
pub const CONFIG_HAVE_PERF_USER_STACK_DUMP: u32 = 1;
pub const CONFIG_ACPI_EC_DEBUGFS_MODULE: u32 = 1;
pub const CONFIG_APPLE_PROPERTIES: u32 = 1;
pub const CONFIG_VXFS_FS_MODULE: u32 = 1;
pub const CONFIG_GPIO_SCH_MODULE: u32 = 1;
pub const CONFIG_CGROUP_PERF: u32 = 1;
pub const CONFIG_NLATTR: u32 = 1;
pub const CONFIG_SND_LOLA_MODULE: u32 = 1;
pub const CONFIG_ISDN_CAPI_MODULE: u32 = 1;
pub const CONFIG_HOTPLUG_PCI: u32 = 1;
pub const CONFIG_IIO_ADIS_LIB_MODULE: u32 = 1;
pub const CONFIG_ZD1211RW_MODULE: u32 = 1;
pub const CONFIG_SRF08_MODULE: u32 = 1;
pub const CONFIG_TCP_CONG_CUBIC: u32 = 1;
pub const CONFIG_CEPH_FS_MODULE: u32 = 1;
pub const CONFIG_MPL115_SPI_MODULE: u32 = 1;
pub const CONFIG_SCSI_NETLINK: u32 = 1;
pub const CONFIG_BACKLIGHT_BD6107_MODULE: u32 = 1;
pub const CONFIG_TCG_TIS_ST33ZP24_I2C_MODULE: u32 = 1;
pub const CONFIG_NR_CPUS: u32 = 8192;
pub const CONFIG_IXGBE_MODULE: u32 = 1;
pub const CONFIG_SUSPEND_FREEZER: u32 = 1;
pub const CONFIG_HAVE_EXIT_THREAD: u32 = 1;
pub const CONFIG_IIO_BUFFER_CB_MODULE: u32 = 1;
pub const CONFIG_MMC_SDHCI_MODULE: u32 = 1;
pub const CONFIG_GPIO_CRYSTAL_COVE_MODULE: u32 = 1;
pub const CONFIG_USB_MOUSE_MODULE: u32 = 1;
pub const CONFIG_B43_SSB: u32 = 1;
pub const CONFIG_SND_SUPPORT_OLD_API: u32 = 1;
pub const CONFIG_DVB_DIB7000M_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_CONNMARK_MODULE: u32 = 1;
pub const CONFIG_ENA_ETHERNET_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS35L35_MODULE: u32 = 1;
pub const CONFIG_IIO_ST_ACCEL_SPI_3AXIS_MODULE: u32 = 1;
pub const CONFIG_LEDS_LT3593_MODULE: u32 = 1;
pub const CONFIG_LOGITECH_FF: u32 = 1;
pub const CONFIG_DVB_AF9033_MODULE: u32 = 1;
pub const CONFIG_IPV6_FOU_TUNNEL_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_RAW_MODULE: u32 = 1;
pub const CONFIG_EDAC_PND2_MODULE: u32 = 1;
pub const CONFIG_HID_KYE_MODULE: u32 = 1;
pub const CONFIG_MOUSE_PS2_TRACKPOINT: u32 = 1;
pub const CONFIG_CRYPTO_CHACHA20_MODULE: u32 = 1;
pub const CONFIG_HID_GEMBIRD_MODULE: u32 = 1;
pub const CONFIG_MOUSE_VSXXXAA_MODULE: u32 = 1;
pub const CONFIG_FIRMWARE_IN_KERNEL: u32 = 1;
pub const CONFIG_VIDEO_TM6000_ALSA_MODULE: u32 = 1;
pub const CONFIG_NFT_COMPAT_MODULE: u32 = 1;
pub const CONFIG_LEDS_PCA963X_MODULE: u32 = 1;
pub const CONFIG_DRM_NOUVEAU_BACKLIGHT: u32 = 1;
pub const CONFIG_SOFT_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_SYSFS: u32 = 1;
pub const CONFIG_IPWIRELESS_MODULE: u32 = 1;
pub const CONFIG_EXT4_FS_ENCRYPTION: u32 = 1;
pub const CONFIG_PARIDE_FRPW_MODULE: u32 = 1;
pub const CONFIG_IP_SET_BITMAP_IPMAC_MODULE: u32 = 1;
pub const CONFIG_ISCSI_TARGET_CXGB4_MODULE: u32 = 1;
pub const CONFIG_MTD_NAND_RICOH_MODULE: u32 = 1;
pub const CONFIG_USB_DEFAULT_PERSIST: u32 = 1;
pub const CONFIG_PANEL_PARPORT: u32 = 0;
pub const CONFIG_DVB_MN88473_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_UCB1400_MODULE: u32 = 1;
pub const CONFIG_LIB80211_CRYPT_WEP_MODULE: u32 = 1;
pub const CONFIG_DELL_WMI_MODULE: u32 = 1;
pub const CONFIG_SBP_TARGET_MODULE: u32 = 1;
pub const CONFIG_SENSORS_W83791D_MODULE: u32 = 1;
pub const CONFIG_INPUT_TOUCHSCREEN: u32 = 1;
pub const CONFIG_RT2800USB_UNKNOWN: u32 = 1;
pub const CONFIG_RADIO_SI4713_MODULE: u32 = 1;
pub const CONFIG_DRM_PANEL_BRIDGE: u32 = 1;
pub const CONFIG_DSCC4_PCI_RST: u32 = 1;
pub const CONFIG_RIONET_RX_SIZE: u32 = 128;
pub const CONFIG_SND_SOC_CS42L51_I2C_MODULE: u32 = 1;
pub const CONFIG_ROCKCHIP_PHY_MODULE: u32 = 1;
pub const CONFIG_USB_HUB_USB251XB_MODULE: u32 = 1;
pub const CONFIG_I2C_VIAPRO_MODULE: u32 = 1;
pub const CONFIG_FB_HYPERV_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_NW80X_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_LABELS: u32 = 1;
pub const CONFIG_GPIO_ADP5520_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_RC5T583_MODULE: u32 = 1;
pub const CONFIG_IP_NF_MATCH_AH_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_SRP_MODULE: u32 = 1;
pub const CONFIG_SYNCLINK_CS_MODULE: u32 = 1;
pub const CONFIG_CARL9170_WPC: u32 = 1;
pub const CONFIG_GPIO_BD9571MWV_MODULE: u32 = 1;
pub const CONFIG_VIDEO_SAA7134_GO7007_MODULE: u32 = 1;
pub const CONFIG_TCP_CONG_VENO_MODULE: u32 = 1;
pub const CONFIG_DVB_S5H1420_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_MODULE: u32 = 1;
pub const CONFIG_AFS_FS_MODULE: u32 = 1;
pub const CONFIG_MFD_88PM800_MODULE: u32 = 1;
pub const CONFIG_SMC_MODULE: u32 = 1;
pub const CONFIG_COMEDI_S526_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DAS1800_MODULE: u32 = 1;
pub const CONFIG_USB_EHCI_HCD_PLATFORM: u32 = 1;
pub const CONFIG_SOC_CAMERA_MT9M001_MODULE: u32 = 1;
pub const CONFIG_DVB_NET: u32 = 1;
pub const CONFIG_MEDIA_CEC_RC: u32 = 1;
pub const CONFIG_ASN1: u32 = 1;
pub const CONFIG_NF_LOG_COMMON_MODULE: u32 = 1;
pub const CONFIG_I2C_PARPORT_LIGHT_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_LIMIT_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_AES_NI_INTEL_MODULE: u32 = 1;
pub const CONFIG_NFC_SHDLC: u32 = 1;
pub const CONFIG_CRYPTO_DEV_VIRTIO_MODULE: u32 = 1;
pub const CONFIG_MFD_WM8998: u32 = 1;
pub const CONFIG_ULI526X_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SHA1_MB_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_BU21013_MODULE: u32 = 1;
pub const CONFIG_CC_STACKPROTECTOR: u32 = 1;
pub const CONFIG_I2C_SIMTEC_MODULE: u32 = 1;
pub const CONFIG_FB_SMSCUFX_MODULE: u32 = 1;
pub const CONFIG_NTB_TRANSPORT_MODULE: u32 = 1;
pub const CONFIG_XZ_DEC_ARM: u32 = 1;
pub const CONFIG_DEFAULT_IO_DELAY_TYPE: u32 = 1;
pub const CONFIG_MAX44000_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_775_MODULE: u32 = 1;
pub const CONFIG_MFD_TI_LMU_MODULE: u32 = 1;
pub const CONFIG_IRLAN_MODULE: u32 = 1;
pub const CONFIG_USB_CONFIGFS_EEM: u32 = 1;
pub const CONFIG_RTLLIB_CRYPTO_TKIP_MODULE: u32 = 1;
pub const CONFIG_MOUSE_SERIAL_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_HASH_INFO: u32 = 1;
pub const CONFIG_FB_SYS_FOPS_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_ANALOG_MODULE: u32 = 1;
pub const CONFIG_MISDN_HFCPCI_MODULE: u32 = 1;
pub const CONFIG_WIMAX_MODULE: u32 = 1;
pub const CONFIG_QED_FCOE: u32 = 1;
pub const CONFIG_BLK_SCSI_REQUEST: u32 = 1;
pub const CONFIG_HAVE_SYSCALL_TRACEPOINTS: u32 = 1;
pub const CONFIG_NFC_ST_NCI_I2C_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_XC4000_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_DEVGROUP_MODULE: u32 = 1;
pub const CONFIG_ACPI_BATTERY: u32 = 1;
pub const CONFIG_SND_SOC_TAS571X_MODULE: u32 = 1;
pub const CONFIG_DVB_LGDT3305_MODULE: u32 = 1;
pub const CONFIG_CAN_HI311X_MODULE: u32 = 1;
pub const CONFIG_MEMSTICK_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_RX6110_MODULE: u32 = 1;
pub const CONFIG_FUJITSU_TABLET_MODULE: u32 = 1;
pub const CONFIG_IIO_ST_PRESS_SPI_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_MPR121_MODULE: u32 = 1;
pub const CONFIG_VIDEO_USBTV_MODULE: u32 = 1;
pub const CONFIG_EEPROM_IDT_89HPESX_MODULE: u32 = 1;
pub const CONFIG_PM_DEVFREQ: u32 = 1;
pub const CONFIG_MFD_JANZ_CMODIO_MODULE: u32 = 1;
pub const CONFIG_HISAX_ELSA: u32 = 1;
pub const CONFIG_VIDEO_SAA7146_MODULE: u32 = 1;
pub const CONFIG_MTD_SPINAND_MT29F_MODULE: u32 = 1;
pub const CONFIG_MTD_COMPLEX_MAPPINGS: u32 = 1;
pub const CONFIG_MARVELL_10G_PHY_MODULE: u32 = 1;
pub const CONFIG_FB: u32 = 1;
pub const CONFIG_GREYBUS_LOG_MODULE: u32 = 1;
pub const CONFIG_BATTERY_DA9030_MODULE: u32 = 1;
pub const CONFIG_IMA_NG_TEMPLATE: u32 = 1;
pub const CONFIG_TRACING: u32 = 1;
pub const CONFIG_IIO_SYSFS_TRIGGER_MODULE: u32 = 1;
pub const CONFIG_BLK_MQ_VIRTIO: u32 = 1;
pub const CONFIG_SECURITY_STACKING: u32 = 1;
pub const CONFIG_TOUCHSCREEN_S6SY761_MODULE: u32 = 1;
pub const CONFIG_IP_NF_MATCH_RPFILTER_MODULE: u32 = 1;
pub const CONFIG_REGMAP_W1_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_865_MODULE: u32 = 1;
pub const CONFIG_I2C_COMPAT: u32 = 1;
pub const CONFIG_KEYBOARD_OPENCORES_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ZYDAS: u32 = 1;
pub const CONFIG_EFI_DEV_PATH_PARSER: u32 = 1;
pub const CONFIG_CHARGER_LTC3651_MODULE: u32 = 1;
pub const CONFIG_INET_SCTP_DIAG_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_BYT_CHT_DA7213_MACH_MODULE: u32 = 1;
pub const CONFIG_NFSD_V3_ACL: u32 = 1;
pub const CONFIG_SND_SOC_SSM4567_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_SPCA500_MODULE: u32 = 1;
pub const CONFIG_GPIO_UCB1400_MODULE: u32 = 1;
pub const CONFIG_SPARSEMEM_VMEMMAP_ENABLE: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_CPU: u32 = 1;
pub const CONFIG_PC300TOO_MODULE: u32 = 1;
pub const CONFIG_HID_ELO_MODULE: u32 = 1;
pub const CONFIG_ENCX24J600_MODULE: u32 = 1;
pub const CONFIG_AIM_V4L2_MODULE: u32 = 1;
pub const CONFIG_IPVLAN_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_LABPC_ISADMA_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_DA7213_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_NAT_MODULE: u32 = 1;
pub const CONFIG_BATTERY_DS2780_MODULE: u32 = 1;
pub const CONFIG_GPIO_104_IDI_48_MODULE: u32 = 1;
pub const CONFIG_NFC_PORT100_MODULE: u32 = 1;
pub const CONFIG_FTRACE_MCOUNT_RECORD: u32 = 1;
pub const CONFIG_OCFS2_FS_STATS: u32 = 1;
pub const CONFIG_VIRTUALIZATION: u32 = 1;
pub const CONFIG_MFD_SKY81452_MODULE: u32 = 1;
pub const CONFIG_ND_CLAIM: u32 = 1;
pub const CONFIG_VIDEO_ZORAN_DC10_MODULE: u32 = 1;
pub const CONFIG_MSDOS_PARTITION: u32 = 1;
pub const CONFIG_USB_CHIPIDEA_PCI_MODULE: u32 = 1;
pub const CONFIG_COMEDI_RTI800_MODULE: u32 = 1;
pub const CONFIG_MXC4005_MODULE: u32 = 1;
pub const CONFIG_RTC_I2C_AND_SPI: u32 = 1;
pub const CONFIG_MYRI10GE_DCA: u32 = 1;
pub const CONFIG_PATA_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_MODULE: u32 = 1;
pub const CONFIG_RESET_ATTACK_MITIGATION: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_NEXIO: u32 = 1;
pub const CONFIG_BOOTPARAM_HARDLOCKUP_PANIC_VALUE: u32 = 0;
pub const CONFIG_RT2800USB_RT33XX: u32 = 1;
pub const CONFIG_SND_SOC_WM8903_MODULE: u32 = 1;
pub const CONFIG_DVB_LNBP22_MODULE: u32 = 1;
pub const CONFIG_SENSORS_WM831X_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_INTEL: u32 = 1;
pub const CONFIG_RTC_DRV_TPS6586X_MODULE: u32 = 1;
pub const CONFIG_GPIO_ADP5588_MODULE: u32 = 1;
pub const CONFIG_SENSORS_TMP421_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8804_SPI_MODULE: u32 = 1;
pub const CONFIG_FB_RADEON_I2C: u32 = 1;
pub const CONFIG_DVB_RTL2832_SDR_MODULE: u32 = 1;
pub const CONFIG_CAN_PEAK_PCIEFD_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_SN9C2028_MODULE: u32 = 1;
pub const CONFIG_SUNGEM_MODULE: u32 = 1;
pub const CONFIG_BMP280_I2C_MODULE: u32 = 1;
pub const CONFIG_HAVE_OPROFILE: u32 = 1;
pub const CONFIG_IR_STREAMZAP_MODULE: u32 = 1;
pub const CONFIG_SND_HDSPM_MODULE: u32 = 1;
pub const CONFIG_CAN_PEAK_PCIEC: u32 = 1;
pub const CONFIG_EFI_VARS_PSTORE_MODULE: u32 = 1;
pub const CONFIG_X86_INTEL_LPSS: u32 = 1;
pub const CONFIG_LEDS_CLEVO_MAIL_MODULE: u32 = 1;
pub const CONFIG_TEST_UDELAY_MODULE: u32 = 1;
pub const CONFIG_CPU_IDLE_GOV_LADDER: u32 = 1;
pub const CONFIG_IP_SET_MODULE: u32 = 1;
pub const CONFIG_THERMAL: u32 = 1;
pub const CONFIG_DVB_BUDGET_PATCH_MODULE: u32 = 1;
pub const CONFIG_SYNC_FILE: u32 = 1;
pub const CONFIG_USB_XHCI_PCI: u32 = 1;
pub const CONFIG_TOUCHSCREEN_TOUCHRIGHT_MODULE: u32 = 1;
pub const CONFIG_AMD8111_ETH_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADL_PCI8164_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_ACPI_INTEL_MATCH_MODULE: u32 = 1;
pub const CONFIG_XEN_ACPI: u32 = 1;
pub const CONFIG_AMD_IOMMU: u32 = 1;
pub const CONFIG_I2C_AMD8111_MODULE: u32 = 1;
pub const CONFIG_INPUT_POWERMATE_MODULE: u32 = 1;
pub const CONFIG_NET_FC: u32 = 1;
pub const CONFIG_ACPI_WATCHDOG: u32 = 1;
pub const CONFIG_FB_S3_MODULE: u32 = 1;
pub const CONFIG_BRCMUTIL_MODULE: u32 = 1;
pub const CONFIG_DVB_TTUSB_BUDGET_MODULE: u32 = 1;
pub const CONFIG_VETH_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_PCF8583_MODULE: u32 = 1;
pub const CONFIG_DVB_MT312_MODULE: u32 = 1;
pub const CONFIG_MLX5_CORE_EN: u32 = 1;
pub const CONFIG_LEDS_PCA955X_GPIO: u32 = 1;
pub const CONFIG_MFD_TPS65912_I2C: u32 = 1;
pub const CONFIG_NET_VENDOR_3COM: u32 = 1;
pub const CONFIG_TOUCHSCREEN_ROHM_BU21023_MODULE: u32 = 1;
pub const CONFIG_ATM_DUMMY_MODULE: u32 = 1;
pub const CONFIG_MAX517_MODULE: u32 = 1;
pub const CONFIG_HID_PETALYNX_MODULE: u32 = 1;
pub const CONFIG_AMD_NUMA: u32 = 1;
pub const CONFIG_MTD_PCMCIA_MODULE: u32 = 1;
pub const CONFIG_FB_ATY_CT: u32 = 1;
pub const CONFIG_IRQ_BYPASS_MANAGER_MODULE: u32 = 1;
pub const CONFIG_ADXRS450_MODULE: u32 = 1;
pub const CONFIG_TLAN_MODULE: u32 = 1;
pub const CONFIG_INTEL_MIC_BUS_MODULE: u32 = 1;
pub const CONFIG_ARCH_ENABLE_SPLIT_PMD_PTLOCK: u32 = 1;
pub const CONFIG_COMEDI_AMPLC_PCI230_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_VIA_MODULE: u32 = 1;
pub const CONFIG_CMDLINE_PARTITION: u32 = 1;
pub const CONFIG_MEMSTICK_TIFM_MS_MODULE: u32 = 1;
pub const CONFIG_ATM_LANE_MODULE: u32 = 1;
pub const CONFIG_MLXSW_CORE_THERMAL: u32 = 1;
pub const CONFIG_COMMON_CLK_PWM_MODULE: u32 = 1;
pub const CONFIG_NET_DSA_TAG_BRCM: u32 = 1;
pub const CONFIG_SENSORS_W83L786NG_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_PCM1681_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_MIRRED_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_KGDB: u32 = 1;
pub const CONFIG_ARCH_USE_QUEUED_SPINLOCKS: u32 = 1;
pub const CONFIG_IMA_DEFAULT_HASH: &'static [u8; 5usize] = b"sha1\0";
pub const CONFIG_INPUT_APANEL_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_ABLK_HELPER_MODULE: u32 = 1;
pub const CONFIG_B43_PCICORE_AUTOSELECT: u32 = 1;
pub const CONFIG_NF_CONNTRACK_IPV4_MODULE: u32 = 1;
pub const CONFIG_BLK_DEBUG_FS: u32 = 1;
pub const CONFIG_QLCNIC_SRIOV: u32 = 1;
pub const CONFIG_MYRI10GE_MODULE: u32 = 1;
pub const CONFIG_X86_PM_TIMER: u32 = 1;
pub const CONFIG_TI_ADC161S626_MODULE: u32 = 1;
pub const CONFIG_USB_VL600_MODULE: u32 = 1;
pub const CONFIG_PARIDE_BPCK_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_HID_SENSOR_TIME_MODULE: u32 = 1;
pub const CONFIG_ZPA2326_I2C_MODULE: u32 = 1;
pub const CONFIG_B43LEGACY_HWRNG: u32 = 1;
pub const CONFIG_NET_DSA_TAG_LAN9303: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_CHT_BSW_RT5672_MACH_MODULE: u32 = 1;
pub const CONFIG_HAVE_RCU_TABLE_INVALIDATE: u32 = 1;
pub const CONFIG_ATH9K_BTCOEX_SUPPORT: u32 = 1;
pub const CONFIG_CAN_SOFTING_MODULE: u32 = 1;
pub const CONFIG_STM_DUMMY_MODULE: u32 = 1;
pub const CONFIG_RT2X00_LIB_PCI_MODULE: u32 = 1;
pub const CONFIG_SND_DUMMY_MODULE: u32 = 1;
pub const CONFIG_X86_DEBUG_FPU: u32 = 1;
pub const CONFIG_SCSI_MVSAS_MODULE: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_SCHEDUTIL: u32 = 1;
pub const CONFIG_ADIS16260_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_INTEL: u32 = 1;
pub const CONFIG_USB_WUSB_CBAF_MODULE: u32 = 1;
pub const CONFIG_NFC_PN544_I2C_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_TAS2552_MODULE: u32 = 1;
pub const CONFIG_RPS: u32 = 1;
pub const CONFIG_PACKET_DIAG_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_IMG_I2S_OUT_MODULE: u32 = 1;
pub const CONFIG_DVB_AU8522_DTV_MODULE: u32 = 1;
pub const CONFIG_HISAX_ST5481_MODULE: u32 = 1;
pub const CONFIG_USB_NET_ZAURUS_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_EXAR_MODULE: u32 = 1;
pub const CONFIG_DEVFREQ_GOV_PERFORMANCE: u32 = 1;
pub const CONFIG_INET6_XFRM_TUNNEL_MODULE: u32 = 1;
pub const CONFIG_DRM_AST_MODULE: u32 = 1;
pub const CONFIG_DM_MULTIPATH_ST_MODULE: u32 = 1;
pub const CONFIG_NET_TEAM_MODE_RANDOM_MODULE: u32 = 1;
pub const CONFIG_SPI_DW_MID_DMA: u32 = 1;
pub const CONFIG_SENSORS_LM95241_MODULE: u32 = 1;
pub const CONFIG_PROC_PID_CPUSET: u32 = 1;
pub const CONFIG_REALTEK_AUTOPM: u32 = 1;
pub const CONFIG_IEEE802154_ADF7242_MODULE: u32 = 1;
pub const CONFIG_USB_NET_AX88179_178A_MODULE: u32 = 1;
pub const CONFIG_FB_METRONOME_MODULE: u32 = 1;
pub const CONFIG_NF_TABLES_BRIDGE_MODULE: u32 = 1;
pub const CONFIG_USB_MV_U3D_MODULE: u32 = 1;
pub const CONFIG_AD525X_DPOT_SPI_MODULE: u32 = 1;
pub const CONFIG_BATTERY_GAUGE_LTC2941_MODULE: u32 = 1;
pub const CONFIG_INET_ESP_OFFLOAD_MODULE: u32 = 1;
pub const CONFIG_PM_GENERIC_DOMAINS: u32 = 1;
pub const CONFIG_LEGACY_PTY_COUNT: u32 = 0;
pub const CONFIG_MEDIA_TUNER_E4000_MODULE: u32 = 1;
pub const CONFIG_INPUT_ATLAS_BTNS_MODULE: u32 = 1;
pub const CONFIG_LOAD_UEFI_KEYS: u32 = 1;
pub const CONFIG_ACQUIRE_WDT_MODULE: u32 = 1;
pub const CONFIG_PM_WAKELOCKS_LIMIT: u32 = 100;
pub const CONFIG_VIDEO_SAA6588_MODULE: u32 = 1;
pub const CONFIG_IPV6_FOU_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_DMC_TSC10: u32 = 1;
pub const CONFIG_DVB_ZL10039_MODULE: u32 = 1;
pub const CONFIG_CAPI_AVM: u32 = 1;
pub const CONFIG_MTD_MAP_BANK_WIDTH_2: u32 = 1;
pub const CONFIG_USB_AUDIO_MODULE: u32 = 1;
pub const CONFIG_NFT_REJECT_MODULE: u32 = 1;
pub const CONFIG_NVME_TARGET_RDMA_MODULE: u32 = 1;
pub const CONFIG_WDTPCI_MODULE: u32 = 1;
pub const CONFIG_STX104_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_DEBUG_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX16064_MODULE: u32 = 1;
pub const CONFIG_IP_SET_HASH_IPPORTIP_MODULE: u32 = 1;
pub const CONFIG_MLX4_EN_MODULE: u32 = 1;
pub const CONFIG_PARIDE_DSTR_MODULE: u32 = 1;
pub const CONFIG_TABLET_USB_ACECAD_MODULE: u32 = 1;
pub const CONFIG_HYPERVISOR_GUEST: u32 = 1;
pub const CONFIG_SENSORS_LM70_MODULE: u32 = 1;
pub const CONFIG_SERIAL_MAX310X: u32 = 1;
pub const CONFIG_SECURITY_SMACK_NETFILTER: u32 = 1;
pub const CONFIG_NET_EMATCH_NBYTE_MODULE: u32 = 1;
pub const CONFIG_SENSORS_BH1770_MODULE: u32 = 1;
pub const CONFIG_NORTEL_HERMES_MODULE: u32 = 1;
pub const CONFIG_SIS190_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_UC1611_MODULE: u32 = 1;
pub const CONFIG_INTEL_INT0002_VGPIO_MODULE: u32 = 1;
pub const CONFIG_NVM_RRPC_MODULE: u32 = 1;
pub const CONFIG_RAPIDIO_DMA_ENGINE: u32 = 1;
pub const CONFIG_FONT_TER16x32: u32 = 1;
pub const CONFIG_USB_BDC_UDC_MODULE: u32 = 1;
pub const CONFIG_TCG_NSC_MODULE: u32 = 1;
pub const CONFIG_BCMA_SFLASH: u32 = 1;
pub const CONFIG_ZISOFS: u32 = 1;
pub const CONFIG_WLAN_VENDOR_MEDIATEK: u32 = 1;
pub const CONFIG_WIMAX_I2400M_MODULE: u32 = 1;
pub const CONFIG_CUSE_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8728_MODULE: u32 = 1;
pub const CONFIG_FB_BROADSHEET_MODULE: u32 = 1;
pub const CONFIG_HTC_PASIC3_MODULE: u32 = 1;
pub const CONFIG_USB_ZERO_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_CRYPTOLOOP_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_WM97XX_MODULE: u32 = 1;
pub const CONFIG_NF_TABLES_IPV4_MODULE: u32 = 1;
pub const CONFIG_IP_MULTICAST: u32 = 1;
pub const CONFIG_FB_RADEON_MODULE: u32 = 1;
pub const CONFIG_DM_CACHE_SMQ_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_RMD256_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_HASWELL_MODULE: u32 = 1;
pub const CONFIG_DVB_MT352_MODULE: u32 = 1;
pub const CONFIG_RC_ATI_REMOTE_MODULE: u32 = 1;
pub const CONFIG_W83627HF_WDT_MODULE: u32 = 1;
pub const CONFIG_SQUASHFS_XZ: u32 = 1;
pub const CONFIG_FB_VOODOO1_MODULE: u32 = 1;
pub const CONFIG_USB_NET_CX82310_ETH_MODULE: u32 = 1;
pub const CONFIG_GENERIC_CMOS_UPDATE: u32 = 1;
pub const CONFIG_NET_VENDOR_CISCO: u32 = 1;
pub const CONFIG_REGULATOR_AS3711_MODULE: u32 = 1;
pub const CONFIG_EEPROM_MAX6875_MODULE: u32 = 1;
pub const CONFIG_ACPI_ALS_MODULE: u32 = 1;
pub const CONFIG_W1_MASTER_MATROX_MODULE: u32 = 1;
pub const CONFIG_DRM_CIRRUS_QEMU_MODULE: u32 = 1;
pub const CONFIG_MOUSE_APPLETOUCH_MODULE: u32 = 1;
pub const CONFIG_HID_LOGITECH_DJ_MODULE: u32 = 1;
pub const CONFIG_DEFAULT_SECURITY: &'static [u8; 9usize] = b"apparmor\0";
pub const CONFIG_MFD_DLN2_MODULE: u32 = 1;
pub const CONFIG_VIDEO_STK1160_MODULE: u32 = 1;
pub const CONFIG_BT_LEDS: u32 = 1;
pub const CONFIG_CRYPTO_DH: u32 = 1;
pub const CONFIG_TICK_ONESHOT: u32 = 1;
pub const CONFIG_HISAX_HFCUSB_MODULE: u32 = 1;
pub const CONFIG_FB_I740_MODULE: u32 = 1;
pub const CONFIG_XEN_PCIDEV_FRONTEND_MODULE: u32 = 1;
pub const CONFIG_HID_BETOP_FF_MODULE: u32 = 1;
pub const CONFIG_NF_NAT_PROTO_UDPLITE: u32 = 1;
pub const CONFIG_USB_SERIAL_SIERRAWIRELESS_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CTR: u32 = 1;
pub const CONFIG_GPIO_TPS6586X: u32 = 1;
pub const CONFIG_PCMCIA_XIRC2PS_MODULE: u32 = 1;
pub const CONFIG_COMPAT_FOR_U64_ALIGNMENT: u32 = 1;
pub const CONFIG_MTRR_SANITIZER: u32 = 1;
pub const CONFIG_DVB_STV090x_MODULE: u32 = 1;
pub const CONFIG_SCSI_HPTIOP_MODULE: u32 = 1;
pub const CONFIG_NATIONAL_PHY_MODULE: u32 = 1;
pub const CONFIG_B43LEGACY_PCICORE_AUTOSELECT: u32 = 1;
pub const CONFIG_SW_SYNC: u32 = 1;
pub const CONFIG_USB_CONFIGFS_F_LB_SS: u32 = 1;
pub const CONFIG_SPI_DW_PCI_MODULE: u32 = 1;
pub const CONFIG_ORE_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_PDA_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TW68_MODULE: u32 = 1;
pub const CONFIG_DE_AOC: u32 = 1;
pub const CONFIG_WIRELESS_EXT: u32 = 1;
pub const CONFIG_MEDIA_TUNER_MT2060_MODULE: u32 = 1;
pub const CONFIG_HID_PICOLCD_BACKLIGHT: u32 = 1;
pub const CONFIG_SND_SOC_RT5640_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ADV_PCI1710_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_CA0110_MODULE: u32 = 1;
pub const CONFIG_GPIO_TPS65910: u32 = 1;
pub const CONFIG_NFC_ST_NCI_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_RS5C348_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_PV88080_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_FTRTC010_MODULE: u32 = 1;
pub const CONFIG_DELL_UART_BACKLIGHT_MODULE: u32 = 1;
pub const CONFIG_MODVERSIONS: u32 = 1;
pub const CONFIG_HW_RANDOM: u32 = 1;
pub const CONFIG_B43_PCI_AUTOSELECT: u32 = 1;
pub const CONFIG_MUTEX_SPIN_ON_OWNER: u32 = 1;
pub const CONFIG_NCPFS_STRONG: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_MACH_MODULE: u32 = 1;
pub const CONFIG_PATA_LEGACY_MODULE: u32 = 1;
pub const CONFIG_IO_DELAY_TYPE_0X80: u32 = 0;
pub const CONFIG_DVB_USB_AU6610_MODULE: u32 = 1;
pub const CONFIG_CAN_LEDS: u32 = 1;
pub const CONFIG_SPI_LM70_LLP_MODULE: u32 = 1;
pub const CONFIG_X86_SPEEDSTEP_LIB_MODULE: u32 = 1;
pub const CONFIG_IE6XX_WDT_MODULE: u32 = 1;
pub const CONFIG_BT_HCIBTUSB_RTL: u32 = 1;
pub const CONFIG_SYS_HYPERVISOR: u32 = 1;
pub const CONFIG_TOUCHSCREEN_WACOM_I2C_MODULE: u32 = 1;
pub const CONFIG_USB_LEDS_TRIGGER_USBPORT_MODULE: u32 = 1;
pub const CONFIG_IRNET_MODULE: u32 = 1;
pub const CONFIG_ATM_IA_MODULE: u32 = 1;
pub const CONFIG_VIRTIO_VSOCKETS_COMMON_MODULE: u32 = 1;
pub const CONFIG_DRM_AMD_DC_DCN1_0: u32 = 1;
pub const CONFIG_TRACE_ROUTER_MODULE: u32 = 1;
pub const CONFIG_SND_VIRTUOSO_MODULE: u32 = 1;
pub const CONFIG_AMIGA_PARTITION: u32 = 1;
pub const CONFIG_EARLY_PRINTK: u32 = 1;
pub const CONFIG_SND_SOC_WM8804_I2C_MODULE: u32 = 1;
pub const CONFIG_THINKPAD_ACPI_ALSA_SUPPORT: u32 = 1;
pub const CONFIG_CGROUP_NET_CLASSID: u32 = 1;
pub const CONFIG_MTD_AR7_PARTS_MODULE: u32 = 1;
pub const CONFIG_MEMCG_SWAP: u32 = 1;
pub const CONFIG_SENSORS_ADS7871_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_SYNPROXY_MODULE: u32 = 1;
pub const CONFIG_TPL0102_MODULE: u32 = 1;
pub const CONFIG_FS_DAX: u32 = 1;
pub const CONFIG_INTEL_TH_MSU_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT5677_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_737_MODULE: u32 = 1;
pub const CONFIG_NF_NAT_IPV4_MODULE: u32 = 1;
pub const CONFIG_HAVE_FUNCTION_GRAPH_TRACER: u32 = 1;
pub const CONFIG_HW_RANDOM_VIA_MODULE: u32 = 1;
pub const CONFIG_SUNDANCE_MODULE: u32 = 1;
pub const CONFIG_SENSORS_W83781D_MODULE: u32 = 1;
pub const CONFIG_I2C_DESIGNWARE_PLATFORM: u32 = 1;
pub const CONFIG_CAN_SOFTING_CS_MODULE: u32 = 1;
pub const CONFIG_HAVE_CMPXCHG_LOCAL: u32 = 1;
pub const CONFIG_NVDIMM_PFN: u32 = 1;
pub const CONFIG_AF_KCM_MODULE: u32 = 1;
pub const CONFIG_LNET_XPRT_IB_MODULE: u32 = 1;
pub const CONFIG_VIDEOBUF2_CORE_MODULE: u32 = 1;
pub const CONFIG_PARIDE_COMM_MODULE: u32 = 1;
pub const CONFIG_DVB_HELENE_MODULE: u32 = 1;
pub const CONFIG_SSB_DRIVER_GPIO: u32 = 1;
pub const CONFIG_IRTTY_SIR_MODULE: u32 = 1;
pub const CONFIG_EEEPC_WMI_MODULE: u32 = 1;
pub const CONFIG_INPUT_ADXL34X_I2C_MODULE: u32 = 1;
pub const CONFIG_TREE_SRCU: u32 = 1;
pub const CONFIG_CRYPTO_NULL2: u32 = 1;
pub const CONFIG_NTFS_FS_MODULE: u32 = 1;
pub const CONFIG_VIDEO_AU0828_V4L2: u32 = 1;
pub const CONFIG_REGULATOR_MAX8998_MODULE: u32 = 1;
pub const CONFIG_ACPI_THERMAL: u32 = 1;
pub const CONFIG_RT2X00_LIB_CRYPTO: u32 = 1;
pub const CONFIG_SCSI_DH_HP_SW_MODULE: u32 = 1;
pub const CONFIG_IP_SCTP_MODULE: u32 = 1;
pub const CONFIG_DVB_STB0899_MODULE: u32 = 1;
pub const CONFIG_INPUT_SOC_BUTTON_ARRAY_MODULE: u32 = 1;
pub const CONFIG_P54_PCI_MODULE: u32 = 1;
pub const CONFIG_LEDS_ADP5520_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_ACPI_TABLE_UPGRADE: u32 = 1;
pub const CONFIG_SERIAL_8250_DMA: u32 = 1;
pub const CONFIG_BASE_SMALL: u32 = 0;
pub const CONFIG_LUSTRE_FS_MODULE: u32 = 1;
pub const CONFIG_IWLEGACY_DEBUGFS: u32 = 1;
pub const CONFIG_ADE7854_I2C_MODULE: u32 = 1;
pub const CONFIG_XEN_GRANT_DEV_ALLOC_MODULE: u32 = 1;
pub const CONFIG_ISDN_PPP_BSDCOMP_MODULE: u32 = 1;
pub const CONFIG_PM_WAKELOCKS: u32 = 1;
pub const CONFIG_CRYPTO_BLKCIPHER2: u32 = 1;
pub const CONFIG_SCSI_SAS_ATTRS_MODULE: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_AVC_STATS: u32 = 1;
pub const CONFIG_RTL8187_MODULE: u32 = 1;
pub const CONFIG_X86_PMEM_LEGACY_DEVICE: u32 = 1;
pub const CONFIG_SND_SEQ_DUMMY_MODULE: u32 = 1;
pub const CONFIG_QTNFMAC_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_AES_X86_64_MODULE: u32 = 1;
pub const CONFIG_B43LEGACY_PCI_AUTOSELECT: u32 = 1;
pub const CONFIG_DM_RAID_MODULE: u32 = 1;
pub const CONFIG_COMPACTION: u32 = 1;
pub const CONFIG_NFS_V2_MODULE: u32 = 1;
pub const CONFIG_USB_HCD_BCMA_MODULE: u32 = 1;
pub const CONFIG_ADE7854_SPI_MODULE: u32 = 1;
pub const CONFIG_SCSI_MPT3SAS_MAX_SGE: u32 = 128;
pub const CONFIG_CAN_SJA1000_ISA_MODULE: u32 = 1;
pub const CONFIG_DVB_TDA18271C2DD_MODULE: u32 = 1;
pub const CONFIG_QLGE_MODULE: u32 = 1;
pub const CONFIG_USB_AIRSPY_MODULE: u32 = 1;
pub const CONFIG_ALIENWARE_WMI_MODULE: u32 = 1;
pub const CONFIG_VIDEO_TM6000_MODULE: u32 = 1;
pub const CONFIG_DVB_CXD2820R_MODULE: u32 = 1;
pub const CONFIG_WM8350_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_MRVL: u32 = 1;
pub const CONFIG_VIDEO_TDA7432_MODULE: u32 = 1;
pub const CONFIG_TEST_POWER_MODULE: u32 = 1;
pub const CONFIG_NF_DUP_IPV6_MODULE: u32 = 1;
pub const CONFIG_RTL8723BE_MODULE: u32 = 1;
pub const CONFIG_Z3FOLD_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS2404_MODULE: u32 = 1;
pub const CONFIG_HDM_DIM2_MODULE: u32 = 1;
pub const CONFIG_DM_ERA_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_DAQ_DIO24_CS_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_SONIXJ_MODULE: u32 = 1;
pub const CONFIG_SERIAL_ALTERA_UART_BAUDRATE: u32 = 115200;
pub const CONFIG_THINKPAD_ACPI_HOTKEY_POLL: u32 = 1;
pub const CONFIG_REGULATOR_MT6323_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_F81232_MODULE: u32 = 1;
pub const CONFIG_DRM_AMDGPU_MODULE: u32 = 1;
pub const CONFIG_VIDEO_OV7670_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1553_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_HAMPSHIRE_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_KHAZAD_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_TSC2005_MODULE: u32 = 1;
pub const CONFIG_PROC_FS: u32 = 1;
pub const CONFIG_MMC_CB710_MODULE: u32 = 1;
pub const CONFIG_NET_PACKET_ENGINE: u32 = 1;
pub const CONFIG_MTD_BLOCK_MODULE: u32 = 1;
pub const CONFIG_SND_OXFW_MODULE: u32 = 1;
pub const CONFIG_MPL3115_MODULE: u32 = 1;
pub const CONFIG_ACPI_HOTPLUG_MEMORY: u32 = 1;
pub const CONFIG_VIDEOBUF2_VMALLOC_MODULE: u32 = 1;
pub const CONFIG_NFT_BRIDGE_REJECT_MODULE: u32 = 1;
pub const CONFIG_GENERIC_BUG_RELATIVE_POINTERS: u32 = 1;
pub const CONFIG_SND_SOC_WM8523_MODULE: u32 = 1;
pub const CONFIG_6LOWPAN_NHC_FRAGMENT_MODULE: u32 = 1;
pub const CONFIG_SECURITY_TOMOYO: u32 = 1;
pub const CONFIG_RC_MAP_MODULE: u32 = 1;
pub const CONFIG_LCD_S6E63M0_MODULE: u32 = 1;
pub const CONFIG_WEXT_PRIV: u32 = 1;
pub const CONFIG_THINKPAD_ACPI_VIDEO: u32 = 1;
pub const CONFIG_VIRTIO_MMIO: u32 = 1;
pub const CONFIG_NET_VENDOR_ROCKER: u32 = 1;
pub const CONFIG_SCSI_LOWLEVEL: u32 = 1;
pub const CONFIG_SND_SOC_MAX98504_MODULE: u32 = 1;
pub const CONFIG_DP83822_PHY_MODULE: u32 = 1;
pub const CONFIG_ROSE_MODULE: u32 = 1;
pub const CONFIG_HYPERV_VSOCKETS_MODULE: u32 = 1;
pub const CONFIG_INTEL_SOC_PMIC_CHTDC_TI_MODULE: u32 = 1;
pub const CONFIG_INTEL_SOC_DTS_IOSF_CORE_MODULE: u32 = 1;
pub const CONFIG_INPUT_GPIO_ROTARY_ENCODER_MODULE: u32 = 1;
pub const CONFIG_IP_VS_PROTO_AH_ESP: u32 = 1;
pub const CONFIG_MTD_QINFO_PROBE_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_POWER_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_NAU8825_MODULE: u32 = 1;
pub const CONFIG_INPUT_DRV260X_HAPTICS_MODULE: u32 = 1;
pub const CONFIG_IRQ_FORCED_THREADING: u32 = 1;
pub const CONFIG_NILFS2_FS_MODULE: u32 = 1;
pub const CONFIG_ATH9K_PCI: u32 = 1;
pub const CONFIG_TOUCHSCREEN_HIDEEP_MODULE: u32 = 1;
pub const CONFIG_EDAC_ATOMIC_SCRUB: u32 = 1;
pub const CONFIG_NFSD_FLEXFILELAYOUT: u32 = 1;
pub const CONFIG_USB_F_HID_MODULE: u32 = 1;
pub const CONFIG_DRM_VM: u32 = 1;
pub const CONFIG_NLS_ISO8859_3_MODULE: u32 = 1;
pub const CONFIG_RSI_91X_MODULE: u32 = 1;
pub const CONFIG_FB_OPENCORES_MODULE: u32 = 1;
pub const CONFIG_XEN_SYS_HYPERVISOR: u32 = 1;
pub const CONFIG_CRYPTO_CMAC_MODULE: u32 = 1;
pub const CONFIG_DELL_SMBIOS_WMI: u32 = 1;
pub const CONFIG_INTEL_TELEMETRY_MODULE: u32 = 1;
pub const CONFIG_IIO_CROS_EC_LIGHT_PROX_MODULE: u32 = 1;
pub const CONFIG_MAX30100_MODULE: u32 = 1;
pub const CONFIG_COMEDI_PCL816_MODULE: u32 = 1;
pub const CONFIG_HID_PANTHERLORD_MODULE: u32 = 1;
pub const CONFIG_DRM_FBDEV_EMULATION: u32 = 1;
pub const CONFIG_MTDRAM_ERASE_SIZE: u32 = 128;
pub const CONFIG_SND_MODULE: u32 = 1;
pub const CONFIG_MTD_ICHXROM_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_STI_SAS_MODULE: u32 = 1;
pub const CONFIG_SND_SST_ATOM_HIFI2_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SST_MODULE: u32 = 1;
pub const CONFIG_IIO_ST_GYRO_I2C_3AXIS_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_TEQL_MODULE: u32 = 1;
pub const CONFIG_MEMSTICK_JMICRON_38X_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MCP3021_MODULE: u32 = 1;
pub const CONFIG_IR_RC6_DECODER_MODULE: u32 = 1;
pub const CONFIG_XEN_NETDEV_BACKEND_MODULE: u32 = 1;
pub const CONFIG_LTC2485_MODULE: u32 = 1;
pub const CONFIG_MFD_LP3943_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_ABB5ZES3_MODULE: u32 = 1;
pub const CONFIG_SCSI_SNIC_MODULE: u32 = 1;
pub const CONFIG_KXCJK1013_MODULE: u32 = 1;
pub const CONFIG_MTD_OOPS_MODULE: u32 = 1;
pub const CONFIG_IWLEGACY_MODULE: u32 = 1;
pub const CONFIG_SCSI_INIA100_MODULE: u32 = 1;
pub const CONFIG_S2IO_MODULE: u32 = 1;
pub const CONFIG_IP_VS_SH_MODULE: u32 = 1;
pub const CONFIG_XEN_BALLOON: u32 = 1;
pub const CONFIG_MTD_NAND_DOCG4_MODULE: u32 = 1;
pub const CONFIG_VIDEO_MSP3400_MODULE: u32 = 1;
pub const CONFIG_VIDEO_BT856_MODULE: u32 = 1;
pub const CONFIG_USB_F_OBEX_MODULE: u32 = 1;
pub const CONFIG_PLIP_MODULE: u32 = 1;
pub const CONFIG_SCSI_EATA_TAGGED_QUEUE: u32 = 1;
pub const CONFIG_CRYPTO_SERPENT_AVX_X86_64_MODULE: u32 = 1;
pub const CONFIG_TCG_TIS_SPI_MODULE: u32 = 1;
pub const CONFIG_MC3230_MODULE: u32 = 1;
pub const CONFIG_USB_PEGASUS_MODULE: u32 = 1;
pub const CONFIG_IIO_ST_MAGN_3AXIS_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_UC1701_MODULE: u32 = 1;
pub const CONFIG_HI8435_MODULE: u32 = 1;
pub const CONFIG_USB_TMC_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8962_MODULE: u32 = 1;
pub const CONFIG_NET_VRF_MODULE: u32 = 1;
pub const CONFIG_INPUT_E3X0_BUTTON_MODULE: u32 = 1;
pub const CONFIG_USB_G_WEBCAM_MODULE: u32 = 1;
pub const CONFIG_SBC_EPX_C3_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_ATM_HE_USE_SUNI: u32 = 1;
pub const CONFIG_PCIE_DW: u32 = 1;
pub const CONFIG_NET_DSA_SMSC_LAN9303_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_FD_MODULE: u32 = 1;
pub const CONFIG_LCD_HX8357_MODULE: u32 = 1;
pub const CONFIG_IPPP_FILTER: u32 = 1;
pub const CONFIG_V4L_PLATFORM_DRIVERS: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2408_READBACK: u32 = 1;
pub const CONFIG_EVM: u32 = 1;
pub const CONFIG_SND_PCSP_MODULE: u32 = 1;
pub const CONFIG_FB_NVIDIA_I2C: u32 = 1;
pub const CONFIG_RFKILL_INPUT: u32 = 1;
pub const CONFIG_COMEDI_NI_USB6501_MODULE: u32 = 1;
pub const CONFIG_BLK_MQ_RDMA: u32 = 1;
pub const CONFIG_RAPIDIO_MPORT_CDEV_MODULE: u32 = 1;
pub const CONFIG_FB_CIRRUS_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX20751_MODULE: u32 = 1;
pub const CONFIG_DEV_DAX_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_NATSEMI: u32 = 1;
pub const CONFIG_USB_MUSB_DUAL_ROLE: u32 = 1;
pub const CONFIG_BLK_DEV_BSGLIB: u32 = 1;
pub const CONFIG_NET_DSA_TAG_MTK: u32 = 1;
pub const CONFIG_GPIO_TPS68470: u32 = 1;
pub const CONFIG_ATH5K_PCI: u32 = 1;
pub const CONFIG_MEDIA_TUNER_FC2580_MODULE: u32 = 1;
pub const CONFIG_AQUANTIA_PHY_MODULE: u32 = 1;
pub const CONFIG_UNISYS_VISORINPUT_MODULE: u32 = 1;
pub const CONFIG_TABLET_USB_HANWANG_MODULE: u32 = 1;
pub const CONFIG_USB_F_MASS_STORAGE_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_AAT2870_MODULE: u32 = 1;
pub const CONFIG_MENF21BMC_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_ATH9K_COMMON_MODULE: u32 = 1;
pub const CONFIG_QTNFMAC_PEARL_PCIE_MODULE: u32 = 1;
pub const CONFIG_DVB_STB6000_MODULE: u32 = 1;
pub const CONFIG_SND_FIREWIRE_MOTU_MODULE: u32 = 1;
pub const CONFIG_COMEDI_MISC_DRIVERS: u32 = 1;
pub const CONFIG_USB_SERIAL_QCAUX_MODULE: u32 = 1;
pub const CONFIG_NFSD_BLOCKLAYOUT: u32 = 1;
pub const CONFIG_SATA_ACARD_AHCI_MODULE: u32 = 1;
pub const CONFIG_GENERIC_IRQ_MIGRATION: u32 = 1;
pub const CONFIG_NET_VENDOR_NETRONOME: u32 = 1;
pub const CONFIG_NFS_USE_KERNEL_DNS: u32 = 1;
pub const CONFIG_SENSORS_MAX31722_MODULE: u32 = 1;
pub const CONFIG_MISDN_SPEEDFAX_MODULE: u32 = 1;
pub const CONFIG_SENSORS_IBMAEM_MODULE: u32 = 1;
pub const CONFIG_DMA_ENGINE_RAID: u32 = 1;
pub const CONFIG_INTEL_MIC_HOST_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_FORTIFY_SOURCE: u32 = 1;
pub const CONFIG_LIRC_STAGING: u32 = 1;
pub const CONFIG_SND_HDA_I915: u32 = 1;
pub const CONFIG_QCOM_SPMI_VADC_MODULE: u32 = 1;
pub const CONFIG_LATTICE_ECP3_CONFIG_MODULE: u32 = 1;
pub const CONFIG_NFT_RT_MODULE: u32 = 1;
pub const CONFIG_SYSCTL: u32 = 1;
pub const CONFIG_CRYPTO_DES3_EDE_X86_64_MODULE: u32 = 1;
pub const CONFIG_842_DECOMPRESS_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_GCOV_PROFILE_ALL: u32 = 1;
pub const CONFIG_BRIDGE_IGMP_SNOOPING: u32 = 1;
pub const CONFIG_IP_NF_TARGET_CLUSTERIP_MODULE: u32 = 1;
pub const CONFIG_MTD_BLOCK2MTD_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_THERM_MODULE: u32 = 1;
pub const CONFIG_CAN_SLCAN_MODULE: u32 = 1;
pub const CONFIG_PARIDE_KBIC_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_TWIDJOY_MODULE: u32 = 1;
pub const CONFIG_PHYS_ADDR_T_64BIT: u32 = 1;
pub const CONFIG_COMEDI_DT2815_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_USA19QI: u32 = 1;
pub const CONFIG_SND_SOC_RT5663_MODULE: u32 = 1;
pub const CONFIG_THREAD_INFO_IN_TASK: u32 = 1;
pub const CONFIG_DVB_M88DS3103_MODULE: u32 = 1;
pub const CONFIG_NOZOMI_MODULE: u32 = 1;
pub const CONFIG_COMEDI_PCL711_MODULE: u32 = 1;
pub const CONFIG_USB_DWC3_ULPI: u32 = 1;
pub const CONFIG_MLX4_EN_DCB: u32 = 1;
pub const CONFIG_CRYPTO_842_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_AUDIT_MODULE: u32 = 1;
pub const CONFIG_VT6655_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_PIXCIR_MODULE: u32 = 1;
pub const CONFIG_HOSTAP_CS_MODULE: u32 = 1;
pub const CONFIG_WM831X_BACKUP_MODULE: u32 = 1;
pub const CONFIG_HAVE_C_RECORDMCOUNT: u32 = 1;
pub const CONFIG_GENERIC_MSI_IRQ: u32 = 1;
pub const CONFIG_SND_SOC_AMD_ACP_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ADCXX_MODULE: u32 = 1;
pub const CONFIG_SND_CS4281_MODULE: u32 = 1;
pub const CONFIG_COMEDI_8255_MODULE: u32 = 1;
pub const CONFIG_LCD_LD9040_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_MT2131_MODULE: u32 = 1;
pub const CONFIG_SENSORS_DELL_SMM_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_I40IW_MODULE: u32 = 1;
pub const CONFIG_HID_THINGM_MODULE: u32 = 1;
pub const CONFIG_USB_NET_KALMIA_MODULE: u32 = 1;
pub const CONFIG_IR_TTUSBIR_MODULE: u32 = 1;
pub const CONFIG_ATH6KL_SDIO_MODULE: u32 = 1;
pub const CONFIG_USB_NET_DM9601_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_TRACEHOOK: u32 = 1;
pub const CONFIG_SSB_PCIHOST: u32 = 1;
pub const CONFIG_RPMSG_CHAR_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_KBL_RT5663_MAX98927_MACH_MODULE: u32 = 1;
pub const CONFIG_WATCHDOG_PRETIMEOUT_GOV: u32 = 1;
pub const CONFIG_IR_MCEUSB_MODULE: u32 = 1;
pub const CONFIG_IIO_ST_ACCEL_I2C_3AXIS_MODULE: u32 = 1;
pub const CONFIG_LDM_PARTITION: u32 = 1;
pub const CONFIG_CIFS_MODULE: u32 = 1;
pub const CONFIG_DRM_FBDEV_OVERALLOC: u32 = 100;
pub const CONFIG_SMSC37B787_WDT_MODULE: u32 = 1;
pub const CONFIG_XFRM_USER_MODULE: u32 = 1;
pub const CONFIG_BMI160_I2C_MODULE: u32 = 1;
pub const CONFIG_HISAX_1TR6: u32 = 1;
pub const CONFIG_TCP_CONG_BIC_MODULE: u32 = 1;
pub const CONFIG_EXTCON_PALMAS_MODULE: u32 = 1;
pub const CONFIG_LEDS_PCA9532_MODULE: u32 = 1;
pub const CONFIG_TASK_DELAY_ACCT: u32 = 1;
pub const CONFIG_IR_IGORPLUGUSB_MODULE: u32 = 1;
pub const CONFIG_INPUT_PCF50633_PMU_MODULE: u32 = 1;
pub const CONFIG_INPUT_DA9063_ONKEY_MODULE: u32 = 1;
pub const CONFIG_SCSI_DH_EMC_MODULE: u32 = 1;
pub const CONFIG_EXTCON_USB_GPIO_MODULE: u32 = 1;
pub const CONFIG_NET_NS: u32 = 1;
pub const CONFIG_USB_ISP1760_DUAL_ROLE: u32 = 1;
pub const CONFIG_SENSORS_TMP401_MODULE: u32 = 1;
pub const CONFIG_XEN_BALLOON_MEMORY_HOTPLUG_LIMIT: u32 = 512;
pub const CONFIG_REGULATOR_MAX1586_MODULE: u32 = 1;
pub const CONFIG_REISERFS_FS_XATTR: u32 = 1;
pub const CONFIG_SENSORS_ADT7475_MODULE: u32 = 1;
pub const CONFIG_MEMORY: u32 = 1;
pub const CONFIG_HAVE_PERF_EVENTS: u32 = 1;
pub const CONFIG_PCMCIA_XIRCOM_MODULE: u32 = 1;
pub const CONFIG_COMEDI_II_PCI20KC_MODULE: u32 = 1;
pub const CONFIG_B53_SRAB_DRIVER_MODULE: u32 = 1;
pub const CONFIG_HISAX_SCT_QUADRO: u32 = 1;
pub const CONFIG_DVB_MANTIS_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LIS3_I2C_MODULE: u32 = 1;
pub const CONFIG_RT2800PCI_RT35XX: u32 = 1;
pub const CONFIG_MTD_NAND_GPIO_MODULE: u32 = 1;
pub const CONFIG_CAN_C_CAN_MODULE: u32 = 1;
pub const CONFIG_BTT: u32 = 1;
pub const CONFIG_ATA_SFF: u32 = 1;
pub const CONFIG_LEDS_MENF21BMC_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_WALKERA0701_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_LRW_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1685_FAMILY_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_WM8350_MODULE: u32 = 1;
pub const CONFIG_IWLWIFI_OPMODE_MODULAR: u32 = 1;
pub const CONFIG_NET_EMATCH_CMP_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_T613_MODULE: u32 = 1;
pub const CONFIG_MLXSW_SWITCHX2_MODULE: u32 = 1;
pub const CONFIG_SND_VIA82XX_MODEM_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_WM8580_MODULE: u32 = 1;
pub const CONFIG_SND_MTPAV_MODULE: u32 = 1;
pub const CONFIG_PPP_ASYNC_MODULE: u32 = 1;
pub const CONFIG_MD_RAID10_MODULE: u32 = 1;
pub const CONFIG_NFSD_SCSILAYOUT: u32 = 1;
pub const CONFIG_HAVE_ALIGNED_STRUCT_PAGE: u32 = 1;
pub const CONFIG_NO_BOOTMEM: u32 = 1;
pub const CONFIG_SSB_SDIOHOST_POSSIBLE: u32 = 1;
pub const CONFIG_SENSORS_APPLESMC_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_SOLARFLARE: u32 = 1;
pub const CONFIG_CAN_GW_MODULE: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_866_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ABITUGURU3_MODULE: u32 = 1;
pub const CONFIG_CRAMFS_MODULE: u32 = 1;
pub const CONFIG_RADIO_SAA7706H_MODULE: u32 = 1;
pub const CONFIG_SKGE_GENESIS: u32 = 1;
pub const CONFIG_WM831X_POWER_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_SUNRISEPOINT_MODULE: u32 = 1;
pub const CONFIG_LEDS_TRIGGER_TRANSIENT_MODULE: u32 = 1;
pub const CONFIG_CYCLADES_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_LM8323_MODULE: u32 = 1;
pub const CONFIG_STMMAC_ETH_MODULE: u32 = 1;
pub const CONFIG_CHELSIO_T1_MODULE: u32 = 1;
pub const CONFIG_PCIE_DW_PLAT: u32 = 1;
pub const CONFIG_COMEDI_AIO_AIO12_8_MODULE: u32 = 1;
pub const CONFIG_NFSD_V4_SECURITY_LABEL: u32 = 1;
pub const CONFIG_QCOM_HIDMA_MGMT_MODULE: u32 = 1;
pub const CONFIG_CEPH_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_BLK_DEV_PMEM_MODULE: u32 = 1;
pub const CONFIG_AUDIT: u32 = 1;
pub const CONFIG_CHR_DEV_ST_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_TPS65910_MODULE: u32 = 1;
pub const CONFIG_BATTERY_RT5033_MODULE: u32 = 1;
pub const CONFIG_BCH_MODULE: u32 = 1;
pub const CONFIG_INTEL_IOMMU: u32 = 1;
pub const CONFIG_DVB_GP8PSK_FE_MODULE: u32 = 1;
pub const CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE: u32 = 1;
pub const CONFIG_DM_MULTIPATH_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_USER_API_SKCIPHER_MODULE: u32 = 1;
pub const CONFIG_SCSI_3W_SAS_MODULE: u32 = 1;
pub const CONFIG_BPF_JIT_ALWAYS_ON: u32 = 1;
pub const CONFIG_COMEDI_NI_ATMIO16D_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MC13892_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LM80_MODULE: u32 = 1;
pub const CONFIG_CMA_AREAS: u32 = 7;
pub const CONFIG_PCI_HYPERV_MODULE: u32 = 1;
pub const CONFIG_PCIEASPM: u32 = 1;
pub const CONFIG_PM_ADVANCED_DEBUG: u32 = 1;
pub const CONFIG_TSL2x7x_MODULE: u32 = 1;
pub const CONFIG_INTEL_IDMA64_MODULE: u32 = 1;
pub const CONFIG_VME_TSI148_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT5514_MODULE: u32 = 1;
pub const CONFIG_ATA_PIIX: u32 = 1;
pub const CONFIG_ARM_GIC_MAX_NR: u32 = 1;
pub const CONFIG_B43LEGACY_MODULE: u32 = 1;
pub const CONFIG_AIC7XXX_REG_PRETTY_PRINT: u32 = 1;
pub const CONFIG_HID_MULTITOUCH_MODULE: u32 = 1;
pub const CONFIG_ISDN_HDLC_MODULE: u32 = 1;
pub const CONFIG_ECRYPT_FS_MESSAGING: u32 = 1;
pub const CONFIG_FB_DEFERRED_IO: u32 = 1;
pub const CONFIG_SATA_AHCI_MODULE: u32 = 1;
pub const CONFIG_COMEDI_MITE_MODULE: u32 = 1;
pub const CONFIG_SLAB_FREELIST_RANDOM: u32 = 1;
pub const CONFIG_DVB_USB_A800_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_CHT_BSW_RT5645_MACH_MODULE: u32 = 1;
pub const CONFIG_XEN_BALLOON_MEMORY_HOTPLUG: u32 = 1;
pub const CONFIG_SECURITY: u32 = 1;
pub const CONFIG_I2C_SI470X_MODULE: u32 = 1;
pub const CONFIG_DVB_A8293_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ASC7621_MODULE: u32 = 1;
pub const CONFIG_OPTPROBES: u32 = 1;
pub const CONFIG_USB_AMD5536UDC_MODULE: u32 = 1;
pub const CONFIG_CHARGER_BQ2415X_MODULE: u32 = 1;
pub const CONFIG_HISAX_NETJET_U: u32 = 1;
pub const CONFIG_NETXEN_NIC_MODULE: u32 = 1;
pub const CONFIG_BNX2X_SRIOV: u32 = 1;
pub const CONFIG_ACPI_NUMA: u32 = 1;
pub const CONFIG_ATM_TCP_MODULE: u32 = 1;
pub const CONFIG_USB_GR_UDC_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_ISL9305_MODULE: u32 = 1;
pub const CONFIG_HID_ELECOM_MODULE: u32 = 1;
pub const CONFIG_FB_TFT_PCD8544_MODULE: u32 = 1;
pub const CONFIG_SND_TIMER_MODULE: u32 = 1;
pub const CONFIG_COMEDI_ICP_MULTI_MODULE: u32 = 1;
pub const CONFIG_BATTERY_DA9150_MODULE: u32 = 1;
pub const CONFIG_KVM_MMIO: u32 = 1;
pub const CONFIG_USB_EHCI_TT_NEWSCHED: u32 = 1;
pub const CONFIG_FAT_DEFAULT_CODEPAGE: u32 = 437;
pub const CONFIG_TCM_FC_MODULE: u32 = 1;
pub const CONFIG_IPV6_MROUTE_MULTIPLE_TABLES: u32 = 1;
pub const CONFIG_BLK_DEV: u32 = 1;
pub const CONFIG_SND_SOC_TLV320AIC31XX_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_PCM179X_SPI_MODULE: u32 = 1;
pub const CONFIG_SERIO_I8042: u32 = 1;
pub const CONFIG_MAC80211_RC_DEFAULT: &'static [u8; 12usize] = b"minstrel_ht\0";
pub const CONFIG_NIC7018_WDT_MODULE: u32 = 1;
pub const CONFIG_FARSYNC_MODULE: u32 = 1;
pub const CONFIG_RTL8187_LEDS: u32 = 1;
pub const CONFIG_NFS_ACL_SUPPORT_MODULE: u32 = 1;
pub const CONFIG_RT2800USB_RT55XX: u32 = 1;
pub const CONFIG_W1_SLAVE_DS2433_MODULE: u32 = 1;
pub const CONFIG_CHROME_PLATFORMS: u32 = 1;
pub const CONFIG_ATL1_MODULE: u32 = 1;
pub const CONFIG_APPLICOM_MODULE: u32 = 1;
pub const CONFIG_HISAX_NI1: u32 = 1;
pub const CONFIG_USB_SERIAL_OMNINET_MODULE: u32 = 1;
pub const CONFIG_HDLC_PPP_MODULE: u32 = 1;
pub const CONFIG_X86_AMD_PLATFORM_DEVICE: u32 = 1;
pub const CONFIG_BRIDGE_NETFILTER_MODULE: u32 = 1;
pub const CONFIG_TCP_CONG_SCALABLE_MODULE: u32 = 1;
pub const CONFIG_DVB_MB86A20S_MODULE: u32 = 1;
pub const CONFIG_PATA_TRIFLEX_MODULE: u32 = 1;
pub const CONFIG_COMEDI_PCL818_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_TMDC_MODULE: u32 = 1;
pub const CONFIG_MCP4922_MODULE: u32 = 1;
pub const CONFIG_SERIAL_ALTERA_UART_MAXPORTS: u32 = 4;
pub const CONFIG_SND_SYNTH_EMUX_MODULE: u32 = 1;
pub const CONFIG_IOMMU_API: u32 = 1;
pub const CONFIG_GPIO_GENERIC_MODULE: u32 = 1;
pub const CONFIG_TRACING_SUPPORT: u32 = 1;
pub const CONFIG_UNIX98_PTYS: u32 = 1;
pub const CONFIG_CDROM_PKTCDVD_MODULE: u32 = 1;
pub const CONFIG_MS_BLOCK_MODULE: u32 = 1;
pub const CONFIG_VFIO_MODULE: u32 = 1;
pub const CONFIG_NFC_MICROREAD_MEI_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_CONNMARK_MODULE: u32 = 1;
pub const CONFIG_MINIX_SUBPARTITION: u32 = 1;
pub const CONFIG_CHROMEOS_PSTORE_MODULE: u32 = 1;
pub const CONFIG_NET_RX_BUSY_POLL: u32 = 1;
pub const CONFIG_RADIO_WL1273_MODULE: u32 = 1;
pub const CONFIG_SENSORS_SMSC47B397_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_MICHAEL_MIC_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_SOCIONEXT: u32 = 1;
pub const CONFIG_CRYPTO_ANSI_CPRNG_MODULE: u32 = 1;
pub const CONFIG_SECURITY_SELINUX: u32 = 1;
pub const CONFIG_ZONE_DMA32: u32 = 1;
pub const CONFIG_NET_SCHED: u32 = 1;
pub const CONFIG_LCD_LMS501KF03_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_TPS65086_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_CONNSECMARK_MODULE: u32 = 1;
pub const CONFIG_UWB_I1480U_MODULE: u32 = 1;
pub const CONFIG_COMEDI_PCL726_MODULE: u32 = 1;
pub const CONFIG_LIQUIDIO_MODULE: u32 = 1;
pub const CONFIG_STAGING_MEDIA: u32 = 1;
pub const CONFIG_NVME_RDMA_MODULE: u32 = 1;
pub const CONFIG_DRM_PANEL: u32 = 1;
pub const CONFIG_DVB_PLL_MODULE: u32 = 1;
pub const CONFIG_PRINTK_TIME: u32 = 1;
pub const CONFIG_PANEL_MODULE: u32 = 1;
pub const CONFIG_SERIAL_JSM_MODULE: u32 = 1;
pub const CONFIG_VIDEO_VIVID_MAX_DEVS: u32 = 64;
pub const CONFIG_INPUT_MOUSEDEV_SCREEN_Y: u32 = 768;
pub const CONFIG_SECCOMP_FILTER: u32 = 1;
pub const CONFIG_PATA_HPT37X_MODULE: u32 = 1;
pub const CONFIG_MPU3050_MODULE: u32 = 1;
pub const CONFIG_MLXSW_SWITCHIB_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SST_FIRMWARE_MODULE: u32 = 1;
pub const CONFIG_UIO_PCI_GENERIC_MODULE: u32 = 1;
pub const CONFIG_PPP: u32 = 1;
pub const CONFIG_RFD_FTL_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_QUOTA_MODULE: u32 = 1;
pub const CONFIG_TI_ST_MODULE: u32 = 1;
pub const CONFIG_ARCH_MAY_HAVE_PC_FDC: u32 = 1;
pub const CONFIG_NET_SCH_PIE_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_ATMEL_MXT_MODULE: u32 = 1;
pub const CONFIG_NFT_FIB_IPV4_MODULE: u32 = 1;
pub const CONFIG_HAVE_KERNEL_LZO: u32 = 1;
pub const CONFIG_ASYNC_CORE_MODULE: u32 = 1;
pub const CONFIG_INTEL_PMC_CORE: u32 = 1;
pub const CONFIG_NET_SCH_MULTIQ_MODULE: u32 = 1;
pub const CONFIG_INET_DIAG_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_GHASH: u32 = 1;
pub const CONFIG_OCFS2_DEBUG_MASKLOG: u32 = 1;
pub const CONFIG_SND_SOC_WM8741_MODULE: u32 = 1;
pub const CONFIG_SYNCLINKMP_MODULE: u32 = 1;
pub const CONFIG_PSTORE: u32 = 1;
pub const CONFIG_OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW: u32 = 1;
pub const CONFIG_SCSI_LPFC_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS53L30_MODULE: u32 = 1;
pub const CONFIG_NFC_ST95HF_MODULE: u32 = 1;
pub const CONFIG_NF_NAT_FTP_MODULE: u32 = 1;
pub const CONFIG_MAC80211_RC_MINSTREL: u32 = 1;
pub const CONFIG_CRYPTO_RMD320_MODULE: u32 = 1;
pub const CONFIG_IIO_CONSUMERS_PER_TRIGGER: u32 = 2;
pub const CONFIG_NF_CT_PROTO_UDPLITE: u32 = 1;
pub const CONFIG_VIRTIO_BLK_SCSI: u32 = 1;
pub const CONFIG_CARDMAN_4000_MODULE: u32 = 1;
pub const CONFIG_IO_DELAY_TYPE_UDELAY: u32 = 2;
pub const CONFIG_SPEAKUP_MODULE: u32 = 1;
pub const CONFIG_IP6_NF_TARGET_SYNPROXY_MODULE: u32 = 1;
pub const CONFIG_HANGCHECK_TIMER_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_WARRIOR_MODULE: u32 = 1;
pub const CONFIG_COMEDI_AIO_IIRO_16_MODULE: u32 = 1;
pub const CONFIG_SENSORS_W83627EHF_MODULE: u32 = 1;
pub const CONFIG_ELF_CORE: u32 = 1;
pub const CONFIG_DEV_COREDUMP: u32 = 1;
pub const CONFIG_NOTIFIER_ERROR_INJECTION_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LM73_MODULE: u32 = 1;
pub const CONFIG_VIA_VELOCITY_MODULE: u32 = 1;
pub const CONFIG_SENSORS_PC87360_MODULE: u32 = 1;
pub const CONFIG_TEXTSEARCH: u32 = 1;
pub const CONFIG_DRM_AMDGPU_USERPTR: u32 = 1;
pub const CONFIG_VIDEO_IVTV_MODULE: u32 = 1;
pub const CONFIG_ACPI_DOCK: u32 = 1;
pub const CONFIG_TEST_STATIC_KEYS_MODULE: u32 = 1;
pub const CONFIG_USB_DWC3_MODULE: u32 = 1;
pub const CONFIG_KS8851_MODULE: u32 = 1;
pub const CONFIG_XEN_HAVE_PVMMU: u32 = 1;
pub const CONFIG_MTD_JEDECPROBE_MODULE: u32 = 1;
pub const CONFIG_TSYS01_MODULE: u32 = 1;
pub const CONFIG_NF_CT_NETLINK_HELPER_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_ON_DEMAND_PAGING: u32 = 1;
pub const CONFIG_INA2XX_ADC_MODULE: u32 = 1;
pub const CONFIG_EFI_TEST_MODULE: u32 = 1;
pub const CONFIG_MTD_ONENAND_VERIFY_WRITE: u32 = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_USA19QW: u32 = 1;
pub const CONFIG_INPUT_PCF8574_MODULE: u32 = 1;
pub const CONFIG_HDM_USB_MODULE: u32 = 1;
pub const CONFIG_SOC_CAMERA_OV9640_MODULE: u32 = 1;
pub const CONFIG_USB_SUPPORT: u32 = 1;
pub const CONFIG_SOFT_WATCHDOG_PRETIMEOUT: u32 = 1;
pub const CONFIG_NVME_TARGET_MODULE: u32 = 1;
pub const CONFIG_I2C_SCMI_MODULE: u32 = 1;
pub const CONFIG_I2C_VIA_MODULE: u32 = 1;
pub const CONFIG_BMC150_MAGN_SPI_MODULE: u32 = 1;
pub const CONFIG_INPUT_POLLDEV_MODULE: u32 = 1;
pub const CONFIG_INPUT_MAX8925_ONKEY_MODULE: u32 = 1;
pub const CONFIG_VIRTIO_MMIO_CMDLINE_DEVICES: u32 = 1;
pub const CONFIG_SND_INTEL8X0M_MODULE: u32 = 1;
pub const CONFIG_ACPI_DEBUG: u32 = 1;
pub const CONFIG_MODIFY_LDT_SYSCALL: u32 = 1;
pub const CONFIG_SENSORS_ADC128D818_MODULE: u32 = 1;
pub const CONFIG_KEMPLD_WDT_MODULE: u32 = 1;
pub const CONFIG_SURFACE3_WMI_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_BQ32K_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_PAC7311_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ST: u32 = 1;
pub const CONFIG_REGMAP_HWSPINLOCK: u32 = 1;
pub const CONFIG_COMEDI_PCMAD_MODULE: u32 = 1;
pub const CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS: u32 = 1;
pub const CONFIG_VIA_WDT_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_NVME_MODULE: u32 = 1;
pub const CONFIG_BRCMFMAC_PROTO_BCDC: u32 = 1;
pub const CONFIG_TWL4030_CORE: u32 = 1;
pub const CONFIG_USB_HWA_HCD_MODULE: u32 = 1;
pub const CONFIG_SPI_ZYNQMP_GQSPI_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_EASYTOUCH: u32 = 1;
pub const CONFIG_LEDS_LP8860_MODULE: u32 = 1;
pub const CONFIG_STAGING: u32 = 1;
pub const CONFIG_NET_VENDOR_SIS: u32 = 1;
pub const CONFIG_F2FS_FS_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_EDT_FT5X06_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RL6347A_MODULE: u32 = 1;
pub const CONFIG_FB_RIVA_I2C: u32 = 1;
pub const CONFIG_SENSORS_LIS3LV02D_MODULE: u32 = 1;
pub const CONFIG_EXTCON_MAX14577_MODULE: u32 = 1;
pub const CONFIG_AD9523_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_RT5645_MODULE: u32 = 1;
pub const CONFIG_FIREWIRE_MODULE: u32 = 1;
pub const CONFIG_WIZNET_W5100_SPI_MODULE: u32 = 1;
pub const CONFIG_ATM_MODULE: u32 = 1;
pub const CONFIG_MMIOTRACE: u32 = 1;
pub const CONFIG_MAX63XX_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_ST1232_MODULE: u32 = 1;
pub const CONFIG_SCSI_FC_ATTRS_MODULE: u32 = 1;
pub const CONFIG_VT_CONSOLE: u32 = 1;
pub const CONFIG_EDAC_SBRIDGE_MODULE: u32 = 1;
pub const CONFIG_HID_UCLOGIC_MODULE: u32 = 1;
pub const CONFIG_VFIO_MDEV_MODULE: u32 = 1;
pub const CONFIG_HW_RANDOM_VIRTIO_MODULE: u32 = 1;
pub const CONFIG_COMEDI_PCMCIA_DRIVERS_MODULE: u32 = 1;
pub const CONFIG_ACPI_APEI: u32 = 1;
pub const CONFIG_SND_ES1968_RADIO: u32 = 1;
pub const CONFIG_LEDS_GPIO_MODULE: u32 = 1;
pub const CONFIG_SND_SB_COMMON_MODULE: u32 = 1;
pub const CONFIG_LED_TRIGGER_PHY: u32 = 1;
pub const CONFIG_CFG80211_WEXT_EXPORT: u32 = 1;
pub const CONFIG_SND_CS46XX_MODULE: u32 = 1;
pub const CONFIG_SCHED_INFO: u32 = 1;
pub const CONFIG_USB_GSPCA_STK014_MODULE: u32 = 1;
pub const CONFIG_ACPI_DEBUGGER: u32 = 1;
pub const CONFIG_MQ_IOSCHED_KYBER_MODULE: u32 = 1;
pub const CONFIG_IP_VS_FTP_MODULE: u32 = 1;
pub const CONFIG_FANOTIFY_ACCESS_PERMISSIONS: u32 = 1;
pub const CONFIG_SENSORS_LM3533_MODULE: u32 = 1;
pub const CONFIG_IIO_ST_PRESS_I2C_MODULE: u32 = 1;
pub const CONFIG_STM_SOURCE_FTRACE_MODULE: u32 = 1;
pub const CONFIG_VIDEO_CX18_MODULE: u32 = 1;
pub const CONFIG_XILINX_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_VMWARE_PVSCSI_MODULE: u32 = 1;
pub const CONFIG_CFG80211_WEXT: u32 = 1;
pub const CONFIG_VIRTIO_VSOCKETS_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_MARVELL: u32 = 1;
pub const CONFIG_SERIAL_SCCNXP_CONSOLE: u32 = 1;
pub const CONFIG_HISAX_EURO: u32 = 1;
pub const CONFIG_SMARTJOYPLUS_FF: u32 = 1;
pub const CONFIG_SND_SOC_XTFPGA_I2S_MODULE: u32 = 1;
pub const CONFIG_I2C_PARPORT_MODULE: u32 = 1;
pub const CONFIG_ISDN_DIVAS_BRIPCI: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_PHYSDEV_MODULE: u32 = 1;
pub const CONFIG_NOP_USB_XCEIV_MODULE: u32 = 1;
pub const CONFIG_GPIO_DA9052_MODULE: u32 = 1;
pub const CONFIG_BRCMFMAC_PCIE: u32 = 1;
pub const CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE: u32 = 1;
pub const CONFIG_EXTCON_MAX77843_MODULE: u32 = 1;
pub const CONFIG_SND_VIA82XX_MODULE: u32 = 1;
pub const CONFIG_ISDN_DIVAS_MODULE: u32 = 1;
pub const CONFIG_CC10001_ADC_MODULE: u32 = 1;
pub const CONFIG_NFC_PN533_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_ANATOP_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_DIBUSB_MB_MODULE: u32 = 1;
pub const CONFIG_TWL6030_GPADC_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_GPIO_MODULE: u32 = 1;
pub const CONFIG_SND_DARLA20_MODULE: u32 = 1;
pub const CONFIG_MFD_MAX77843: u32 = 1;
pub const CONFIG_SND_SEQ_MIDI_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_RAM_MODULE: u32 = 1;
pub const CONFIG_USB_F_NCM_MODULE: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_COMPAT_BITS: u32 = 8;
pub const CONFIG_TOUCHSCREEN_AD7879_MODULE: u32 = 1;
pub const CONFIG_MMA9553_MODULE: u32 = 1;
pub const CONFIG_SENSORS_HDAPS_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_STATE_MODULE: u32 = 1;
pub const CONFIG_DVB_L64781_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_RM_TS_MODULE: u32 = 1;
pub const CONFIG_INPUT_EVBUG_MODULE: u32 = 1;
pub const CONFIG_IEEE802154_AT86RF230_DEBUGFS: u32 = 1;
pub const CONFIG_LOGIRUMBLEPAD2_FF: u32 = 1;
pub const CONFIG_SND_INDIGOIOX_MODULE: u32 = 1;
pub const CONFIG_MFD_TPS6586X: u32 = 1;
pub const CONFIG_SND_ASIHPI_MODULE: u32 = 1;
pub const CONFIG_BSD_DISKLABEL: u32 = 1;
pub const CONFIG_RTC_DRV_M48T35_MODULE: u32 = 1;
pub const CONFIG_I2C_TAOS_EVM_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_CAST_COMMON_MODULE: u32 = 1;
pub const CONFIG_IIO_TRIGGERED_BUFFER_MODULE: u32 = 1;
pub const CONFIG_COMEDI_KCOMEDILIB_MODULE: u32 = 1;
pub const CONFIG_FB_HGA_MODULE: u32 = 1;
pub const CONFIG_XEN_PVH: u32 = 1;
pub const CONFIG_RTC_DRV_PCF2127_MODULE: u32 = 1;
pub const CONFIG_USB_STORAGE_FREECOM_MODULE: u32 = 1;
pub const CONFIG_LCD_VGG2432A4_MODULE: u32 = 1;
pub const CONFIG_MFD_TPS65086_MODULE: u32 = 1;
pub const CONFIG_SCSI_BUSLOGIC_MODULE: u32 = 1;
pub const CONFIG_BRIDGE_EBT_LOG_MODULE: u32 = 1;
pub const CONFIG_MICROCHIP_PHY_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_ADS7846_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_CARILLO_RANCH_MODULE: u32 = 1;
pub const CONFIG_OPENVSWITCH_VXLAN_MODULE: u32 = 1;
pub const CONFIG_FONT_6x10: u32 = 1;
pub const CONFIG_GADGET_UAC1: u32 = 1;
pub const CONFIG_IR_RC5_DECODER_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_S5M8767_MODULE: u32 = 1;
pub const CONFIG_FIREWIRE_NOSY_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_GRED_MODULE: u32 = 1;
pub const CONFIG_PCI_DIRECT: u32 = 1;
pub const CONFIG_MMC_VIA_SDMMC_MODULE: u32 = 1;
pub const CONFIG_DRM_MODULE: u32 = 1;
pub const CONFIG_FUSION_MAX_SGE: u32 = 128;
pub const CONFIG_RTC_DRV_DA9055_MODULE: u32 = 1;
pub const CONFIG_DOUBLEFAULT: u32 = 1;
pub const CONFIG_INET6_XFRM_MODE_BEET_MODULE: u32 = 1;
pub const CONFIG_AD7150_MODULE: u32 = 1;
pub const CONFIG_MEDIA_RADIO_SUPPORT: u32 = 1;
pub const CONFIG_PCF50633_GPIO_MODULE: u32 = 1;
pub const CONFIG_IWL4965_MODULE: u32 = 1;
pub const CONFIG_PCIE_DPC: u32 = 1;
pub const CONFIG_POSIX_MQUEUE_SYSCTL: u32 = 1;
pub const CONFIG_RTC_DRV_MAX6900_MODULE: u32 = 1;
pub const CONFIG_ICS932S401_MODULE: u32 = 1;
pub const CONFIG_RIONET_TX_SIZE: u32 = 128;
pub const CONFIG_XILINX_GMII2RGMII_MODULE: u32 = 1;
pub const CONFIG_UNUSED_SYMBOLS: u32 = 1;
pub const CONFIG_SENSORS_MAX1111_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_DEV_PADLOCK_AES_MODULE: u32 = 1;
pub const CONFIG_INTEL_TH_STH_MODULE: u32 = 1;
pub const CONFIG_ISDN_DRV_AVMB1_B1PCIV4: u32 = 1;
pub const CONFIG_SAMSUNG_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_BE2NET_HWMON: u32 = 1;
pub const CONFIG_USB_USS720_MODULE: u32 = 1;
pub const CONFIG_LEDS_DAC124S085_MODULE: u32 = 1;
pub const CONFIG_FB_CFB_COPYAREA: u32 = 1;
pub const CONFIG_USB_F_ECM_MODULE: u32 = 1;
pub const CONFIG_GPIO_IT87_MODULE: u32 = 1;
pub const CONFIG_FB_EFI: u32 = 1;
pub const CONFIG_MOUSE_GPIO_MODULE: u32 = 1;
pub const CONFIG_USB_SISUSBVGA_MODULE: u32 = 1;
pub const CONFIG_DVB_RTL2830_MODULE: u32 = 1;
pub const CONFIG_I40E_MODULE: u32 = 1;
pub const CONFIG_HAVE_KVM_IRQCHIP: u32 = 1;
pub const CONFIG_BRIDGE_EBT_STP_MODULE: u32 = 1;
pub const CONFIG_RT73USB_MODULE: u32 = 1;
pub const CONFIG_USB_ULPI_BUS_MODULE: u32 = 1;
pub const CONFIG_DE2104X_DSL: u32 = 0;
pub const CONFIG_BRIDGE_EBT_ARP_MODULE: u32 = 1;
pub const CONFIG_BALLOON_COMPACTION: u32 = 1;
pub const CONFIG_BMC150_ACCEL_I2C_MODULE: u32 = 1;
pub const CONFIG_MANDATORY_FILE_LOCKING: u32 = 1;
pub const CONFIG_CHARGER_MAX8997_MODULE: u32 = 1;
pub const CONFIG_USB_CYTHERM_MODULE: u32 = 1;
pub const CONFIG_MFD_TWL4030_AUDIO: u32 = 1;
pub const CONFIG_HX711_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_MSM8916_WCD_ANALOG_MODULE: u32 = 1;
pub const CONFIG_IP6_NF_MATCH_EUI64_MODULE: u32 = 1;
pub const CONFIG_BINARY_PRINTF: u32 = 1;
pub const CONFIG_MWIFIEX_MODULE: u32 = 1;
pub const CONFIG_HP_ILO_MODULE: u32 = 1;
pub const CONFIG_SATA_DWC_OLD_DMA: u32 = 1;
pub const CONFIG_USB_STORAGE_JUMPSHOT_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX6642_MODULE: u32 = 1;
pub const CONFIG_GPIO_MC33880_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SGTL5000_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_PLUG_MODULE: u32 = 1;
pub const CONFIG_SND_GINA20_MODULE: u32 = 1;
pub const CONFIG_ACPI_REV_OVERRIDE_POSSIBLE: u32 = 1;
pub const CONFIG_HARDLOCKUP_CHECK_TIMESTAMP: u32 = 1;
pub const CONFIG_TRACER_MAX_TRACE: u32 = 1;
pub const CONFIG_ZSTD_DECOMPRESS: u32 = 1;
pub const CONFIG_USB_KEENE_MODULE: u32 = 1;
pub const CONFIG_VIDEOBUF_GEN_MODULE: u32 = 1;
pub const CONFIG_MTD_CFI_AMDSTD_MODULE: u32 = 1;
pub const CONFIG_LEDS_WM831X_STATUS_MODULE: u32 = 1;
pub const CONFIG_CLK_TWL6040_MODULE: u32 = 1;
pub const CONFIG_SGI_PARTITION: u32 = 1;
pub const CONFIG_INPUT_SPARSEKMAP_MODULE: u32 = 1;
pub const CONFIG_GPIO_PALMAS: u32 = 1;
pub const CONFIG_NF_LOG_NETDEV_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_TWOFISH_X86_64_3WAY_MODULE: u32 = 1;
pub const CONFIG_HIO_MODULE: u32 = 1;
pub const CONFIG_ADIS16400_MODULE: u32 = 1;
pub const CONFIG_AIC7XXX_CMDS_PER_DEVICE: u32 = 8;
pub const CONFIG_SYSFS_SYSCALL: u32 = 1;
pub const CONFIG_WLAN_VENDOR_QUANTENNA: u32 = 1;
pub const CONFIG_RTL8192EE_MODULE: u32 = 1;
pub const CONFIG_SECURITY_INFINIBAND: u32 = 1;
pub const CONFIG_TCG_XEN_MODULE: u32 = 1;
pub const CONFIG_VIDEO_V4L2_MODULE: u32 = 1;
pub const CONFIG_SND_PCM_TIMER: u32 = 1;
pub const CONFIG_DVB_STV6110_MODULE: u32 = 1;
pub const CONFIG_MPL115_I2C_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1685: u32 = 1;
pub const CONFIG_AC97_BUS_MODULE: u32 = 1;
pub const CONFIG_CW1200_MODULE: u32 = 1;
pub const CONFIG_SYSVIPC_SYSCTL: u32 = 1;
pub const CONFIG_SND_FIREWORKS_MODULE: u32 = 1;
pub const CONFIG_QEDI_MODULE: u32 = 1;
pub const CONFIG_NVME_FABRICS_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_TI: u32 = 1;
pub const CONFIG_ADE7753_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_USA19: u32 = 1;
pub const CONFIG_HID_NTRIG_MODULE: u32 = 1;
pub const CONFIG_IP_VS_IPV6: u32 = 1;
pub const CONFIG_X86_64_ACPI_NUMA: u32 = 1;
pub const CONFIG_DMA_SHARED_BUFFER: u32 = 1;
pub const CONFIG_RTC_SYSTOHC: u32 = 1;
pub const CONFIG_DVB_USB_NOVA_T_USB2_MODULE: u32 = 1;
pub const CONFIG_VHOST_SCSI_MODULE: u32 = 1;
pub const CONFIG_CIFS_POSIX: u32 = 1;
pub const CONFIG_AMD_XGBE_HAVE_ECC: u32 = 1;
pub const CONFIG_PATA_RDC_MODULE: u32 = 1;
pub const CONFIG_SND_PORTMAN2X4_MODULE: u32 = 1;
pub const CONFIG_USB_EPSON2888: u32 = 1;
pub const CONFIG_AF_RXRPC_IPV6: u32 = 1;
pub const CONFIG_TOUCHSCREEN_ZET6223_MODULE: u32 = 1;
pub const CONFIG_SND_INDIGODJ_MODULE: u32 = 1;
pub const CONFIG_SENSORS_W83L785TS_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_MXUPORT_MODULE: u32 = 1;
pub const CONFIG_W1_SLAVE_DS28E04_MODULE: u32 = 1;
pub const CONFIG_DECOMPRESS_GZIP: u32 = 1;
pub const CONFIG_SND_AW2_MODULE: u32 = 1;
pub const CONFIG_SENSORS_EMC2103_MODULE: u32 = 1;
pub const CONFIG_NLS_MAC_CELTIC_MODULE: u32 = 1;
pub const CONFIG_SND_AU8830_MODULE: u32 = 1;
pub const CONFIG_SPI_SC18IS602_MODULE: u32 = 1;
pub const CONFIG_RTLLIB_CRYPTO_WEP_MODULE: u32 = 1;
pub const CONFIG_THERMAL_GOV_POWER_ALLOCATOR: u32 = 1;
pub const CONFIG_VIRTIO_BLK_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_CS_MODULE: u32 = 1;
pub const CONFIG_DECOMPRESS_LZO: u32 = 1;
pub const CONFIG_USB_SERIAL_ARK3116_MODULE: u32 = 1;
pub const CONFIG_64BIT: u32 = 1;
pub const CONFIG_SND_MIXART_MODULE: u32 = 1;
pub const CONFIG_QUOTA: u32 = 1;
pub const CONFIG_SND_BT87X_MODULE: u32 = 1;
pub const CONFIG_IIO_CROS_EC_SENSORS_CORE_MODULE: u32 = 1;
pub const CONFIG_SENSORS_WM8350_MODULE: u32 = 1;
pub const CONFIG_EARLY_PRINTK_EFI: u32 = 1;
pub const CONFIG_DM9102_MODULE: u32 = 1;
pub const CONFIG_COMEDI_NI_MIO_CS_MODULE: u32 = 1;
pub const CONFIG_SENSORS_LINEAGE_MODULE: u32 = 1;
pub const CONFIG_CAN_EMS_PCMCIA_MODULE: u32 = 1;
pub const CONFIG_SCSI_MPT2SAS_MAX_SGE: u32 = 128;
pub const CONFIG_VXGE_MODULE: u32 = 1;
pub const CONFIG_PARIDE_PCD_MODULE: u32 = 1;
pub const CONFIG_ZBUD: u32 = 1;
pub const CONFIG_MMC_SDHCI_PLTFM_MODULE: u32 = 1;
pub const CONFIG_I2C_CHARDEV: u32 = 1;
pub const CONFIG_MEDIA_TUNER_FC0013_MODULE: u32 = 1;
pub const CONFIG_LLC_MODULE: u32 = 1;
pub const CONFIG_MTD_NAND_NANDSIM_MODULE: u32 = 1;
pub const CONFIG_CROSS_COMPILE: &'static [u8; 1usize] = b"\0";
pub const CONFIG_FMC_FAKEDEV_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MAX8649_MODULE: u32 = 1;
pub const CONFIG_ARCH_USE_QUEUED_RWLOCKS: u32 = 1;
pub const CONFIG_GENWQE_MODULE: u32 = 1;
pub const CONFIG_MEDIA_TUNER_TEA5761_MODULE: u32 = 1;
pub const CONFIG_MFD_MC13XXX_SPI_MODULE: u32 = 1;
pub const CONFIG_SC92031_MODULE: u32 = 1;
pub const CONFIG_REGMAP_MMIO: u32 = 1;
pub const CONFIG_ARCH_HAS_PKEYS: u32 = 1;
pub const CONFIG_NFT_REDIR_IPV4_MODULE: u32 = 1;
pub const CONFIG_SND_TRIDENT_MODULE: u32 = 1;
pub const CONFIG_MICROCHIP_KSZ_MODULE: u32 = 1;
pub const CONFIG_INTEL_HID_EVENT_MODULE: u32 = 1;
pub const CONFIG_GPIO_MB86S7X_MODULE: u32 = 1;
pub const CONFIG_NETWORK_SECMARK: u32 = 1;
pub const CONFIG_SND_RIPTIDE_MODULE: u32 = 1;
pub const CONFIG_SND_CTXFI_MODULE: u32 = 1;
pub const CONFIG_GENERIC_CLOCKEVENTS_BROADCAST: u32 = 1;
pub const CONFIG_VIDEO_TVAUDIO_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MAX8907_MODULE: u32 = 1;
pub const CONFIG_RXKAD: u32 = 1;
pub const CONFIG_CRYPTO_SIMD_MODULE: u32 = 1;
pub const CONFIG_HID_HOLTEK_MODULE: u32 = 1;
pub const CONFIG_MTD_GPIO_ADDR_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_SAMSUNG_MODULE: u32 = 1;
pub const CONFIG_ARCH_RANDOM: u32 = 1;
pub const CONFIG_SERIAL_8250_PCI: u32 = 1;
pub const CONFIG_LIB80211_CRYPT_CCMP_MODULE: u32 = 1;
pub const CONFIG_HAVE_MIXED_BREAKPOINTS_REGS: u32 = 1;
pub const CONFIG_USB_GSPCA_DTCS033_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1672_MODULE: u32 = 1;
pub const CONFIG_INTEL_MEI_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_SSU100_MODULE: u32 = 1;
pub const CONFIG_BATMAN_ADV_DAT: u32 = 1;
pub const CONFIG_MOUSE_PS2_SYNAPTICS: u32 = 1;
pub const CONFIG_DVB_USB_DIB3000MC_MODULE: u32 = 1;
pub const CONFIG_ATA_BMDMA: u32 = 1;
pub const CONFIG_NFC_SIM_MODULE: u32 = 1;
pub const CONFIG_ATALK_MODULE: u32 = 1;
pub const CONFIG_XZ_DEC_ARMTHUMB: u32 = 1;
pub const CONFIG_B43_BCMA: u32 = 1;
pub const CONFIG_SND_SOC_RT5631_MODULE: u32 = 1;
pub const CONFIG_AD7791_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_CS35L33_MODULE: u32 = 1;
pub const CONFIG_MTD_SWAP_MODULE: u32 = 1;
pub const CONFIG_USB_F_UAC1_MODULE: u32 = 1;
pub const CONFIG_JFFS2_CMODE_FAVOURLZO: u32 = 1;
pub const CONFIG_MEMORY_FAILURE: u32 = 1;
pub const CONFIG_NFS_V4_1: u32 = 1;
pub const CONFIG_SKFP_MODULE: u32 = 1;
pub const CONFIG_ARCH_USE_CMPXCHG_LOCKREF: u32 = 1;
pub const CONFIG_REGMAP: u32 = 1;
pub const CONFIG_SFC_MCDI_MON: u32 = 1;
pub const CONFIG_MTD_DOCG3_MODULE: u32 = 1;
pub const CONFIG_6PACK_MODULE: u32 = 1;
pub const CONFIG_NLS_UTF8_MODULE: u32 = 1;
pub const CONFIG_RADIO_SI470X: u32 = 1;
pub const CONFIG_PCIE_PME: u32 = 1;
pub const CONFIG_VIDEO_TM6000_DVB_MODULE: u32 = 1;
pub const CONFIG_JOYSTICK_XPAD_MODULE: u32 = 1;
pub const CONFIG_FB_ATY_BACKLIGHT: u32 = 1;
pub const CONFIG_BCMA_HOST_SOC: u32 = 1;
pub const CONFIG_PHY_PXA_28NM_USB2_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_SSM2602_I2C_MODULE: u32 = 1;
pub const CONFIG_HARDENED_USERCOPY: u32 = 1;
pub const CONFIG_KS7010_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_ISERT_MODULE: u32 = 1;
pub const CONFIG_ADIS16130_MODULE: u32 = 1;
pub const CONFIG_BAYCOM_PAR_MODULE: u32 = 1;
pub const CONFIG_DRM_AMD_ACP: u32 = 1;
pub const CONFIG_HAVE_MOD_ARCH_SPECIFIC: u32 = 1;
pub const CONFIG_AB3100_CORE: u32 = 1;
pub const CONFIG_FB_NOTIFY: u32 = 1;
pub const CONFIG_CAN_DEV_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_WM831X_MODULE: u32 = 1;
pub const CONFIG_INPUT_YEALINK_MODULE: u32 = 1;
pub const CONFIG_COMEDI_VMK80XX_MODULE: u32 = 1;
pub const CONFIG_DVB_DIB3000MB_MODULE: u32 = 1;
pub const CONFIG_IEEE802154_CC2520_MODULE: u32 = 1;
pub const CONFIG_FW_CFG_SYSFS_MODULE: u32 = 1;
pub const CONFIG_USB_PXA27X_MODULE: u32 = 1;
pub const CONFIG_MFD_DA9055: u32 = 1;
pub const CONFIG_SENSORS_NCT6683_MODULE: u32 = 1;
pub const CONFIG_AD5755_MODULE: u32 = 1;
pub const CONFIG_TI_ADC081C_MODULE: u32 = 1;
pub const CONFIG_SPEAKUP_SYNTH_SPKOUT_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_M41T80_MODULE: u32 = 1;
pub const CONFIG_STRICT_MODULE_RWX: u32 = 1;
pub const CONFIG_SERIAL_MEN_Z135_MODULE: u32 = 1;
pub const CONFIG_PCCARD_NONSTATIC: u32 = 1;
pub const CONFIG_VT6656_MODULE: u32 = 1;
pub const CONFIG_XEN_SCSI_FRONTEND_MODULE: u32 = 1;
pub const CONFIG_USB_USBNET_MODULE: u32 = 1;
pub const CONFIG_IIO_ST_LSM6DSX_MODULE: u32 = 1;
pub const CONFIG_NET_DEVLINK_MODULE: u32 = 1;
pub const CONFIG_INTEL_SOC_PMIC_BXTWC_MODULE: u32 = 1;
pub const CONFIG_EBC_C384_WDT_MODULE: u32 = 1;
pub const CONFIG_CPU_SUP_CENTAUR: u32 = 1;
pub const CONFIG_SND_SOC_CS4271_MODULE: u32 = 1;
pub const CONFIG_CB710_CORE_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_PL2303_MODULE: u32 = 1;
pub const CONFIG_NET_ACT_POLICE_MODULE: u32 = 1;
pub const CONFIG_AIC79XX_DEBUG_MASK: u32 = 0;
pub const CONFIG_UEFI_CPER: u32 = 1;
pub const CONFIG_NODES_SPAN_OTHER_NODES: u32 = 1;
pub const CONFIG_HAVE_INTEL_TXT: u32 = 1;
pub const CONFIG_HAMRADIO: u32 = 1;
pub const CONFIG_SYSCTL_EXCEPTION_TRACE: u32 = 1;
pub const CONFIG_M62332_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_PCAP_MODULE: u32 = 1;
pub const CONFIG_SERIAL_UARTLITE_NR_UARTS: u32 = 1;
pub const CONFIG_SYSVIPC_COMPAT: u32 = 1;
pub const CONFIG_GPIO_PCA953X_MODULE: u32 = 1;
pub const CONFIG_INPUT_XEN_KBDDEV_FRONTEND_MODULE: u32 = 1;
pub const CONFIG_HOTPLUG_PCI_SHPC_MODULE: u32 = 1;
pub const CONFIG_HINIC_MODULE: u32 = 1;
pub const CONFIG_ADIS16240_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_CINERGY_T2_MODULE: u32 = 1;
pub const CONFIG_FHANDLE: u32 = 1;
pub const CONFIG_COMEDI_ADDI_APCI_3XXX_MODULE: u32 = 1;
pub const CONFIG_SERIAL_ALTERA_UART_MODULE: u32 = 1;
pub const CONFIG_USB_MICROTEK_MODULE: u32 = 1;
pub const CONFIG_PANASONIC_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_HISAX_BKM_A4T: u32 = 1;
pub const CONFIG_INPUT_MC13783_PWRBUTTON_MODULE: u32 = 1;
pub const CONFIG_HISAX_ENTERNOW_PCI: u32 = 1;
pub const CONFIG_HID_SMARTJOYPLUS_MODULE: u32 = 1;
pub const CONFIG_ATA_GENERIC: u32 = 1;
pub const CONFIG_TOUCHSCREEN_GOODIX_MODULE: u32 = 1;
pub const CONFIG_NEW_LEDS: u32 = 1;
pub const CONFIG_SWAP: u32 = 1;
pub const CONFIG_MTD_MCHP23K256_MODULE: u32 = 1;
pub const CONFIG_AD5592R_BASE_MODULE: u32 = 1;
pub const CONFIG_MFD_TPS80031: u32 = 1;
pub const CONFIG_MTD_ONENAND_MODULE: u32 = 1;
pub const CONFIG_WATCHDOG_PRETIMEOUT_DEFAULT_GOV_NOOP: u32 = 1;
pub const CONFIG_B53_SPI_DRIVER_MODULE: u32 = 1;
pub const CONFIG_NFT_BRIDGE_META_MODULE: u32 = 1;
pub const CONFIG_MICROCODE_INTEL: u32 = 1;
pub const CONFIG_GENERIC_ADC_BATTERY_MODULE: u32 = 1;
pub const CONFIG_MOUSE_ELAN_I2C_I2C: u32 = 1;
pub const CONFIG_RTC_DRV_DS1511_MODULE: u32 = 1;
pub const CONFIG_USB_NET_CDC_SUBSET_ENABLE_MODULE: u32 = 1;
pub const CONFIG_IP_FIB_TRIE_STATS: u32 = 1;
pub const CONFIG_CRYPTO_SHA256_SSSE3_MODULE: u32 = 1;
pub const CONFIG_TEST_FIRMWARE_MODULE: u32 = 1;
pub const CONFIG_ATM_FORE200E_MODULE: u32 = 1;
pub const CONFIG_VIDEO_SOLO6X10_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_HFSC_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_RV3029C2_MODULE: u32 = 1;
pub const CONFIG_GPIO_TWL6040_MODULE: u32 = 1;
pub const CONFIG_X86_FAST_FEATURE_TESTS: u32 = 1;
pub const CONFIG_WIL6210_MODULE: u32 = 1;
pub const CONFIG_SND_ISIGHT_MODULE: u32 = 1;
pub const CONFIG_VIDEOBUF_DMA_SG_MODULE: u32 = 1;
pub const CONFIG_MTD_NAND_DISKONCHIP_MODULE: u32 = 1;
pub const CONFIG_MAC80211_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SKL_NAU88L25_SSM4567_MACH_MODULE: u32 = 1;
pub const CONFIG_SPI_ALTERA_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_GENERAL_TOUCH: u32 = 1;
pub const CONFIG_MEGARAID_MM_MODULE: u32 = 1;
pub const CONFIG_ARCH_USES_PG_UNCACHED: u32 = 1;
pub const CONFIG_CRC_CCITT: u32 = 1;
pub const CONFIG_SND_SOC_TS3A227E_MODULE: u32 = 1;
pub const CONFIG_GPIOLIB_IRQCHIP: u32 = 1;
pub const CONFIG_NET_VENDOR_CAVIUM: u32 = 1;
pub const CONFIG_DVB_TDA8261_MODULE: u32 = 1;
pub const CONFIG_SND_HDA_EXT_CORE_MODULE: u32 = 1;
pub const CONFIG_IGBVF_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_SD: u32 = 1;
pub const CONFIG_SND_SEQ_VIRMIDI_MODULE: u32 = 1;
pub const CONFIG_MFD_MAX14577: u32 = 1;
pub const CONFIG_NET_NCSI: u32 = 1;
pub const CONFIG_PHYSICAL_ALIGN: u32 = 2097152;
pub const CONFIG_ACPI_LEGACY_TABLES_LOOKUP: u32 = 1;
pub const CONFIG_INPUT_AD714X_SPI_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_NETLINK_MODULE: u32 = 1;
pub const CONFIG_VITESSE_PHY_MODULE: u32 = 1;
pub const CONFIG_MODULE_UNLOAD: u32 = 1;
pub const CONFIG_KEXEC_BZIMAGE_VERIFY_SIG: u32 = 1;
pub const CONFIG_FSCACHE_STATS: u32 = 1;
pub const CONFIG_DEVFREQ_GOV_USERSPACE: u32 = 1;
pub const CONFIG_INFINIBAND_MTHCA_MODULE: u32 = 1;
pub const CONFIG_SENSORS_MAX6650_MODULE: u32 = 1;
pub const CONFIG_SPI_SLAVE: u32 = 1;
pub const CONFIG_USB_GSPCA_BENQ_MODULE: u32 = 1;
pub const CONFIG_HAVE_ACPI_APEI_NMI: u32 = 1;
pub const CONFIG_REGULATOR_TPS65023_MODULE: u32 = 1;
pub const CONFIG_BT_LE: u32 = 1;
pub const CONFIG_PINCTRL_SX150X: u32 = 1;
pub const CONFIG_SND_AC97_CODEC_MODULE: u32 = 1;
pub const CONFIG_PCI_SW_SWITCHTEC_MODULE: u32 = 1;
pub const CONFIG_ARCH_WANT_OLD_COMPAT_IPC: u32 = 1;
pub const CONFIG_SND_SOC_DA7219_MODULE: u32 = 1;
pub const CONFIG_MOXA_SMARTIO_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_AK4613_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_CXUSB_MODULE: u32 = 1;
pub const CONFIG_TSL2583_MODULE: u32 = 1;
pub const CONFIG_X25_ASY_MODULE: u32 = 1;
pub const CONFIG_RT2500PCI_MODULE: u32 = 1;
pub const CONFIG_CMA: u32 = 1;
pub const CONFIG_RWSEM_SPIN_ON_OWNER: u32 = 1;
pub const CONFIG_SENSORS_LM85_MODULE: u32 = 1;
pub const CONFIG_AD525X_DPOT_MODULE: u32 = 1;
pub const CONFIG_SND_ATIIXP_MODULE: u32 = 1;
pub const CONFIG_VL6180_MODULE: u32 = 1;
pub const CONFIG_DIMLIB: u32 = 1;
pub const CONFIG_MEDIA_TUNER_M88RS6000T_MODULE: u32 = 1;
pub const CONFIG_TRACER_SNAPSHOT: u32 = 1;
pub const CONFIG_INFINIBAND_IPOIB_CM: u32 = 1;
pub const CONFIG_COMEDI_PARPORT_MODULE: u32 = 1;
pub const CONFIG_ADE7854_MODULE: u32 = 1;
pub const CONFIG_HID_PICOLCD_LCD: u32 = 1;
pub const CONFIG_HAVE_RELIABLE_STACKTRACE: u32 = 1;
pub const CONFIG_BITREVERSE: u32 = 1;
pub const CONFIG_NFT_MASQ_IPV6_MODULE: u32 = 1;
pub const CONFIG_DEVPORT: u32 = 1;
pub const CONFIG_VIDEO_CX88_ENABLE_VP3054: u32 = 1;
pub const CONFIG_DRM_I915_COMPRESS_ERROR: u32 = 1;
pub const CONFIG_IOSCHED_BFQ_MODULE: u32 = 1;
pub const CONFIG_MACB_USE_HWSTAMP: u32 = 1;
pub const CONFIG_INTEL_RST_MODULE: u32 = 1;
pub const CONFIG_X509_CERTIFICATE_PARSER: u32 = 1;
pub const CONFIG_BLK_DEV_RAM_SIZE: u32 = 65536;
pub const CONFIG_USB_SERIAL_WWAN_MODULE: u32 = 1;
pub const CONFIG_SND_ICE1724_MODULE: u32 = 1;
pub const CONFIG_MAC_PARTITION: u32 = 1;
pub const CONFIG_CONSOLE_POLL: u32 = 1;
pub const CONFIG_EARLY_PRINTK_USB: u32 = 1;
pub const CONFIG_HID_ALPS_MODULE: u32 = 1;
pub const CONFIG_IIO_ADIS_LIB_BUFFER: u32 = 1;
pub const CONFIG_SENSORS_DA9052_ADC_MODULE: u32 = 1;
pub const CONFIG_XFS_POSIX_ACL: u32 = 1;
pub const CONFIG_BT_WILINK_MODULE: u32 = 1;
pub const CONFIG_PTP_1588_CLOCK_KVM_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_DA9034_MODULE: u32 = 1;
pub const CONFIG_ND_BLK_MODULE: u32 = 1;
pub const CONFIG_IIO_ST_LSM6DSX_SPI_MODULE: u32 = 1;
pub const CONFIG_INT3406_THERMAL_MODULE: u32 = 1;
pub const CONFIG_MSI_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_COMEDI_DT2801_MODULE: u32 = 1;
pub const CONFIG_NVM: u32 = 1;
pub const CONFIG_BRCMFMAC_USB: u32 = 1;
pub const CONFIG_TOUCHSCREEN_DYNAPRO_MODULE: u32 = 1;
pub const CONFIG_FB_MODE_HELPERS: u32 = 1;
pub const CONFIG_NLS_ISO8859_13_MODULE: u32 = 1;
pub const CONFIG_MTD_MTDRAM_MODULE: u32 = 1;
pub const CONFIG_PCI_PRI: u32 = 1;
pub const CONFIG_BLK_DEV_SX8_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_BLKCIPHER: u32 = 1;
pub const CONFIG_CRYPTO_SKEIN: u32 = 1;
pub const CONFIG_EXTCON_MAX77693_MODULE: u32 = 1;
pub const CONFIG_X86_L1_CACHE_SHIFT: u32 = 6;
pub const CONFIG_BATTERY_BQ27XXX_HDQ_MODULE: u32 = 1;
pub const CONFIG_X86_PAT: u32 = 1;
pub const CONFIG_USB_STORAGE_ONETOUCH_MODULE: u32 = 1;
pub const CONFIG_NLS_ISO8859_8_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_INTEL_SKL_NAU88L25_MAX98357A_MACH_MODULE: u32 = 1;
pub const CONFIG_RT2400PCI_MODULE: u32 = 1;
pub const CONFIG_NF_CONNTRACK_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_PCF8523_MODULE: u32 = 1;
pub const CONFIG_ARCH_HAS_REFCOUNT: u32 = 1;
pub const CONFIG_HID_PICOLCD_CIR: u32 = 1;
pub const CONFIG_BACKLIGHT_PANDORA_MODULE: u32 = 1;
pub const CONFIG_COMEDI_GSC_HPDI_MODULE: u32 = 1;
pub const CONFIG_FB_NVIDIA_MODULE: u32 = 1;
pub const CONFIG_EFI_RUNTIME_WRAPPERS: u32 = 1;
pub const CONFIG_LCD_CLASS_DEVICE_MODULE: u32 = 1;
pub const CONFIG_ARCH_DMA_ADDR_T_64BIT: u32 = 1;
pub const CONFIG_FILE_LOCKING: u32 = 1;
pub const CONFIG_PATA_HPT3X3_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_XIRLINK_CIT_MODULE: u32 = 1;
pub const CONFIG_AD2S1200_MODULE: u32 = 1;
pub const CONFIG_RTC_DRV_STK17TA8_MODULE: u32 = 1;
pub const CONFIG_USB_GSPCA_SN9C20X_MODULE: u32 = 1;
pub const CONFIG_RMI4_F03: u32 = 1;
pub const CONFIG_TOUCHSCREEN_USB_ELO: u32 = 1;
pub const CONFIG_RTC_DRV_DS1302_MODULE: u32 = 1;
pub const CONFIG_USB_CHAOSKEY_MODULE: u32 = 1;
pub const CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST: u32 = 1;
pub const CONFIG_TEST_BPF_MODULE: u32 = 1;
pub const CONFIG_FS_DAX_PMD: u32 = 1;
pub const CONFIG_BACKLIGHT_LV5207LP_MODULE: u32 = 1;
pub const CONFIG_KARMA_PARTITION: u32 = 1;
pub const CONFIG_FB_SM501_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_I2C_AND_SPI_MODULE: u32 = 1;
pub const CONFIG_NETPOLL: u32 = 1;
pub const CONFIG_COMEDI_ISADMA_MODULE: u32 = 1;
pub const CONFIG_ZSWAP: u32 = 1;
pub const CONFIG_SPEAKUP_SYNTH_AUDPTR_MODULE: u32 = 1;
pub const CONFIG_MAC80211_MESSAGE_TRACING: u32 = 1;
pub const CONFIG_SENSORS_F71882FG_MODULE: u32 = 1;
pub const CONFIG_ACPI_APEI_GHES: u32 = 1;
pub const CONFIG_FB_CARILLO_RANCH_MODULE: u32 = 1;
pub const CONFIG_SENSORS_ADT7310_MODULE: u32 = 1;
pub const CONFIG_AIO: u32 = 1;
pub const CONFIG_SERIO_ARC_PS2_MODULE: u32 = 1;
pub const CONFIG_DVB_TDA8083_MODULE: u32 = 1;
pub const CONFIG_NET_MPLS_GSO_MODULE: u32 = 1;
pub const CONFIG_NFC_FDP_I2C_MODULE: u32 = 1;
pub const CONFIG_LEGACY_VSYSCALL_EMULATE: u32 = 1;
pub const CONFIG_RTC_DRV_DS1347_MODULE: u32 = 1;
pub const CONFIG_BLK_DEV_DAC960_MODULE: u32 = 1;
pub const CONFIG_USB_FOTG210_UDC_MODULE: u32 = 1;
pub const CONFIG_CLKEVT_I8253: u32 = 1;
pub const CONFIG_DVB_USB_AZ6007_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_USERSPACE_CONSUMER_MODULE: u32 = 1;
pub const CONFIG_NET_EMATCH: u32 = 1;
pub const CONFIG_PERF_EVENTS: u32 = 1;
pub const CONFIG_MMC_REALTEK_USB_MODULE: u32 = 1;
pub const CONFIG_GENERIC_TIME_VSYSCALL: u32 = 1;
pub const CONFIG_IP_NF_TARGET_REJECT_MODULE: u32 = 1;
pub const CONFIG_ZIIRAVE_WATCHDOG_MODULE: u32 = 1;
pub const CONFIG_NET_SCH_CHOKE_MODULE: u32 = 1;
pub const CONFIG_LEDS_CLASS: u32 = 1;
pub const CONFIG_COMEDI_BOND_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_DIGITV_MODULE: u32 = 1;
pub const CONFIG_IP6_NF_MATCH_HL_MODULE: u32 = 1;
pub const CONFIG_PERF_EVENTS_INTEL_CSTATE_MODULE: u32 = 1;
pub const CONFIG_KALLSYMS_BASE_RELATIVE: u32 = 1;
pub const CONFIG_TIPC_MEDIA_IB: u32 = 1;
pub const CONFIG_VIDEO_SAA7110_MODULE: u32 = 1;
pub const CONFIG_MTD_L440GX_MODULE: u32 = 1;
pub const CONFIG_WINBOND_FIR_MODULE: u32 = 1;
pub const CONFIG_GPIO_GPIO_MM_MODULE: u32 = 1;
pub const CONFIG_IP_VS_TAB_BITS: u32 = 12;
pub const CONFIG_COMEDI_NI_AT_AO_MODULE: u32 = 1;
pub const CONFIG_IP6_NF_MATCH_OPTS_MODULE: u32 = 1;
pub const CONFIG_SENSORS_DA9055_MODULE: u32 = 1;
pub const CONFIG_INPUT_TWL4030_PWRBUTTON_MODULE: u32 = 1;
pub const CONFIG_SCSI_SAS_HOST_SMP: u32 = 1;
pub const CONFIG_VERSION_SIGNATURE: &'static [u8; 38usize] =
    b"Ubuntu 4.15.0-151.157-generic 4.15.18\0";
pub const CONFIG_RTC_INTF_DEV: u32 = 1;
pub const CONFIG_MTD_MAP_BANK_WIDTH_4: u32 = 1;
pub const CONFIG_UBIFS_FS_ENCRYPTION: u32 = 1;
pub const CONFIG_IIO_ST_SENSORS_SPI_MODULE: u32 = 1;
pub const CONFIG_GREYBUS_SPI_MODULE: u32 = 1;
pub const CONFIG_DCACHE_WORD_ACCESS: u32 = 1;
pub const CONFIG_IP6_NF_TARGET_NPT_MODULE: u32 = 1;
pub const CONFIG_SOC_CAMERA_OV9740_MODULE: u32 = 1;
pub const CONFIG_DVB_USB_CE6230_MODULE: u32 = 1;
pub const CONFIG_PARIDE_ATEN_MODULE: u32 = 1;
pub const CONFIG_INFINIBAND_CXGB3_MODULE: u32 = 1;
pub const CONFIG_USB_SERIAL_SYMBOL_MODULE: u32 = 1;
pub const CONFIG_CHARGER_MAX77693_MODULE: u32 = 1;
pub const CONFIG_HERMES_MODULE: u32 = 1;
pub const CONFIG_REGULATOR_MAX8952_MODULE: u32 = 1;
pub const CONFIG_SND_SOC_HDMI_CODEC_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_OSF_MODULE: u32 = 1;
pub const CONFIG_MLX_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_USB_MIDI_GADGET_MODULE: u32 = 1;
pub const CONFIG_SATA_QSTOR_MODULE: u32 = 1;
pub const CONFIG_WILINK_PLATFORM_DATA: u32 = 1;
pub const CONFIG_VIDEO_GO7007_MODULE: u32 = 1;
pub const CONFIG_PATA_SIS: u32 = 1;
pub const CONFIG_MESSAGE_LOGLEVEL_DEFAULT: u32 = 4;
pub const CONFIG_GPIO_TWL4030_MODULE: u32 = 1;
pub const CONFIG_AMD_NB: u32 = 1;
pub const CONFIG_SND_VIRMIDI_MODULE: u32 = 1;
pub const CONFIG_LIB80211_CRYPT_TKIP_MODULE: u32 = 1;
pub const CONFIG_APDS9960_MODULE: u32 = 1;
pub const CONFIG_LOCKUP_DETECTOR: u32 = 1;
pub const CONFIG_QSEMI_PHY_MODULE: u32 = 1;
pub const CONFIG_IP_VS_PROTO_UDP: u32 = 1;
pub const CONFIG_VIDEO_BT866_MODULE: u32 = 1;
pub const CONFIG_NLS_DEFAULT: &'static [u8; 5usize] = b"utf8\0";
pub const CONFIG_WATCHDOG_PRETIMEOUT_GOV_NOOP: u32 = 1;
pub const CONFIG_ACPI_CONTAINER: u32 = 1;
pub const CONFIG_SND_DMA_SGBUF: u32 = 1;
pub const CONFIG_UTS_NS: u32 = 1;
pub const CONFIG_I2C_AMD_MP2_MODULE: u32 = 1;
pub const CONFIG_NF_CT_PROTO_GRE_MODULE: u32 = 1;
pub const CONFIG_HDMI_LPE_AUDIO_MODULE: u32 = 1;
pub const CONFIG_WMI_BMOF_MODULE: u32 = 1;
pub const CONFIG_BT_HCIUART_BCSP: u32 = 1;
pub const CONFIG_REGULATOR_S2MPA01_MODULE: u32 = 1;
pub const CONFIG_NF_CT_NETLINK_MODULE: u32 = 1;
pub const CONFIG_EFS_FS_MODULE: u32 = 1;
pub const CONFIG_AUXDISPLAY: u32 = 1;
pub const CONFIG_USB_NET_SR9800_MODULE: u32 = 1;
pub const CONFIG_NET_EMATCH_TEXT_MODULE: u32 = 1;
pub const CONFIG_DMA_ENGINE: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_ANALOG_MODULE: u32 = 1;
pub const CONFIG_ADIS16209_MODULE: u32 = 1;
pub const CONFIG_X86_ACPI_CPUFREQ: u32 = 1;
pub const CONFIG_HID_WIIMOTE_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_AS3711_MODULE: u32 = 1;
pub const CONFIG_APDS9300_MODULE: u32 = 1;
pub const CONFIG_USB_MA901_MODULE: u32 = 1;
pub const CONFIG_P54_SPI_MODULE: u32 = 1;
pub const CONFIG_RDS_TCP_MODULE: u32 = 1;
pub const CONFIG_CGROUP_PIDS: u32 = 1;
pub const CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD: u32 = 1;
pub const CONFIG_CRYPTO_AEAD2: u32 = 1;
pub const CONFIG_CRYPTO_FCRYPT_MODULE: u32 = 1;
pub const CONFIG_NF_NAT_MASQUERADE_IPV6_MODULE: u32 = 1;
pub const CONFIG_PCMCIA_ATMEL_MODULE: u32 = 1;
pub const CONFIG_NFC_NCI_MODULE: u32 = 1;
pub const CONFIG_TOSHIBA_BT_RFKILL_MODULE: u32 = 1;
pub const CONFIG_WATCHDOG_PRETIMEOUT_GOV_PANIC_MODULE: u32 = 1;
pub const CONFIG_MOUSE_PS2_MODULE: u32 = 1;
pub const CONFIG_NET_IPIP_MODULE: u32 = 1;
pub const CONFIG_IP_VS_SH_TAB_BITS: u32 = 8;
pub const CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE: u32 = 0;
pub const CONFIG_USB_SERIAL_IPAQ_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_HL_MODULE: u32 = 1;
pub const CONFIG_PCI_ENDPOINT: u32 = 1;
pub const CONFIG_CHROMEOS_LAPTOP_MODULE: u32 = 1;
pub const CONFIG_NFC_DIGITAL_MODULE: u32 = 1;
pub const CONFIG_LEDS_TCA6507_MODULE: u32 = 1;
pub const CONFIG_SND_USB_POD_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_ALGAPI2: u32 = 1;
pub const CONFIG_SATA_SIS_MODULE: u32 = 1;
pub const CONFIG_PHYSICAL_START: u32 = 16777216;
pub const CONFIG_NETFILTER_XT_TARGET_LED_MODULE: u32 = 1;
pub const CONFIG_WEXT_SPY: u32 = 1;
pub const CONFIG_UBIFS_FS_LZO: u32 = 1;
pub const CONFIG_SI1145_MODULE: u32 = 1;
pub const CONFIG_USB_G_ACM_MS_MODULE: u32 = 1;
pub const CONFIG_ACPI_SBS_MODULE: u32 = 1;
pub const CONFIG_KEYBOARD_ADP5589_MODULE: u32 = 1;
pub const CONFIG_GENERIC_IRQ_RESERVATION_MODE: u32 = 1;
pub const CONFIG_HAVE_MEMBLOCK: u32 = 1;
pub const CONFIG_FB_3DFX_MODULE: u32 = 1;
pub const CONFIG_TOUCHSCREEN_SILEAD_MODULE: u32 = 1;
pub const CONFIG_X86_PMEM_LEGACY: u32 = 1;
pub const CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS: u32 = 1;
pub const CONFIG_INPUT: u32 = 1;
pub const CONFIG_PCI200SYN_MODULE: u32 = 1;
pub const CONFIG_PPPOATM_MODULE: u32 = 1;
pub const CONFIG_VIDEO_ZORAN_MODULE: u32 = 1;
pub const CONFIG_PMIC_DA9052: u32 = 1;
pub const CONFIG_PATA_OPTI_MODULE: u32 = 1;
pub const CONFIG_PROC_SYSCTL: u32 = 1;
pub const CONFIG_SND_HDA_CODEC_REALTEK_MODULE: u32 = 1;
pub const CONFIG_ATH6KL_MODULE: u32 = 1;
pub const CONFIG_HAVE_PERF_EVENTS_NMI: u32 = 1;
pub const CONFIG_SND_SOC_FSL_ASRC_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_CT_MODULE: u32 = 1;
pub const CONFIG_RD_LZ4: u32 = 1;
pub const CONFIG_MMU: u32 = 1;
pub const CONFIG_DVB_CX24123_MODULE: u32 = 1;
pub const CONFIG_OCFS2_FS_MODULE: u32 = 1;
pub const CONFIG_MTD_M25P80_MODULE: u32 = 1;
pub const CONFIG_USB_KAWETH_MODULE: u32 = 1;
pub const CONFIG_USB_SIERRA_NET_MODULE: u32 = 1;
pub const CONFIG_AIC7XXX_RESET_DELAY_MS: u32 = 5000;
pub const CONFIG_VMWARE_BALLOON_MODULE: u32 = 1;
pub const CONFIG_HISAX_GAZEL: u32 = 1;
pub const CONFIG_BRIDGE_EBT_NFLOG_MODULE: u32 = 1;
pub const CONFIG_CAN_SJA1000_PLATFORM_MODULE: u32 = 1;
pub const CONFIG_TABLET_USB_AIPTEK_MODULE: u32 = 1;
pub const CONFIG_BNXT_SRIOV: u32 = 1;
pub const CONFIG_AGP: u32 = 1;
pub const CONFIG_INLINE_WRITE_UNLOCK: u32 = 1;
pub const CONFIG_ZPOOL: u32 = 1;
pub const CONFIG_REGULATOR_TPS6524X_MODULE: u32 = 1;
pub const CONFIG_INPUT_AD714X_MODULE: u32 = 1;
pub const CONFIG_SENSORS_GL520SM_MODULE: u32 = 1;
pub const CONFIG_E1000_MODULE: u32 = 1;
pub const CONFIG_SCSI_SYM53C8XX_MMIO: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __ARG_PLACEHOLDER_1: u32 = 0;
pub const GCC_VERSION: u32 = 40201;
pub const COMPILER_HAS_GENERIC_BUILTIN_OVERFLOW: u32 = 1;
pub const ASM_UNREACHABLE: &'static [u8; 71usize] =
    b"999:\n\t.pushsection .discard.unreachable\n\t.long 999b - .\n\t.popsection\n\t\0";
pub const __BITS_PER_LONG: u32 = 64;
pub const BITS_PER_LONG: u32 = 64;
pub const BITS_PER_LONG_LONG: u32 = 64;
pub const __FD_SETSIZE: u32 = 1024;
pub const LOCK_PREFIX_HERE: &'static [u8; 70usize] =
    b".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\0";
pub const LOCK_PREFIX: &'static [u8; 78usize] =
    b".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; \0";
pub const alt_end_marker: &'static [u8; 4usize] = b"663\0";
pub const alt_slen: &'static [u8; 10usize] = b"662b-661b\0";
pub const alt_pad_len: &'static [u8; 10usize] = b"663b-662b\0";
pub const alt_total_slen: &'static [u8; 10usize] = b"663b-661b\0";
pub const NOP_DS_PREFIX: u32 = 62;
pub const GENERIC_NOP1: u32 = 144;
pub const K8_NOP1: u32 = 144;
pub const K7_NOP1: u32 = 144;
pub const P6_NOP1: u32 = 144;
pub const ASM_NOP_MAX: u32 = 8;
pub const NOP_ATOMIC5: u32 = 9;
pub const KERN_SOH: &'static [u8; 2usize] = b"\x01\0";
pub const KERN_SOH_ASCII: u8 = 1u8;
pub const KERN_EMERG: &'static [u8; 3usize] = b"\x010\0";
pub const KERN_ALERT: &'static [u8; 3usize] = b"\x011\0";
pub const KERN_CRIT: &'static [u8; 3usize] = b"\x012\0";
pub const KERN_ERR: &'static [u8; 3usize] = b"\x013\0";
pub const KERN_WARNING: &'static [u8; 3usize] = b"\x014\0";
pub const KERN_NOTICE: &'static [u8; 3usize] = b"\x015\0";
pub const KERN_INFO: &'static [u8; 3usize] = b"\x016\0";
pub const KERN_DEBUG: &'static [u8; 3usize] = b"\x017\0";
pub const KERN_DEFAULT: &'static [u8; 3usize] = b"\x01d\0";
pub const KERN_CONT: &'static [u8; 3usize] = b"\x01c\0";
pub const LOGLEVEL_SCHED: i32 = -2;
pub const LOGLEVEL_DEFAULT: i32 = -1;
pub const LOGLEVEL_EMERG: u32 = 0;
pub const LOGLEVEL_ALERT: u32 = 1;
pub const LOGLEVEL_CRIT: u32 = 2;
pub const LOGLEVEL_ERR: u32 = 3;
pub const LOGLEVEL_WARNING: u32 = 4;
pub const LOGLEVEL_NOTICE: u32 = 5;
pub const LOGLEVEL_INFO: u32 = 6;
pub const LOGLEVEL_DEBUG: u32 = 7;
pub const __ALIGN_STR: &'static [u8; 14usize] = b".align 4,0x90\0";
pub const SI_LOAD_SHIFT: u32 = 16;
pub const L1_CACHE_SHIFT: u32 = 6;
pub const L1_CACHE_BYTES: u32 = 64;
pub const INTERNODE_CACHE_SHIFT: u32 = 6;
pub const INTERNODE_CACHE_BYTES: u32 = 64;
pub const SMP_CACHE_BYTES: u32 = 64;
pub const PRINTK_MAX_SINGLE_HEADER_LEN: u32 = 2;
pub const CONSOLE_EXT_LOG_MAX: u32 = 8192;
pub const MESSAGE_LOGLEVEL_DEFAULT: u32 = 4;
pub const CONSOLE_LOGLEVEL_SILENT: u32 = 0;
pub const CONSOLE_LOGLEVEL_MIN: u32 = 1;
pub const CONSOLE_LOGLEVEL_QUIET: u32 = 4;
pub const CONSOLE_LOGLEVEL_DEBUG: u32 = 10;
pub const CONSOLE_LOGLEVEL_MOTORMOUTH: u32 = 15;
pub const CONSOLE_LOGLEVEL_DEFAULT: u32 = 7;
pub const DEVKMSG_STR_MAX_SIZE: u32 = 10;
pub const FW_BUG: &'static [u8; 17usize] = b"[Firmware Bug]: \0";
pub const FW_WARN: &'static [u8; 18usize] = b"[Firmware Warn]: \0";
pub const FW_INFO: &'static [u8; 18usize] = b"[Firmware Info]: \0";
pub const HW_ERR: &'static [u8; 19usize] = b"[Hardware Error]: \0";
pub const DEPRECATED: &'static [u8; 15usize] = b"[Deprecated]: \0";
pub const _DPRINTK_FLAGS_NONE: u32 = 0;
pub const _DPRINTK_FLAGS_PRINT: u32 = 1;
pub const _DPRINTK_FLAGS_INCL_MODNAME: u32 = 2;
pub const _DPRINTK_FLAGS_INCL_FUNCNAME: u32 = 4;
pub const _DPRINTK_FLAGS_INCL_LINENO: u32 = 8;
pub const _DPRINTK_FLAGS_INCL_TID: u32 = 16;
pub const _DPRINTK_FLAGS_DEFAULT: u32 = 0;
pub const LINUX_MM_DEBUG_H: u32 = 1;
pub const ASM_UD0: &'static [u8; 17usize] = b".byte 0x0f, 0xff\0";
pub const ASM_UD1: &'static [u8; 17usize] = b".byte 0x0f, 0xb9\0";
pub const ASM_UD2: &'static [u8; 17usize] = b".byte 0x0f, 0x0b\0";
pub const INSN_UD0: u32 = 65295;
pub const INSN_UD2: u32 = 2831;
pub const LEN_UD2: u32 = 2;
pub const CUT_HERE: &'static [u8; 38usize] = b"------------[ cut here ]------------\n\0";
pub const BUGFLAG_WARNING: u32 = 1;
pub const BUGFLAG_ONCE: u32 = 2;
pub const BUGFLAG_DONE: u32 = 4;
pub const BITS_PER_BYTE: u32 = 8;
pub const __BINARY_RMWcc_ARG: &'static [u8; 6usize] = b" %2, \0";
pub const _BITOPS_LONG_SHIFT: u32 = 6;
pub const NEED_3DNOW: u32 = 0;
pub const NEED_MOVBE: u32 = 0;
pub const NEED_LA57: u32 = 0;
pub const NEED_PSE: u32 = 0;
pub const NEED_PGE: u32 = 0;
pub const REQUIRED_MASK2: u32 = 0;
pub const REQUIRED_MASK4: u32 = 0;
pub const REQUIRED_MASK5: u32 = 0;
pub const REQUIRED_MASK6: u32 = 0;
pub const REQUIRED_MASK7: u32 = 0;
pub const REQUIRED_MASK8: u32 = 0;
pub const REQUIRED_MASK9: u32 = 0;
pub const REQUIRED_MASK10: u32 = 0;
pub const REQUIRED_MASK11: u32 = 0;
pub const REQUIRED_MASK12: u32 = 0;
pub const REQUIRED_MASK13: u32 = 0;
pub const REQUIRED_MASK14: u32 = 0;
pub const REQUIRED_MASK15: u32 = 0;
pub const REQUIRED_MASK16: u32 = 0;
pub const REQUIRED_MASK17: u32 = 0;
pub const REQUIRED_MASK18: u32 = 0;
pub const DISABLE_MPX: u32 = 0;
pub const DISABLE_UMIP: u32 = 0;
pub const DISABLE_PCID: u32 = 0;
pub const DISABLE_PKU: u32 = 0;
pub const DISABLE_OSPKE: u32 = 0;
pub const DISABLE_PTI: u32 = 0;
pub const DISABLED_MASK1: u32 = 0;
pub const DISABLED_MASK2: u32 = 0;
pub const DISABLED_MASK4: u32 = 0;
pub const DISABLED_MASK5: u32 = 0;
pub const DISABLED_MASK6: u32 = 0;
pub const DISABLED_MASK7: u32 = 0;
pub const DISABLED_MASK8: u32 = 0;
pub const DISABLED_MASK9: u32 = 0;
pub const DISABLED_MASK10: u32 = 0;
pub const DISABLED_MASK11: u32 = 0;
pub const DISABLED_MASK12: u32 = 0;
pub const DISABLED_MASK13: u32 = 0;
pub const DISABLED_MASK14: u32 = 0;
pub const DISABLED_MASK15: u32 = 0;
pub const DISABLED_MASK17: u32 = 0;
pub const DISABLED_MASK18: u32 = 0;
pub const NCAPINTS: u32 = 19;
pub const NBUGINTS: u32 = 1;
pub const X86_FEATURE_FPU: u32 = 0;
pub const X86_FEATURE_VME: u32 = 1;
pub const X86_FEATURE_DE: u32 = 2;
pub const X86_FEATURE_PSE: u32 = 3;
pub const X86_FEATURE_TSC: u32 = 4;
pub const X86_FEATURE_MSR: u32 = 5;
pub const X86_FEATURE_PAE: u32 = 6;
pub const X86_FEATURE_MCE: u32 = 7;
pub const X86_FEATURE_CX8: u32 = 8;
pub const X86_FEATURE_APIC: u32 = 9;
pub const X86_FEATURE_SEP: u32 = 11;
pub const X86_FEATURE_MTRR: u32 = 12;
pub const X86_FEATURE_PGE: u32 = 13;
pub const X86_FEATURE_MCA: u32 = 14;
pub const X86_FEATURE_CMOV: u32 = 15;
pub const X86_FEATURE_PAT: u32 = 16;
pub const X86_FEATURE_PSE36: u32 = 17;
pub const X86_FEATURE_PN: u32 = 18;
pub const X86_FEATURE_CLFLUSH: u32 = 19;
pub const X86_FEATURE_DS: u32 = 21;
pub const X86_FEATURE_ACPI: u32 = 22;
pub const X86_FEATURE_MMX: u32 = 23;
pub const X86_FEATURE_FXSR: u32 = 24;
pub const X86_FEATURE_XMM: u32 = 25;
pub const X86_FEATURE_XMM2: u32 = 26;
pub const X86_FEATURE_SELFSNOOP: u32 = 27;
pub const X86_FEATURE_HT: u32 = 28;
pub const X86_FEATURE_ACC: u32 = 29;
pub const X86_FEATURE_IA64: u32 = 30;
pub const X86_FEATURE_PBE: u32 = 31;
pub const X86_FEATURE_SYSCALL: u32 = 43;
pub const X86_FEATURE_MP: u32 = 51;
pub const X86_FEATURE_NX: u32 = 52;
pub const X86_FEATURE_MMXEXT: u32 = 54;
pub const X86_FEATURE_FXSR_OPT: u32 = 57;
pub const X86_FEATURE_GBPAGES: u32 = 58;
pub const X86_FEATURE_RDTSCP: u32 = 59;
pub const X86_FEATURE_LM: u32 = 61;
pub const X86_FEATURE_3DNOWEXT: u32 = 62;
pub const X86_FEATURE_3DNOW: u32 = 63;
pub const X86_FEATURE_RECOVERY: u32 = 64;
pub const X86_FEATURE_LONGRUN: u32 = 65;
pub const X86_FEATURE_LRTI: u32 = 67;
pub const X86_FEATURE_CXMMX: u32 = 96;
pub const X86_FEATURE_K6_MTRR: u32 = 97;
pub const X86_FEATURE_CYRIX_ARR: u32 = 98;
pub const X86_FEATURE_CENTAUR_MCR: u32 = 99;
pub const X86_FEATURE_K8: u32 = 100;
pub const X86_FEATURE_K7: u32 = 101;
pub const X86_FEATURE_P3: u32 = 102;
pub const X86_FEATURE_P4: u32 = 103;
pub const X86_FEATURE_CONSTANT_TSC: u32 = 104;
pub const X86_FEATURE_UP: u32 = 105;
pub const X86_FEATURE_ART: u32 = 106;
pub const X86_FEATURE_ARCH_PERFMON: u32 = 107;
pub const X86_FEATURE_PEBS: u32 = 108;
pub const X86_FEATURE_BTS: u32 = 109;
pub const X86_FEATURE_SYSCALL32: u32 = 110;
pub const X86_FEATURE_SYSENTER32: u32 = 111;
pub const X86_FEATURE_REP_GOOD: u32 = 112;
pub const X86_FEATURE_MFENCE_RDTSC: u32 = 113;
pub const X86_FEATURE_LFENCE_RDTSC: u32 = 114;
pub const X86_FEATURE_ACC_POWER: u32 = 115;
pub const X86_FEATURE_NOPL: u32 = 116;
pub const X86_FEATURE_ALWAYS: u32 = 117;
pub const X86_FEATURE_XTOPOLOGY: u32 = 118;
pub const X86_FEATURE_TSC_RELIABLE: u32 = 119;
pub const X86_FEATURE_NONSTOP_TSC: u32 = 120;
pub const X86_FEATURE_CPUID: u32 = 121;
pub const X86_FEATURE_EXTD_APICID: u32 = 122;
pub const X86_FEATURE_AMD_DCM: u32 = 123;
pub const X86_FEATURE_APERFMPERF: u32 = 124;
pub const X86_FEATURE_NONSTOP_TSC_S3: u32 = 126;
pub const X86_FEATURE_TSC_KNOWN_FREQ: u32 = 127;
pub const X86_FEATURE_XMM3: u32 = 128;
pub const X86_FEATURE_PCLMULQDQ: u32 = 129;
pub const X86_FEATURE_DTES64: u32 = 130;
pub const X86_FEATURE_MWAIT: u32 = 131;
pub const X86_FEATURE_DSCPL: u32 = 132;
pub const X86_FEATURE_VMX: u32 = 133;
pub const X86_FEATURE_SMX: u32 = 134;
pub const X86_FEATURE_EST: u32 = 135;
pub const X86_FEATURE_TM2: u32 = 136;
pub const X86_FEATURE_SSSE3: u32 = 137;
pub const X86_FEATURE_CID: u32 = 138;
pub const X86_FEATURE_SDBG: u32 = 139;
pub const X86_FEATURE_FMA: u32 = 140;
pub const X86_FEATURE_CX16: u32 = 141;
pub const X86_FEATURE_XTPR: u32 = 142;
pub const X86_FEATURE_PDCM: u32 = 143;
pub const X86_FEATURE_PCID: u32 = 145;
pub const X86_FEATURE_DCA: u32 = 146;
pub const X86_FEATURE_XMM4_1: u32 = 147;
pub const X86_FEATURE_XMM4_2: u32 = 148;
pub const X86_FEATURE_X2APIC: u32 = 149;
pub const X86_FEATURE_MOVBE: u32 = 150;
pub const X86_FEATURE_POPCNT: u32 = 151;
pub const X86_FEATURE_TSC_DEADLINE_TIMER: u32 = 152;
pub const X86_FEATURE_AES: u32 = 153;
pub const X86_FEATURE_XSAVE: u32 = 154;
pub const X86_FEATURE_OSXSAVE: u32 = 155;
pub const X86_FEATURE_AVX: u32 = 156;
pub const X86_FEATURE_F16C: u32 = 157;
pub const X86_FEATURE_RDRAND: u32 = 158;
pub const X86_FEATURE_HYPERVISOR: u32 = 159;
pub const X86_FEATURE_XSTORE: u32 = 162;
pub const X86_FEATURE_XSTORE_EN: u32 = 163;
pub const X86_FEATURE_XCRYPT: u32 = 166;
pub const X86_FEATURE_XCRYPT_EN: u32 = 167;
pub const X86_FEATURE_ACE2: u32 = 168;
pub const X86_FEATURE_ACE2_EN: u32 = 169;
pub const X86_FEATURE_PHE: u32 = 170;
pub const X86_FEATURE_PHE_EN: u32 = 171;
pub const X86_FEATURE_PMM: u32 = 172;
pub const X86_FEATURE_PMM_EN: u32 = 173;
pub const X86_FEATURE_LAHF_LM: u32 = 192;
pub const X86_FEATURE_CMP_LEGACY: u32 = 193;
pub const X86_FEATURE_SVM: u32 = 194;
pub const X86_FEATURE_EXTAPIC: u32 = 195;
pub const X86_FEATURE_CR8_LEGACY: u32 = 196;
pub const X86_FEATURE_ABM: u32 = 197;
pub const X86_FEATURE_SSE4A: u32 = 198;
pub const X86_FEATURE_MISALIGNSSE: u32 = 199;
pub const X86_FEATURE_3DNOWPREFETCH: u32 = 200;
pub const X86_FEATURE_OSVW: u32 = 201;
pub const X86_FEATURE_IBS: u32 = 202;
pub const X86_FEATURE_XOP: u32 = 203;
pub const X86_FEATURE_SKINIT: u32 = 204;
pub const X86_FEATURE_WDT: u32 = 205;
pub const X86_FEATURE_LWP: u32 = 207;
pub const X86_FEATURE_FMA4: u32 = 208;
pub const X86_FEATURE_TCE: u32 = 209;
pub const X86_FEATURE_NODEID_MSR: u32 = 211;
pub const X86_FEATURE_TBM: u32 = 213;
pub const X86_FEATURE_TOPOEXT: u32 = 214;
pub const X86_FEATURE_PERFCTR_CORE: u32 = 215;
pub const X86_FEATURE_PERFCTR_NB: u32 = 216;
pub const X86_FEATURE_BPEXT: u32 = 218;
pub const X86_FEATURE_PTSC: u32 = 219;
pub const X86_FEATURE_PERFCTR_LLC: u32 = 220;
pub const X86_FEATURE_MWAITX: u32 = 221;
pub const X86_FEATURE_RING3MWAIT: u32 = 224;
pub const X86_FEATURE_CPUID_FAULT: u32 = 225;
pub const X86_FEATURE_CPB: u32 = 226;
pub const X86_FEATURE_EPB: u32 = 227;
pub const X86_FEATURE_CAT_L3: u32 = 228;
pub const X86_FEATURE_CAT_L2: u32 = 229;
pub const X86_FEATURE_CDP_L3: u32 = 230;
pub const X86_FEATURE_INVPCID_SINGLE: u32 = 231;
pub const X86_FEATURE_HW_PSTATE: u32 = 232;
pub const X86_FEATURE_PROC_FEEDBACK: u32 = 233;
pub const X86_FEATURE_SME: u32 = 234;
pub const X86_FEATURE_PTI: u32 = 235;
pub const X86_FEATURE_RETPOLINE: u32 = 236;
pub const X86_FEATURE_RETPOLINE_AMD: u32 = 237;
pub const X86_FEATURE_INTEL_PPIN: u32 = 238;
pub const X86_FEATURE_CDP_L2: u32 = 239;
pub const X86_FEATURE_MSR_SPEC_CTRL: u32 = 240;
pub const X86_FEATURE_SSBD: u32 = 241;
pub const X86_FEATURE_MBA: u32 = 242;
pub const X86_FEATURE_RSB_CTXSW: u32 = 243;
pub const X86_FEATURE_USE_IBPB: u32 = 245;
pub const X86_FEATURE_USE_IBRS_FW: u32 = 246;
pub const X86_FEATURE_SPEC_STORE_BYPASS_DISABLE: u32 = 247;
pub const X86_FEATURE_LS_CFG_SSBD: u32 = 248;
pub const X86_FEATURE_IBRS: u32 = 249;
pub const X86_FEATURE_IBPB: u32 = 250;
pub const X86_FEATURE_STIBP: u32 = 251;
pub const X86_FEATURE_ZEN: u32 = 252;
pub const X86_FEATURE_L1TF_PTEINV: u32 = 253;
pub const X86_FEATURE_IBRS_ENHANCED: u32 = 254;
pub const X86_FEATURE_TPR_SHADOW: u32 = 256;
pub const X86_FEATURE_VNMI: u32 = 257;
pub const X86_FEATURE_FLEXPRIORITY: u32 = 258;
pub const X86_FEATURE_EPT: u32 = 259;
pub const X86_FEATURE_VPID: u32 = 260;
pub const X86_FEATURE_VMMCALL: u32 = 271;
pub const X86_FEATURE_XENPV: u32 = 272;
pub const X86_FEATURE_FSGSBASE: u32 = 288;
pub const X86_FEATURE_TSC_ADJUST: u32 = 289;
pub const X86_FEATURE_BMI1: u32 = 291;
pub const X86_FEATURE_HLE: u32 = 292;
pub const X86_FEATURE_AVX2: u32 = 293;
pub const X86_FEATURE_FDP_EXCPTN_ONLY: u32 = 294;
pub const X86_FEATURE_SMEP: u32 = 295;
pub const X86_FEATURE_BMI2: u32 = 296;
pub const X86_FEATURE_ERMS: u32 = 297;
pub const X86_FEATURE_INVPCID: u32 = 298;
pub const X86_FEATURE_RTM: u32 = 299;
pub const X86_FEATURE_CQM: u32 = 300;
pub const X86_FEATURE_ZERO_FCS_FDS: u32 = 301;
pub const X86_FEATURE_MPX: u32 = 302;
pub const X86_FEATURE_RDT_A: u32 = 303;
pub const X86_FEATURE_AVX512F: u32 = 304;
pub const X86_FEATURE_AVX512DQ: u32 = 305;
pub const X86_FEATURE_RDSEED: u32 = 306;
pub const X86_FEATURE_ADX: u32 = 307;
pub const X86_FEATURE_SMAP: u32 = 308;
pub const X86_FEATURE_AVX512IFMA: u32 = 309;
pub const X86_FEATURE_CLFLUSHOPT: u32 = 311;
pub const X86_FEATURE_CLWB: u32 = 312;
pub const X86_FEATURE_INTEL_PT: u32 = 313;
pub const X86_FEATURE_AVX512PF: u32 = 314;
pub const X86_FEATURE_AVX512ER: u32 = 315;
pub const X86_FEATURE_AVX512CD: u32 = 316;
pub const X86_FEATURE_SHA_NI: u32 = 317;
pub const X86_FEATURE_AVX512BW: u32 = 318;
pub const X86_FEATURE_AVX512VL: u32 = 319;
pub const X86_FEATURE_XSAVEOPT: u32 = 320;
pub const X86_FEATURE_XSAVEC: u32 = 321;
pub const X86_FEATURE_XGETBV1: u32 = 322;
pub const X86_FEATURE_XSAVES: u32 = 323;
pub const X86_FEATURE_CQM_LLC: u32 = 352;
pub const X86_FEATURE_CQM_OCCUP_LLC: u32 = 353;
pub const X86_FEATURE_CQM_MBM_TOTAL: u32 = 354;
pub const X86_FEATURE_CQM_MBM_LOCAL: u32 = 355;
pub const X86_FEATURE_FENCE_SWAPGS_USER: u32 = 356;
pub const X86_FEATURE_FENCE_SWAPGS_KERNEL: u32 = 357;
pub const X86_FEATURE_CLZERO: u32 = 416;
pub const X86_FEATURE_IRPERF: u32 = 417;
pub const X86_FEATURE_XSAVEERPTR: u32 = 418;
pub const X86_FEATURE_AMD_IBPB: u32 = 428;
pub const X86_FEATURE_AMD_IBRS: u32 = 430;
pub const X86_FEATURE_AMD_STIBP: u32 = 431;
pub const X86_FEATURE_AMD_STIBP_ALWAYS_ON: u32 = 433;
pub const X86_FEATURE_AMD_SSBD: u32 = 440;
pub const X86_FEATURE_VIRT_SSBD: u32 = 441;
pub const X86_FEATURE_AMD_SSB_NO: u32 = 442;
pub const X86_FEATURE_DTHERM: u32 = 448;
pub const X86_FEATURE_IDA: u32 = 449;
pub const X86_FEATURE_ARAT: u32 = 450;
pub const X86_FEATURE_PLN: u32 = 452;
pub const X86_FEATURE_PTS: u32 = 454;
pub const X86_FEATURE_HWP: u32 = 455;
pub const X86_FEATURE_HWP_NOTIFY: u32 = 456;
pub const X86_FEATURE_HWP_ACT_WINDOW: u32 = 457;
pub const X86_FEATURE_HWP_EPP: u32 = 458;
pub const X86_FEATURE_HWP_PKG_REQ: u32 = 459;
pub const X86_FEATURE_NPT: u32 = 480;
pub const X86_FEATURE_LBRV: u32 = 481;
pub const X86_FEATURE_SVML: u32 = 482;
pub const X86_FEATURE_NRIPS: u32 = 483;
pub const X86_FEATURE_TSCRATEMSR: u32 = 484;
pub const X86_FEATURE_VMCBCLEAN: u32 = 485;
pub const X86_FEATURE_FLUSHBYASID: u32 = 486;
pub const X86_FEATURE_DECODEASSISTS: u32 = 487;
pub const X86_FEATURE_PAUSEFILTER: u32 = 490;
pub const X86_FEATURE_PFTHRESHOLD: u32 = 492;
pub const X86_FEATURE_AVIC: u32 = 493;
pub const X86_FEATURE_V_VMSAVE_VMLOAD: u32 = 495;
pub const X86_FEATURE_VGIF: u32 = 496;
pub const X86_FEATURE_AVX512VBMI: u32 = 513;
pub const X86_FEATURE_UMIP: u32 = 514;
pub const X86_FEATURE_PKU: u32 = 515;
pub const X86_FEATURE_OSPKE: u32 = 516;
pub const X86_FEATURE_AVX512_VBMI2: u32 = 518;
pub const X86_FEATURE_GFNI: u32 = 520;
pub const X86_FEATURE_VAES: u32 = 521;
pub const X86_FEATURE_VPCLMULQDQ: u32 = 522;
pub const X86_FEATURE_AVX512_VNNI: u32 = 523;
pub const X86_FEATURE_AVX512_BITALG: u32 = 524;
pub const X86_FEATURE_TME: u32 = 525;
pub const X86_FEATURE_AVX512_VPOPCNTDQ: u32 = 526;
pub const X86_FEATURE_LA57: u32 = 528;
pub const X86_FEATURE_RDPID: u32 = 534;
pub const X86_FEATURE_OVERFLOW_RECOV: u32 = 544;
pub const X86_FEATURE_SUCCOR: u32 = 545;
pub const X86_FEATURE_SMCA: u32 = 547;
pub const X86_FEATURE_AVX512_4VNNIW: u32 = 578;
pub const X86_FEATURE_AVX512_4FMAPS: u32 = 579;
pub const X86_FEATURE_SRBDS_CTRL: u32 = 585;
pub const X86_FEATURE_MD_CLEAR: u32 = 586;
pub const X86_FEATURE_TSX_FORCE_ABORT: u32 = 589;
pub const X86_FEATURE_PCONFIG: u32 = 594;
pub const X86_FEATURE_SPEC_CTRL: u32 = 602;
pub const X86_FEATURE_INTEL_STIBP: u32 = 603;
pub const X86_FEATURE_FLUSH_L1D: u32 = 604;
pub const X86_FEATURE_ARCH_CAPABILITIES: u32 = 605;
pub const X86_FEATURE_SPEC_CTRL_SSBD: u32 = 607;
pub const POPCNT32: &'static [u8; 26usize] = b".byte 0xf3,0x0f,0xb8,0xc7\0";
pub const POPCNT64: &'static [u8; 31usize] = b".byte 0xf3,0x48,0x0f,0xb8,0xc7\0";
pub const REG_IN: &'static [u8; 2usize] = b"D\0";
pub const REG_OUT: &'static [u8; 2usize] = b"a\0";
pub const BITOP_LE_SWIZZLE: u32 = 0;
pub const UINT_MAX: i32 = -1;
pub const ULONG_MAX: i32 = -1;
pub const ULLONG_MAX: i32 = -1;
pub const STACK_MAGIC: u32 = 3735928559;
pub const READ: u32 = 0;
pub const WRITE: u32 = 1;
pub const PANIC_CPU_INVALID: i32 = -1;
pub const TAINT_PROPRIETARY_MODULE: u32 = 0;
pub const TAINT_FORCED_MODULE: u32 = 1;
pub const TAINT_CPU_OUT_OF_SPEC: u32 = 2;
pub const TAINT_FORCED_RMMOD: u32 = 3;
pub const TAINT_MACHINE_CHECK: u32 = 4;
pub const TAINT_BAD_PAGE: u32 = 5;
pub const TAINT_USER: u32 = 6;
pub const TAINT_DIE: u32 = 7;
pub const TAINT_OVERRIDDEN_ACPI_TABLE: u32 = 8;
pub const TAINT_WARN: u32 = 9;
pub const TAINT_CRAP: u32 = 10;
pub const TAINT_FIRMWARE_WORKAROUND: u32 = 11;
pub const TAINT_OOT_MODULE: u32 = 12;
pub const TAINT_UNSIGNED_MODULE: u32 = 13;
pub const TAINT_SOFTLOCKUP: u32 = 14;
pub const TAINT_LIVEPATCH: u32 = 15;
pub const TAINT_AUX: u32 = 16;
pub const TAINT_FLAGS_COUNT: u32 = 17;
pub const PAGE_POISON: u32 = 170;
pub const RED_INACTIVE: u64 = 718624318471594843;
pub const RED_ACTIVE: i64 = -2863912482255763264;
pub const SLUB_RED_INACTIVE: u32 = 187;
pub const SLUB_RED_ACTIVE: u32 = 204;
pub const POISON_INUSE: u32 = 90;
pub const POISON_FREE: u32 = 107;
pub const POISON_END: u32 = 165;
pub const POISON_FREE_INITMEM: u32 = 204;
pub const JBD_POISON_FREE: u32 = 91;
pub const JBD2_POISON_FREE: u32 = 92;
pub const POOL_POISON_FREED: u32 = 167;
pub const POOL_POISON_ALLOCATED: u32 = 169;
pub const ATM_POISON_FREE: u32 = 18;
pub const ATM_POISON: u32 = 3735928559;
pub const MUTEX_DEBUG_INIT: u32 = 17;
pub const MUTEX_DEBUG_FREE: u32 = 34;
pub const FLEX_ARRAY_FREE: u32 = 108;
pub const KEY_DESTROY: u32 = 189;
pub const PREEMPT_BITS: u32 = 8;
pub const SOFTIRQ_BITS: u32 = 8;
pub const HARDIRQ_BITS: u32 = 4;
pub const NMI_BITS: u32 = 1;
pub const PREEMPT_SHIFT: u32 = 0;
pub const SOFTIRQ_SHIFT: u32 = 8;
pub const HARDIRQ_SHIFT: u32 = 16;
pub const NMI_SHIFT: u32 = 20;
pub const PREEMPT_OFFSET: u32 = 1;
pub const SOFTIRQ_OFFSET: u32 = 256;
pub const HARDIRQ_OFFSET: u32 = 65536;
pub const NMI_OFFSET: u32 = 1048576;
pub const SOFTIRQ_DISABLE_OFFSET: u32 = 512;
pub const PREEMPT_NEED_RESCHED: u32 = 2147483648;
pub const INIT_PREEMPT_COUNT: u32 = 1;
pub const NR_CPUS: u32 = 8192;
pub const MIN_THREADS_LEFT_FOR_ROOT: u32 = 4;
pub const PIDS_PER_CPU_DEFAULT: u32 = 1024;
pub const PIDS_PER_CPU_MIN: u32 = 8;
pub const PER_CPU_SHARED_ALIGNED_SECTION: &'static [u8; 1usize] = b"\0";
pub const PER_CPU_ALIGNED_SECTION: &'static [u8; 1usize] = b"\0";
pub const PER_CPU_FIRST_SECTION: &'static [u8; 8usize] = b"..first\0";
pub const PER_CPU_BASE_SECTION: &'static [u8; 14usize] = b".data..percpu\0";
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ERESTARTSYS: u32 = 512;
pub const ERESTARTNOINTR: u32 = 513;
pub const ERESTARTNOHAND: u32 = 514;
pub const ENOIOCTLCMD: u32 = 515;
pub const ERESTART_RESTARTBLOCK: u32 = 516;
pub const EPROBE_DEFER: u32 = 517;
pub const EOPENSTALE: u32 = 518;
pub const EBADHANDLE: u32 = 521;
pub const ENOTSYNC: u32 = 522;
pub const EBADCOOKIE: u32 = 523;
pub const ENOTSUPP: u32 = 524;
pub const ETOOSMALL: u32 = 525;
pub const ESERVERFAULT: u32 = 526;
pub const EBADTYPE: u32 = 527;
pub const EJUKEBOX: u32 = 528;
pub const EIOCBQUEUED: u32 = 529;
pub const ERECALLCONFLICT: u32 = 530;
pub const SETUP_NONE: u32 = 0;
pub const SETUP_E820_EXT: u32 = 1;
pub const SETUP_DTB: u32 = 2;
pub const SETUP_PCI: u32 = 3;
pub const SETUP_EFI: u32 = 4;
pub const SETUP_APPLE_PROPERTIES: u32 = 5;
pub const RAMDISK_IMAGE_START_MASK: u32 = 2047;
pub const RAMDISK_PROMPT_FLAG: u32 = 32768;
pub const RAMDISK_LOAD_FLAG: u32 = 16384;
pub const LOADED_HIGH: u32 = 1;
pub const KASLR_FLAG: u32 = 2;
pub const QUIET_FLAG: u32 = 32;
pub const KEEP_SEGMENTS: u32 = 64;
pub const CAN_USE_HEAP: u32 = 128;
pub const XLF_KERNEL_64: u32 = 1;
pub const XLF_CAN_BE_LOADED_ABOVE_4G: u32 = 2;
pub const XLF_EFI_HANDOVER_32: u32 = 4;
pub const XLF_EFI_HANDOVER_64: u32 = 8;
pub const XLF_EFI_KEXEC: u32 = 16;
pub const VIDEO_TYPE_MDA: u32 = 16;
pub const VIDEO_TYPE_CGA: u32 = 17;
pub const VIDEO_TYPE_EGAM: u32 = 32;
pub const VIDEO_TYPE_EGAC: u32 = 33;
pub const VIDEO_TYPE_VGAC: u32 = 34;
pub const VIDEO_TYPE_VLFB: u32 = 35;
pub const VIDEO_TYPE_PICA_S3: u32 = 48;
pub const VIDEO_TYPE_MIPS_G364: u32 = 49;
pub const VIDEO_TYPE_SGI: u32 = 51;
pub const VIDEO_TYPE_TGAC: u32 = 64;
pub const VIDEO_TYPE_SUN: u32 = 80;
pub const VIDEO_TYPE_SUNPCI: u32 = 81;
pub const VIDEO_TYPE_PMAC: u32 = 96;
pub const VIDEO_TYPE_EFI: u32 = 112;
pub const VIDEO_FLAGS_NOCURSOR: u32 = 1;
pub const VIDEO_CAPABILITY_SKIP_QUIRKS: u32 = 1;
pub const VIDEO_CAPABILITY_64BIT_BASE: u32 = 2;
pub const APM_STATE_READY: u32 = 0;
pub const APM_STATE_STANDBY: u32 = 1;
pub const APM_STATE_SUSPEND: u32 = 2;
pub const APM_STATE_OFF: u32 = 3;
pub const APM_STATE_BUSY: u32 = 4;
pub const APM_STATE_REJECT: u32 = 5;
pub const APM_STATE_OEM_SYS: u32 = 32;
pub const APM_STATE_OEM_DEV: u32 = 64;
pub const APM_STATE_DISABLE: u32 = 0;
pub const APM_STATE_ENABLE: u32 = 1;
pub const APM_STATE_DISENGAGE: u32 = 0;
pub const APM_STATE_ENGAGE: u32 = 1;
pub const APM_SYS_STANDBY: u32 = 1;
pub const APM_SYS_SUSPEND: u32 = 2;
pub const APM_NORMAL_RESUME: u32 = 3;
pub const APM_CRITICAL_RESUME: u32 = 4;
pub const APM_LOW_BATTERY: u32 = 5;
pub const APM_POWER_STATUS_CHANGE: u32 = 6;
pub const APM_UPDATE_TIME: u32 = 7;
pub const APM_CRITICAL_SUSPEND: u32 = 8;
pub const APM_USER_STANDBY: u32 = 9;
pub const APM_USER_SUSPEND: u32 = 10;
pub const APM_STANDBY_RESUME: u32 = 11;
pub const APM_CAPABILITY_CHANGE: u32 = 12;
pub const APM_USER_HIBERNATION: u32 = 13;
pub const APM_HIBERNATION_RESUME: u32 = 14;
pub const APM_SUCCESS: u32 = 0;
pub const APM_DISABLED: u32 = 1;
pub const APM_CONNECTED: u32 = 2;
pub const APM_NOT_CONNECTED: u32 = 3;
pub const APM_16_CONNECTED: u32 = 5;
pub const APM_16_UNSUPPORTED: u32 = 6;
pub const APM_32_CONNECTED: u32 = 7;
pub const APM_32_UNSUPPORTED: u32 = 8;
pub const APM_BAD_DEVICE: u32 = 9;
pub const APM_BAD_PARAM: u32 = 10;
pub const APM_NOT_ENGAGED: u32 = 11;
pub const APM_BAD_FUNCTION: u32 = 12;
pub const APM_RESUME_DISABLED: u32 = 13;
pub const APM_NO_ERROR: u32 = 83;
pub const APM_BAD_STATE: u32 = 96;
pub const APM_NO_EVENTS: u32 = 128;
pub const APM_NOT_PRESENT: u32 = 134;
pub const APM_DEVICE_BIOS: u32 = 0;
pub const APM_DEVICE_ALL: u32 = 1;
pub const APM_DEVICE_DISPLAY: u32 = 256;
pub const APM_DEVICE_STORAGE: u32 = 512;
pub const APM_DEVICE_PARALLEL: u32 = 768;
pub const APM_DEVICE_SERIAL: u32 = 1024;
pub const APM_DEVICE_NETWORK: u32 = 1280;
pub const APM_DEVICE_PCMCIA: u32 = 1536;
pub const APM_DEVICE_BATTERY: u32 = 32768;
pub const APM_DEVICE_OEM: u32 = 57344;
pub const APM_DEVICE_OLD_ALL: u32 = 65535;
pub const APM_DEVICE_CLASS: u32 = 255;
pub const APM_DEVICE_MASK: u32 = 65280;
pub const APM_MAX_BATTERIES: u32 = 2;
pub const APM_CAP_GLOBAL_STANDBY: u32 = 1;
pub const APM_CAP_GLOBAL_SUSPEND: u32 = 2;
pub const APM_CAP_RESUME_STANDBY_TIMER: u32 = 4;
pub const APM_CAP_RESUME_SUSPEND_TIMER: u32 = 8;
pub const APM_CAP_RESUME_STANDBY_RING: u32 = 16;
pub const APM_CAP_RESUME_SUSPEND_RING: u32 = 32;
pub const APM_CAP_RESUME_STANDBY_PCMCIA: u32 = 64;
pub const APM_CAP_RESUME_SUSPEND_PCMCIA: u32 = 128;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_SIZEBITS: u32 = 14;
pub const _IOC_DIRBITS: u32 = 2;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 16383;
pub const _IOC_DIRMASK: u32 = 3;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 30;
pub const _IOC_NONE: u32 = 0;
pub const _IOC_WRITE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const IOC_IN: u32 = 1073741824;
pub const IOC_OUT: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 1073676288;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const APM_16_BIT_SUPPORT: u32 = 1;
pub const APM_32_BIT_SUPPORT: u32 = 2;
pub const APM_IDLE_SLOWS_CLOCK: u32 = 4;
pub const APM_BIOS_DISABLED: u32 = 8;
pub const APM_BIOS_DISENGAGED: u32 = 16;
pub const APM_FUNC_INST_CHECK: u32 = 21248;
pub const APM_FUNC_REAL_CONN: u32 = 21249;
pub const APM_FUNC_16BIT_CONN: u32 = 21250;
pub const APM_FUNC_32BIT_CONN: u32 = 21251;
pub const APM_FUNC_DISCONN: u32 = 21252;
pub const APM_FUNC_IDLE: u32 = 21253;
pub const APM_FUNC_BUSY: u32 = 21254;
pub const APM_FUNC_SET_STATE: u32 = 21255;
pub const APM_FUNC_ENABLE_PM: u32 = 21256;
pub const APM_FUNC_RESTORE_BIOS: u32 = 21257;
pub const APM_FUNC_GET_STATUS: u32 = 21258;
pub const APM_FUNC_GET_EVENT: u32 = 21259;
pub const APM_FUNC_GET_STATE: u32 = 21260;
pub const APM_FUNC_ENABLE_DEV_PM: u32 = 21261;
pub const APM_FUNC_VERSION: u32 = 21262;
pub const APM_FUNC_ENGAGE_PM: u32 = 21263;
pub const APM_FUNC_GET_CAP: u32 = 21264;
pub const APM_FUNC_RESUME_TIMER: u32 = 21265;
pub const APM_FUNC_RESUME_ON_RING: u32 = 21266;
pub const APM_FUNC_TIMER: u32 = 21267;
pub const APM_FUNC_DISABLE_TIMER: u32 = 0;
pub const APM_FUNC_GET_TIMER: u32 = 1;
pub const APM_FUNC_SET_TIMER: u32 = 2;
pub const APM_FUNC_DISABLE_RING: u32 = 0;
pub const APM_FUNC_ENABLE_RING: u32 = 1;
pub const APM_FUNC_GET_RING: u32 = 2;
pub const APM_FUNC_TIMER_DISABLE: u32 = 0;
pub const APM_FUNC_TIMER_ENABLE: u32 = 1;
pub const APM_FUNC_TIMER_GET: u32 = 2;
pub const EDDNR: u32 = 489;
pub const EDDBUF: u32 = 3328;
pub const EDDMAXNR: u32 = 6;
pub const EDDEXTSIZE: u32 = 8;
pub const EDDPARMSIZE: u32 = 74;
pub const CHECKEXTENSIONSPRESENT: u32 = 65;
pub const GETDEVICEPARAMETERS: u32 = 72;
pub const LEGACYGETDEVICEPARAMETERS: u32 = 8;
pub const EDDMAGIC1: u32 = 21930;
pub const EDDMAGIC2: u32 = 43605;
pub const READ_SECTORS: u32 = 2;
pub const EDD_MBR_SIG_OFFSET: u32 = 440;
pub const EDD_MBR_SIG_BUF: u32 = 656;
pub const EDD_MBR_SIG_MAX: u32 = 16;
pub const EDD_MBR_SIG_NR_BUF: u32 = 490;
pub const EDD_EXT_FIXED_DISK_ACCESS: u32 = 1;
pub const EDD_EXT_DEVICE_LOCKING_AND_EJECTING: u32 = 2;
pub const EDD_EXT_ENHANCED_DISK_DRIVE_SUPPORT: u32 = 4;
pub const EDD_EXT_64BIT_EXTENSIONS: u32 = 8;
pub const EDD_INFO_DMA_BOUNDARY_ERROR_TRANSPARENT: u32 = 1;
pub const EDD_INFO_GEOMETRY_VALID: u32 = 2;
pub const EDD_INFO_REMOVABLE: u32 = 4;
pub const EDD_INFO_WRITE_VERIFY: u32 = 8;
pub const EDD_INFO_MEDIA_CHANGE_NOTIFICATION: u32 = 16;
pub const EDD_INFO_LOCKABLE: u32 = 32;
pub const EDD_INFO_NO_MEDIA_PRESENT: u32 = 64;
pub const EDD_INFO_USE_INT13_FN50: u32 = 128;
pub const E820_MAX_ENTRIES_ZEROPAGE: u32 = 128;
pub const PAGE_SHIFT: u32 = 12;
pub const HUGE_MAX_HSTATE: u32 = 2;
pub const KASAN_STACK_ORDER: u32 = 0;
pub const THREAD_SIZE_ORDER: u32 = 2;
pub const EXCEPTION_STACK_ORDER: u32 = 0;
pub const DEBUG_STACK_ORDER: u32 = 1;
pub const IRQ_STACK_ORDER: u32 = 2;
pub const DOUBLEFAULT_STACK: u32 = 1;
pub const NMI_STACK: u32 = 2;
pub const DEBUG_STACK: u32 = 3;
pub const MCE_STACK: u32 = 4;
pub const N_EXCEPTION_STACKS: u32 = 4;
pub const __PHYSICAL_MASK_SHIFT: u32 = 46;
pub const __VIRTUAL_MASK_SHIFT: u32 = 47;
pub const KERNEL_IMAGE_SIZE: u32 = 1073741824;
pub const __HAVE_ARCH_GATE_AREA: u32 = 1;
pub const TOP_OF_KERNEL_STACK_PADDING: u32 = 0;
pub const X86_EFLAGS_CF_BIT: u32 = 0;
pub const X86_EFLAGS_FIXED_BIT: u32 = 1;
pub const X86_EFLAGS_PF_BIT: u32 = 2;
pub const X86_EFLAGS_AF_BIT: u32 = 4;
pub const X86_EFLAGS_ZF_BIT: u32 = 6;
pub const X86_EFLAGS_SF_BIT: u32 = 7;
pub const X86_EFLAGS_TF_BIT: u32 = 8;
pub const X86_EFLAGS_IF_BIT: u32 = 9;
pub const X86_EFLAGS_DF_BIT: u32 = 10;
pub const X86_EFLAGS_OF_BIT: u32 = 11;
pub const X86_EFLAGS_IOPL_BIT: u32 = 12;
pub const X86_EFLAGS_NT_BIT: u32 = 14;
pub const X86_EFLAGS_RF_BIT: u32 = 16;
pub const X86_EFLAGS_VM_BIT: u32 = 17;
pub const X86_EFLAGS_AC_BIT: u32 = 18;
pub const X86_EFLAGS_VIF_BIT: u32 = 19;
pub const X86_EFLAGS_VIP_BIT: u32 = 20;
pub const X86_EFLAGS_ID_BIT: u32 = 21;
pub const X86_CR0_PE_BIT: u32 = 0;
pub const X86_CR0_MP_BIT: u32 = 1;
pub const X86_CR0_EM_BIT: u32 = 2;
pub const X86_CR0_TS_BIT: u32 = 3;
pub const X86_CR0_ET_BIT: u32 = 4;
pub const X86_CR0_NE_BIT: u32 = 5;
pub const X86_CR0_WP_BIT: u32 = 16;
pub const X86_CR0_AM_BIT: u32 = 18;
pub const X86_CR0_NW_BIT: u32 = 29;
pub const X86_CR0_CD_BIT: u32 = 30;
pub const X86_CR0_PG_BIT: u32 = 31;
pub const X86_CR3_PWT_BIT: u32 = 3;
pub const X86_CR3_PCD_BIT: u32 = 4;
pub const X86_CR3_PCID_BITS: u32 = 12;
pub const X86_CR3_PCID_NOFLUSH_BIT: u32 = 63;
pub const X86_CR4_VME_BIT: u32 = 0;
pub const X86_CR4_PVI_BIT: u32 = 1;
pub const X86_CR4_TSD_BIT: u32 = 2;
pub const X86_CR4_DE_BIT: u32 = 3;
pub const X86_CR4_PSE_BIT: u32 = 4;
pub const X86_CR4_PAE_BIT: u32 = 5;
pub const X86_CR4_MCE_BIT: u32 = 6;
pub const X86_CR4_PGE_BIT: u32 = 7;
pub const X86_CR4_PCE_BIT: u32 = 8;
pub const X86_CR4_OSFXSR_BIT: u32 = 9;
pub const X86_CR4_OSXMMEXCPT_BIT: u32 = 10;
pub const X86_CR4_UMIP_BIT: u32 = 11;
pub const X86_CR4_LA57_BIT: u32 = 12;
pub const X86_CR4_VMXE_BIT: u32 = 13;
pub const X86_CR4_SMXE_BIT: u32 = 14;
pub const X86_CR4_FSGSBASE_BIT: u32 = 16;
pub const X86_CR4_PCIDE_BIT: u32 = 17;
pub const X86_CR4_OSXSAVE_BIT: u32 = 18;
pub const X86_CR4_SMEP_BIT: u32 = 20;
pub const X86_CR4_SMAP_BIT: u32 = 21;
pub const X86_CR4_PKE_BIT: u32 = 22;
pub const CX86_PCR0: u32 = 32;
pub const CX86_GCR: u32 = 184;
pub const CX86_CCR0: u32 = 192;
pub const CX86_CCR1: u32 = 193;
pub const CX86_CCR2: u32 = 194;
pub const CX86_CCR3: u32 = 195;
pub const CX86_CCR4: u32 = 232;
pub const CX86_CCR5: u32 = 233;
pub const CX86_CCR6: u32 = 234;
pub const CX86_CCR7: u32 = 235;
pub const CX86_PCR1: u32 = 240;
pub const CX86_DIR0: u32 = 254;
pub const CX86_DIR1: u32 = 255;
pub const CX86_ARR_BASE: u32 = 196;
pub const CX86_RCR_BASE: u32 = 220;
pub const X86_VM_MASK: u32 = 0;
pub const CR3_PCID_MASK: u32 = 4095;
pub const X86_CR3_PTI_PCID_USER_BIT: u32 = 11;
pub const GDT_ENTRY_BOOT_CS: u32 = 2;
pub const GDT_ENTRY_BOOT_DS: u32 = 3;
pub const GDT_ENTRY_BOOT_TSS: u32 = 4;
pub const __BOOT_CS: u32 = 16;
pub const __BOOT_DS: u32 = 24;
pub const __BOOT_TSS: u32 = 32;
pub const SEGMENT_RPL_MASK: u32 = 3;
pub const USER_RPL: u32 = 3;
pub const SEGMENT_TI_MASK: u32 = 4;
pub const SEGMENT_LDT: u32 = 4;
pub const SEGMENT_GDT: u32 = 0;
pub const GDT_ENTRY_INVALID_SEG: u32 = 0;
pub const GDT_ENTRY_KERNEL32_CS: u32 = 1;
pub const GDT_ENTRY_KERNEL_CS: u32 = 2;
pub const GDT_ENTRY_KERNEL_DS: u32 = 3;
pub const GDT_ENTRY_DEFAULT_USER32_CS: u32 = 4;
pub const GDT_ENTRY_DEFAULT_USER_DS: u32 = 5;
pub const GDT_ENTRY_DEFAULT_USER_CS: u32 = 6;
pub const GDT_ENTRY_TSS: u32 = 8;
pub const GDT_ENTRY_LDT: u32 = 10;
pub const GDT_ENTRY_TLS_MIN: u32 = 12;
pub const GDT_ENTRY_TLS_MAX: u32 = 14;
pub const GDT_ENTRY_PER_CPU: u32 = 15;
pub const GDT_ENTRIES: u32 = 16;
pub const __KERNEL32_CS: u32 = 8;
pub const __KERNEL_CS: u32 = 16;
pub const __KERNEL_DS: u32 = 24;
pub const __USER32_CS: u32 = 35;
pub const __USER_DS: u32 = 43;
pub const __USER32_DS: u32 = 43;
pub const __USER_CS: u32 = 51;
pub const __PER_CPU_SEG: u32 = 123;
pub const IDT_ENTRIES: u32 = 256;
pub const NUM_EXCEPTION_VECTORS: u32 = 32;
pub const EXCEPTION_ERRCODE_MASK: u32 = 163072;
pub const GDT_SIZE: u32 = 128;
pub const GDT_ENTRY_TLS_ENTRIES: u32 = 3;
pub const TLS_SIZE: u32 = 24;
pub const EARLY_IDT_HANDLER_SIZE: u32 = 9;
pub const XEN_EARLY_IDT_HANDLER_SIZE: u32 = 8;
pub const FRAME_SIZE: u32 = 168;
pub const PTRACE_GETREGS: u32 = 12;
pub const PTRACE_SETREGS: u32 = 13;
pub const PTRACE_GETFPREGS: u32 = 14;
pub const PTRACE_SETFPREGS: u32 = 15;
pub const PTRACE_GETFPXREGS: u32 = 18;
pub const PTRACE_SETFPXREGS: u32 = 19;
pub const PTRACE_OLDSETOPTIONS: u32 = 21;
pub const PTRACE_GET_THREAD_AREA: u32 = 25;
pub const PTRACE_SET_THREAD_AREA: u32 = 26;
pub const PTRACE_ARCH_PRCTL: u32 = 30;
pub const PTRACE_SYSEMU: u32 = 31;
pub const PTRACE_SYSEMU_SINGLESTEP: u32 = 32;
pub const PTRACE_SINGLEBLOCK: u32 = 33;
pub const CLBR_NONE: u32 = 0;
pub const CLBR_EAX: u32 = 1;
pub const CLBR_ECX: u32 = 2;
pub const CLBR_EDX: u32 = 4;
pub const CLBR_EDI: u32 = 8;
pub const CLBR_RAX: u32 = 1;
pub const CLBR_RCX: u32 = 2;
pub const CLBR_RDX: u32 = 4;
pub const CLBR_RDI: u32 = 8;
pub const CLBR_RSI: u32 = 16;
pub const CLBR_R8: u32 = 32;
pub const CLBR_R9: u32 = 64;
pub const CLBR_R10: u32 = 128;
pub const CLBR_R11: u32 = 256;
pub const CLBR_ANY: u32 = 511;
pub const CLBR_ARG_REGS: u32 = 126;
pub const CLBR_RET_REG: u32 = 1;
pub const CLBR_SCRATCH: u32 = 384;
pub const CLBR_CALLEE_SAVE: u32 = 510;
pub const AR_TYPE_RODATA: u32 = 0;
pub const AR_TYPE_RWDATA: u32 = 512;
pub const AR_TYPE_RODATA_EXPDOWN: u32 = 1024;
pub const AR_TYPE_RWDATA_EXPDOWN: u32 = 1536;
pub const AR_TYPE_XOCODE: u32 = 2048;
pub const AR_TYPE_XRCODE: u32 = 2560;
pub const AR_TYPE_XOCODE_CONF: u32 = 3072;
pub const AR_TYPE_XRCODE_CONF: u32 = 3584;
pub const AR_TYPE_MASK: u32 = 3584;
pub const AR_DPL0: u32 = 0;
pub const AR_DPL3: u32 = 24576;
pub const AR_DPL_MASK: u32 = 24576;
pub const AR_A: u32 = 256;
pub const AR_S: u32 = 4096;
pub const AR_P: u32 = 32768;
pub const AR_AVL: u32 = 1048576;
pub const AR_L: u32 = 2097152;
pub const AR_DB: u32 = 4194304;
pub const AR_G: u32 = 8388608;
pub const KM_TYPE_NR: u32 = 20;
pub const FIRST_USER_ADDRESS: u32 = 0;
pub const _PAGE_BIT_PRESENT: u32 = 0;
pub const _PAGE_BIT_RW: u32 = 1;
pub const _PAGE_BIT_USER: u32 = 2;
pub const _PAGE_BIT_PWT: u32 = 3;
pub const _PAGE_BIT_PCD: u32 = 4;
pub const _PAGE_BIT_ACCESSED: u32 = 5;
pub const _PAGE_BIT_DIRTY: u32 = 6;
pub const _PAGE_BIT_PSE: u32 = 7;
pub const _PAGE_BIT_PAT: u32 = 7;
pub const _PAGE_BIT_GLOBAL: u32 = 8;
pub const _PAGE_BIT_SOFTW1: u32 = 9;
pub const _PAGE_BIT_SOFTW2: u32 = 10;
pub const _PAGE_BIT_SOFTW3: u32 = 11;
pub const _PAGE_BIT_PAT_LARGE: u32 = 12;
pub const _PAGE_BIT_SOFTW4: u32 = 58;
pub const _PAGE_BIT_PKEY_BIT0: u32 = 59;
pub const _PAGE_BIT_PKEY_BIT1: u32 = 60;
pub const _PAGE_BIT_PKEY_BIT2: u32 = 61;
pub const _PAGE_BIT_PKEY_BIT3: u32 = 62;
pub const _PAGE_BIT_NX: u32 = 63;
pub const _PAGE_BIT_SPECIAL: u32 = 9;
pub const _PAGE_BIT_CPA_TEST: u32 = 9;
pub const _PAGE_BIT_SOFT_DIRTY: u32 = 11;
pub const _PAGE_BIT_DEVMAP: u32 = 58;
pub const _PAGE_BIT_PROTNONE: u32 = 8;
pub const SECTION_SIZE_BITS: u32 = 27;
pub const MAX_PHYSADDR_BITS: u32 = 44;
pub const MAX_PHYSMEM_BITS: u32 = 46;
pub const SHARED_KERNEL_PMD: u32 = 0;
pub const PGDIR_SHIFT: u32 = 39;
pub const PTRS_PER_PGD: u32 = 512;
pub const PUD_SHIFT: u32 = 30;
pub const PTRS_PER_PUD: u32 = 512;
pub const PMD_SHIFT: u32 = 21;
pub const PTRS_PER_PMD: u32 = 512;
pub const PTRS_PER_PTE: u32 = 512;
pub const GUARD_HOLE_PGD_ENTRY: i32 = -256;
pub const GUARD_HOLE_SIZE: u64 = 8796093022208;
pub const GUARD_HOLE_BASE_ADDR: i64 = -140737488355328;
pub const GUARD_HOLE_END_ADDR: i64 = -131941395333120;
pub const EARLY_DYNAMIC_PAGE_TABLES: u32 = 64;
pub const PGD_ALLOWED_BITS: i32 = -1;
pub const __PAGETABLE_P4D_FOLDED: u32 = 1;
pub const P4D_SHIFT: u32 = 39;
pub const PTRS_PER_P4D: u32 = 1;
pub const P4D_SIZE: u64 = 549755813888;
pub const P4D_MASK: i64 = -549755813888;
pub const __X86_CASE_B: u32 = 1;
pub const __X86_CASE_W: u32 = 2;
pub const __X86_CASE_L: u32 = 4;
pub const __X86_CASE_Q: u32 = 8;
pub const MSR_EFER: u32 = 3221225600;
pub const MSR_STAR: u32 = 3221225601;
pub const MSR_LSTAR: u32 = 3221225602;
pub const MSR_CSTAR: u32 = 3221225603;
pub const MSR_SYSCALL_MASK: u32 = 3221225604;
pub const MSR_FS_BASE: u32 = 3221225728;
pub const MSR_GS_BASE: u32 = 3221225729;
pub const MSR_KERNEL_GS_BASE: u32 = 3221225730;
pub const MSR_TSC_AUX: u32 = 3221225731;
pub const _EFER_SCE: u32 = 0;
pub const _EFER_LME: u32 = 8;
pub const _EFER_LMA: u32 = 10;
pub const _EFER_NX: u32 = 11;
pub const _EFER_SVME: u32 = 12;
pub const _EFER_LMSLE: u32 = 13;
pub const _EFER_FFXSR: u32 = 14;
pub const EFER_SCE: u32 = 1;
pub const EFER_LME: u32 = 256;
pub const EFER_LMA: u32 = 1024;
pub const EFER_NX: u32 = 2048;
pub const EFER_SVME: u32 = 4096;
pub const EFER_LMSLE: u32 = 8192;
pub const EFER_FFXSR: u32 = 16384;
pub const MSR_IA32_SPEC_CTRL: u32 = 72;
pub const SPEC_CTRL_STIBP_SHIFT: u32 = 1;
pub const SPEC_CTRL_SSBD_SHIFT: u32 = 2;
pub const MSR_IA32_PRED_CMD: u32 = 73;
pub const MSR_PPIN_CTL: u32 = 78;
pub const MSR_PPIN: u32 = 79;
pub const MSR_IA32_PERFCTR0: u32 = 193;
pub const MSR_IA32_PERFCTR1: u32 = 194;
pub const MSR_FSB_FREQ: u32 = 205;
pub const MSR_PLATFORM_INFO: u32 = 206;
pub const MSR_PLATFORM_INFO_CPUID_FAULT_BIT: u32 = 31;
pub const MSR_PKG_CST_CONFIG_CONTROL: u32 = 226;
pub const NHM_C3_AUTO_DEMOTE: u32 = 33554432;
pub const NHM_C1_AUTO_DEMOTE: u32 = 67108864;
pub const ATM_LNC_C6_AUTO_DEMOTE: u32 = 33554432;
pub const SNB_C1_AUTO_UNDEMOTE: u32 = 134217728;
pub const SNB_C3_AUTO_UNDEMOTE: u32 = 268435456;
pub const MSR_MTRRcap: u32 = 254;
pub const MSR_IA32_ARCH_CAPABILITIES: u32 = 266;
pub const MSR_IA32_FLUSH_CMD: u32 = 267;
pub const MSR_IA32_BBL_CR_CTL: u32 = 281;
pub const MSR_IA32_BBL_CR_CTL3: u32 = 286;
pub const MSR_IA32_TSX_CTRL: u32 = 290;
pub const MSR_IA32_MCU_OPT_CTRL: u32 = 291;
pub const MSR_IA32_SYSENTER_CS: u32 = 372;
pub const MSR_IA32_SYSENTER_ESP: u32 = 373;
pub const MSR_IA32_SYSENTER_EIP: u32 = 374;
pub const MSR_IA32_MCG_CAP: u32 = 377;
pub const MSR_IA32_MCG_STATUS: u32 = 378;
pub const MSR_IA32_MCG_CTL: u32 = 379;
pub const MSR_IA32_MCG_EXT_CTL: u32 = 1232;
pub const MSR_OFFCORE_RSP_0: u32 = 422;
pub const MSR_OFFCORE_RSP_1: u32 = 423;
pub const MSR_TURBO_RATIO_LIMIT: u32 = 429;
pub const MSR_TURBO_RATIO_LIMIT1: u32 = 430;
pub const MSR_TURBO_RATIO_LIMIT2: u32 = 431;
pub const MSR_LBR_SELECT: u32 = 456;
pub const MSR_LBR_TOS: u32 = 457;
pub const MSR_LBR_NHM_FROM: u32 = 1664;
pub const MSR_LBR_NHM_TO: u32 = 1728;
pub const MSR_LBR_CORE_FROM: u32 = 64;
pub const MSR_LBR_CORE_TO: u32 = 96;
pub const MSR_LBR_INFO_0: u32 = 3520;
pub const LBR_INFO_CYCLES: u32 = 65535;
pub const MSR_IA32_PEBS_ENABLE: u32 = 1009;
pub const MSR_IA32_DS_AREA: u32 = 1536;
pub const MSR_IA32_PERF_CAPABILITIES: u32 = 837;
pub const MSR_PEBS_LD_LAT_THRESHOLD: u32 = 1014;
pub const MSR_IA32_RTIT_CTL: u32 = 1392;
pub const MSR_IA32_RTIT_STATUS: u32 = 1393;
pub const MSR_IA32_RTIT_ADDR0_A: u32 = 1408;
pub const MSR_IA32_RTIT_ADDR0_B: u32 = 1409;
pub const MSR_IA32_RTIT_ADDR1_A: u32 = 1410;
pub const MSR_IA32_RTIT_ADDR1_B: u32 = 1411;
pub const MSR_IA32_RTIT_ADDR2_A: u32 = 1412;
pub const MSR_IA32_RTIT_ADDR2_B: u32 = 1413;
pub const MSR_IA32_RTIT_ADDR3_A: u32 = 1414;
pub const MSR_IA32_RTIT_ADDR3_B: u32 = 1415;
pub const MSR_IA32_RTIT_CR3_MATCH: u32 = 1394;
pub const MSR_IA32_RTIT_OUTPUT_BASE: u32 = 1376;
pub const MSR_IA32_RTIT_OUTPUT_MASK: u32 = 1377;
pub const MSR_MTRRfix64K_00000: u32 = 592;
pub const MSR_MTRRfix16K_80000: u32 = 600;
pub const MSR_MTRRfix16K_A0000: u32 = 601;
pub const MSR_MTRRfix4K_C0000: u32 = 616;
pub const MSR_MTRRfix4K_C8000: u32 = 617;
pub const MSR_MTRRfix4K_D0000: u32 = 618;
pub const MSR_MTRRfix4K_D8000: u32 = 619;
pub const MSR_MTRRfix4K_E0000: u32 = 620;
pub const MSR_MTRRfix4K_E8000: u32 = 621;
pub const MSR_MTRRfix4K_F0000: u32 = 622;
pub const MSR_MTRRfix4K_F8000: u32 = 623;
pub const MSR_MTRRdefType: u32 = 767;
pub const MSR_IA32_CR_PAT: u32 = 631;
pub const MSR_IA32_DEBUGCTLMSR: u32 = 473;
pub const MSR_IA32_LASTBRANCHFROMIP: u32 = 475;
pub const MSR_IA32_LASTBRANCHTOIP: u32 = 476;
pub const MSR_IA32_LASTINTFROMIP: u32 = 477;
pub const MSR_IA32_LASTINTTOIP: u32 = 478;
pub const DEBUGCTLMSR_LBR: u32 = 1;
pub const DEBUGCTLMSR_BTF_SHIFT: u32 = 1;
pub const DEBUGCTLMSR_BTF: u32 = 2;
pub const DEBUGCTLMSR_TR: u32 = 64;
pub const DEBUGCTLMSR_BTS: u32 = 128;
pub const DEBUGCTLMSR_BTINT: u32 = 256;
pub const DEBUGCTLMSR_BTS_OFF_OS: u32 = 512;
pub const DEBUGCTLMSR_BTS_OFF_USR: u32 = 1024;
pub const DEBUGCTLMSR_FREEZE_LBRS_ON_PMI: u32 = 2048;
pub const DEBUGCTLMSR_FREEZE_IN_SMM_BIT: u32 = 14;
pub const DEBUGCTLMSR_FREEZE_IN_SMM: u32 = 16384;
pub const MSR_PEBS_FRONTEND: u32 = 1015;
pub const MSR_IA32_POWER_CTL: u32 = 508;
pub const MSR_IA32_MC0_CTL: u32 = 1024;
pub const MSR_IA32_MC0_STATUS: u32 = 1025;
pub const MSR_IA32_MC0_ADDR: u32 = 1026;
pub const MSR_IA32_MC0_MISC: u32 = 1027;
pub const MSR_PKG_C3_RESIDENCY: u32 = 1016;
pub const MSR_PKG_C6_RESIDENCY: u32 = 1017;
pub const MSR_ATOM_PKG_C6_RESIDENCY: u32 = 1018;
pub const MSR_PKG_C7_RESIDENCY: u32 = 1018;
pub const MSR_CORE_C3_RESIDENCY: u32 = 1020;
pub const MSR_CORE_C6_RESIDENCY: u32 = 1021;
pub const MSR_CORE_C7_RESIDENCY: u32 = 1022;
pub const MSR_KNL_CORE_C6_RESIDENCY: u32 = 1023;
pub const MSR_PKG_C2_RESIDENCY: u32 = 1549;
pub const MSR_PKG_C8_RESIDENCY: u32 = 1584;
pub const MSR_PKG_C9_RESIDENCY: u32 = 1585;
pub const MSR_PKG_C10_RESIDENCY: u32 = 1586;
pub const MSR_PKGC3_IRTL: u32 = 1546;
pub const MSR_PKGC6_IRTL: u32 = 1547;
pub const MSR_PKGC7_IRTL: u32 = 1548;
pub const MSR_PKGC8_IRTL: u32 = 1587;
pub const MSR_PKGC9_IRTL: u32 = 1588;
pub const MSR_PKGC10_IRTL: u32 = 1589;
pub const MSR_RAPL_POWER_UNIT: u32 = 1542;
pub const MSR_PKG_POWER_LIMIT: u32 = 1552;
pub const MSR_PKG_ENERGY_STATUS: u32 = 1553;
pub const MSR_PKG_PERF_STATUS: u32 = 1555;
pub const MSR_PKG_POWER_INFO: u32 = 1556;
pub const MSR_DRAM_POWER_LIMIT: u32 = 1560;
pub const MSR_DRAM_ENERGY_STATUS: u32 = 1561;
pub const MSR_DRAM_PERF_STATUS: u32 = 1563;
pub const MSR_DRAM_POWER_INFO: u32 = 1564;
pub const MSR_PP0_POWER_LIMIT: u32 = 1592;
pub const MSR_PP0_ENERGY_STATUS: u32 = 1593;
pub const MSR_PP0_POLICY: u32 = 1594;
pub const MSR_PP0_PERF_STATUS: u32 = 1595;
pub const MSR_PP1_POWER_LIMIT: u32 = 1600;
pub const MSR_PP1_ENERGY_STATUS: u32 = 1601;
pub const MSR_PP1_POLICY: u32 = 1602;
pub const MSR_CONFIG_TDP_NOMINAL: u32 = 1608;
pub const MSR_CONFIG_TDP_LEVEL_1: u32 = 1609;
pub const MSR_CONFIG_TDP_LEVEL_2: u32 = 1610;
pub const MSR_CONFIG_TDP_CONTROL: u32 = 1611;
pub const MSR_TURBO_ACTIVATION_RATIO: u32 = 1612;
pub const MSR_PLATFORM_ENERGY_STATUS: u32 = 1613;
pub const MSR_PKG_WEIGHTED_CORE_C0_RES: u32 = 1624;
pub const MSR_PKG_ANY_CORE_C0_RES: u32 = 1625;
pub const MSR_PKG_ANY_GFXE_C0_RES: u32 = 1626;
pub const MSR_PKG_BOTH_CORE_GFXE_C0_RES: u32 = 1627;
pub const MSR_CORE_C1_RES: u32 = 1632;
pub const MSR_MODULE_C6_RES_MS: u32 = 1636;
pub const MSR_CC6_DEMOTION_POLICY_CONFIG: u32 = 1640;
pub const MSR_MC6_DEMOTION_POLICY_CONFIG: u32 = 1641;
pub const MSR_ATOM_CORE_RATIOS: u32 = 1642;
pub const MSR_ATOM_CORE_VIDS: u32 = 1643;
pub const MSR_ATOM_CORE_TURBO_RATIOS: u32 = 1644;
pub const MSR_ATOM_CORE_TURBO_VIDS: u32 = 1645;
pub const MSR_CORE_PERF_LIMIT_REASONS: u32 = 1680;
pub const MSR_GFX_PERF_LIMIT_REASONS: u32 = 1712;
pub const MSR_RING_PERF_LIMIT_REASONS: u32 = 1713;
pub const MSR_PPERF: u32 = 1614;
pub const MSR_PERF_LIMIT_REASONS: u32 = 1615;
pub const MSR_PM_ENABLE: u32 = 1904;
pub const MSR_HWP_CAPABILITIES: u32 = 1905;
pub const MSR_HWP_REQUEST_PKG: u32 = 1906;
pub const MSR_HWP_INTERRUPT: u32 = 1907;
pub const MSR_HWP_REQUEST: u32 = 1908;
pub const MSR_HWP_STATUS: u32 = 1911;
pub const HWP_BASE_BIT: u32 = 128;
pub const HWP_NOTIFICATIONS_BIT: u32 = 256;
pub const HWP_ACTIVITY_WINDOW_BIT: u32 = 512;
pub const HWP_ENERGY_PERF_PREFERENCE_BIT: u32 = 1024;
pub const HWP_PACKAGE_LEVEL_REQUEST_BIT: u32 = 2048;
pub const HWP_EPP_PERFORMANCE: u32 = 0;
pub const HWP_EPP_BALANCE_PERFORMANCE: u32 = 128;
pub const HWP_EPP_BALANCE_POWERSAVE: u32 = 192;
pub const HWP_EPP_POWERSAVE: u32 = 255;
pub const MSR_AMD64_MC0_MASK: u32 = 3221291076;
pub const MSR_IA32_MC0_CTL2: u32 = 640;
pub const MSR_P6_PERFCTR0: u32 = 193;
pub const MSR_P6_PERFCTR1: u32 = 194;
pub const MSR_P6_EVNTSEL0: u32 = 390;
pub const MSR_P6_EVNTSEL1: u32 = 391;
pub const MSR_KNC_PERFCTR0: u32 = 32;
pub const MSR_KNC_PERFCTR1: u32 = 33;
pub const MSR_KNC_EVNTSEL0: u32 = 40;
pub const MSR_KNC_EVNTSEL1: u32 = 41;
pub const MSR_IA32_PMC0: u32 = 1217;
pub const MSR_AMD64_PATCH_LEVEL: u32 = 139;
pub const MSR_AMD64_TSC_RATIO: u32 = 3221225732;
pub const MSR_AMD64_NB_CFG: u32 = 3221291039;
pub const MSR_AMD64_CPUID_FN_1: u32 = 3221295108;
pub const MSR_AMD64_PATCH_LOADER: u32 = 3221291040;
pub const MSR_AMD64_OSVW_ID_LENGTH: u32 = 3221291328;
pub const MSR_AMD64_OSVW_STATUS: u32 = 3221291329;
pub const MSR_AMD64_LS_CFG: u32 = 3221295136;
pub const MSR_AMD64_DC_CFG: u32 = 3221295138;
pub const MSR_AMD64_BU_CFG2: u32 = 3221295146;
pub const MSR_AMD64_IBSFETCHCTL: u32 = 3221295152;
pub const MSR_AMD64_IBSFETCHLINAD: u32 = 3221295153;
pub const MSR_AMD64_IBSFETCHPHYSAD: u32 = 3221295154;
pub const MSR_AMD64_IBSFETCH_REG_COUNT: u32 = 3;
pub const MSR_AMD64_IBSFETCH_REG_MASK: u32 = 7;
pub const MSR_AMD64_IBSOPCTL: u32 = 3221295155;
pub const MSR_AMD64_IBSOPRIP: u32 = 3221295156;
pub const MSR_AMD64_IBSOPDATA: u32 = 3221295157;
pub const MSR_AMD64_IBSOPDATA2: u32 = 3221295158;
pub const MSR_AMD64_IBSOPDATA3: u32 = 3221295159;
pub const MSR_AMD64_IBSDCLINAD: u32 = 3221295160;
pub const MSR_AMD64_IBSDCPHYSAD: u32 = 3221295161;
pub const MSR_AMD64_IBSOP_REG_COUNT: u32 = 7;
pub const MSR_AMD64_IBSOP_REG_MASK: u32 = 127;
pub const MSR_AMD64_IBSCTL: u32 = 3221295162;
pub const MSR_AMD64_IBSBRTARGET: u32 = 3221295163;
pub const MSR_AMD64_ICIBSEXTDCTL: u32 = 3221295164;
pub const MSR_AMD64_IBSOPDATA4: u32 = 3221295165;
pub const MSR_AMD64_IBS_REG_COUNT_MAX: u32 = 8;
pub const MSR_AMD64_SEV: u32 = 3221291313;
pub const MSR_AMD64_SEV_ENABLED_BIT: u32 = 0;
pub const MSR_AMD64_VIRT_SPEC_CTRL: u32 = 3221291295;
pub const MSR_F17H_IRPERF: u32 = 3221225705;
pub const MSR_F16H_L2I_PERF_CTL: u32 = 3221291568;
pub const MSR_F16H_L2I_PERF_CTR: u32 = 3221291569;
pub const MSR_F16H_DR1_ADDR_MASK: u32 = 3221295129;
pub const MSR_F16H_DR2_ADDR_MASK: u32 = 3221295130;
pub const MSR_F16H_DR3_ADDR_MASK: u32 = 3221295131;
pub const MSR_F16H_DR0_ADDR_MASK: u32 = 3221295143;
pub const MSR_F15H_PERF_CTL: u32 = 3221291520;
pub const MSR_F15H_PERF_CTR: u32 = 3221291521;
pub const MSR_F15H_NB_PERF_CTL: u32 = 3221291584;
pub const MSR_F15H_NB_PERF_CTR: u32 = 3221291585;
pub const MSR_F15H_PTSC: u32 = 3221291648;
pub const MSR_F15H_IC_CFG: u32 = 3221295137;
pub const MSR_F15H_EX_CFG: u32 = 3221295148;
pub const MSR_FAM10H_MMIO_CONF_BASE: u32 = 3221291096;
pub const FAM10H_MMIO_CONF_ENABLE: u32 = 1;
pub const FAM10H_MMIO_CONF_BUSRANGE_MASK: u32 = 15;
pub const FAM10H_MMIO_CONF_BUSRANGE_SHIFT: u32 = 2;
pub const FAM10H_MMIO_CONF_BASE_MASK: u32 = 268435455;
pub const FAM10H_MMIO_CONF_BASE_SHIFT: u32 = 20;
pub const MSR_FAM10H_NODE_ID: u32 = 3221295116;
pub const MSR_F10H_DECFG: u32 = 3221295145;
pub const MSR_F10H_DECFG_LFENCE_SERIALIZE_BIT: u32 = 1;
pub const MSR_K8_TOP_MEM1: u32 = 3221291034;
pub const MSR_K8_TOP_MEM2: u32 = 3221291037;
pub const MSR_K8_SYSCFG: u32 = 3221291024;
pub const MSR_K8_SYSCFG_MEM_ENCRYPT_BIT: u32 = 23;
pub const MSR_K8_INT_PENDING_MSG: u32 = 3221291093;
pub const K8_INTP_C1E_ACTIVE_MASK: u32 = 402653184;
pub const MSR_K8_TSEG_ADDR: u32 = 3221291282;
pub const MSR_K8_TSEG_MASK: u32 = 3221291283;
pub const K8_MTRRFIXRANGE_DRAM_ENABLE: u32 = 262144;
pub const K8_MTRRFIXRANGE_DRAM_MODIFY: u32 = 524288;
pub const K8_MTRR_RDMEM_WRMEM_MASK: u32 = 404232216;
pub const MSR_K7_EVNTSEL0: u32 = 3221291008;
pub const MSR_K7_PERFCTR0: u32 = 3221291012;
pub const MSR_K7_EVNTSEL1: u32 = 3221291009;
pub const MSR_K7_PERFCTR1: u32 = 3221291013;
pub const MSR_K7_EVNTSEL2: u32 = 3221291010;
pub const MSR_K7_PERFCTR2: u32 = 3221291014;
pub const MSR_K7_EVNTSEL3: u32 = 3221291011;
pub const MSR_K7_PERFCTR3: u32 = 3221291015;
pub const MSR_K7_CLK_CTL: u32 = 3221291035;
pub const MSR_K7_HWCR: u32 = 3221291029;
pub const MSR_K7_HWCR_IRPERF_EN_BIT: u32 = 30;
pub const MSR_K7_FID_VID_CTL: u32 = 3221291073;
pub const MSR_K7_FID_VID_STATUS: u32 = 3221291074;
pub const MSR_K6_WHCR: u32 = 3221225602;
pub const MSR_K6_UWCCR: u32 = 3221225605;
pub const MSR_K6_EPMR: u32 = 3221225606;
pub const MSR_K6_PSOR: u32 = 3221225607;
pub const MSR_K6_PFIR: u32 = 3221225608;
pub const MSR_IDT_FCR1: u32 = 263;
pub const MSR_IDT_FCR2: u32 = 264;
pub const MSR_IDT_FCR3: u32 = 265;
pub const MSR_IDT_FCR4: u32 = 266;
pub const MSR_IDT_MCR0: u32 = 272;
pub const MSR_IDT_MCR1: u32 = 273;
pub const MSR_IDT_MCR2: u32 = 274;
pub const MSR_IDT_MCR3: u32 = 275;
pub const MSR_IDT_MCR4: u32 = 276;
pub const MSR_IDT_MCR5: u32 = 277;
pub const MSR_IDT_MCR6: u32 = 278;
pub const MSR_IDT_MCR7: u32 = 279;
pub const MSR_IDT_MCR_CTRL: u32 = 288;
pub const MSR_VIA_FCR: u32 = 4359;
pub const MSR_VIA_LONGHAUL: u32 = 4362;
pub const MSR_VIA_RNG: u32 = 4363;
pub const MSR_VIA_BCR2: u32 = 4423;
pub const MSR_TMTA_LONGRUN_CTRL: u32 = 2156298256;
pub const MSR_TMTA_LONGRUN_FLAGS: u32 = 2156298257;
pub const MSR_TMTA_LRTI_READOUT: u32 = 2156298264;
pub const MSR_TMTA_LRTI_VOLT_MHZ: u32 = 2156298266;
pub const MSR_IA32_P5_MC_ADDR: u32 = 0;
pub const MSR_IA32_P5_MC_TYPE: u32 = 1;
pub const MSR_IA32_TSC: u32 = 16;
pub const MSR_IA32_PLATFORM_ID: u32 = 23;
pub const MSR_IA32_EBL_CR_POWERON: u32 = 42;
pub const MSR_EBC_FREQUENCY_ID: u32 = 44;
pub const MSR_SMI_COUNT: u32 = 52;
pub const MSR_IA32_FEATURE_CONTROL: u32 = 58;
pub const MSR_IA32_TSC_ADJUST: u32 = 59;
pub const MSR_IA32_BNDCFGS: u32 = 3472;
pub const MSR_IA32_BNDCFGS_RSVD: u32 = 4092;
pub const MSR_IA32_XSS: u32 = 3488;
pub const FEATURE_CONTROL_LOCKED: u32 = 1;
pub const FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX: u32 = 2;
pub const FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX: u32 = 4;
pub const FEATURE_CONTROL_LMCE: u32 = 1048576;
pub const MSR_IA32_APICBASE: u32 = 27;
pub const MSR_IA32_APICBASE_BSP: u32 = 256;
pub const MSR_IA32_APICBASE_ENABLE: u32 = 2048;
pub const MSR_IA32_APICBASE_BASE: u32 = 4294963200;
pub const MSR_IA32_TSCDEADLINE: u32 = 1760;
pub const MSR_IA32_UCODE_WRITE: u32 = 121;
pub const MSR_IA32_UCODE_REV: u32 = 139;
pub const MSR_IA32_SMM_MONITOR_CTL: u32 = 155;
pub const MSR_IA32_SMBASE: u32 = 158;
pub const MSR_IA32_PERF_STATUS: u32 = 408;
pub const MSR_IA32_PERF_CTL: u32 = 409;
pub const INTEL_PERF_CTL_MASK: u32 = 65535;
pub const MSR_AMD_PSTATE_DEF_BASE: u32 = 3221291108;
pub const MSR_AMD_PERF_STATUS: u32 = 3221291107;
pub const MSR_AMD_PERF_CTL: u32 = 3221291106;
pub const MSR_IA32_MPERF: u32 = 231;
pub const MSR_IA32_APERF: u32 = 232;
pub const MSR_IA32_THERM_CONTROL: u32 = 410;
pub const MSR_IA32_THERM_INTERRUPT: u32 = 411;
pub const THERM_INT_HIGH_ENABLE: u32 = 1;
pub const THERM_INT_LOW_ENABLE: u32 = 2;
pub const THERM_INT_PLN_ENABLE: u32 = 16777216;
pub const MSR_IA32_THERM_STATUS: u32 = 412;
pub const THERM_STATUS_PROCHOT: u32 = 1;
pub const THERM_STATUS_POWER_LIMIT: u32 = 1024;
pub const MSR_THERM2_CTL: u32 = 413;
pub const MSR_THERM2_CTL_TM_SELECT: u32 = 65536;
pub const MSR_IA32_MISC_ENABLE: u32 = 416;
pub const MSR_IA32_TEMPERATURE_TARGET: u32 = 418;
pub const MSR_MISC_FEATURE_CONTROL: u32 = 420;
pub const MSR_MISC_PWR_MGMT: u32 = 426;
pub const MSR_IA32_ENERGY_PERF_BIAS: u32 = 432;
pub const ENERGY_PERF_BIAS_PERFORMANCE: u32 = 0;
pub const ENERGY_PERF_BIAS_BALANCE_PERFORMANCE: u32 = 4;
pub const ENERGY_PERF_BIAS_NORMAL: u32 = 6;
pub const ENERGY_PERF_BIAS_BALANCE_POWERSAVE: u32 = 8;
pub const ENERGY_PERF_BIAS_POWERSAVE: u32 = 15;
pub const MSR_IA32_PACKAGE_THERM_STATUS: u32 = 433;
pub const PACKAGE_THERM_STATUS_PROCHOT: u32 = 1;
pub const PACKAGE_THERM_STATUS_POWER_LIMIT: u32 = 1024;
pub const MSR_IA32_PACKAGE_THERM_INTERRUPT: u32 = 434;
pub const PACKAGE_THERM_INT_HIGH_ENABLE: u32 = 1;
pub const PACKAGE_THERM_INT_LOW_ENABLE: u32 = 2;
pub const PACKAGE_THERM_INT_PLN_ENABLE: u32 = 16777216;
pub const THERM_INT_THRESHOLD0_ENABLE: u32 = 32768;
pub const THERM_SHIFT_THRESHOLD0: u32 = 8;
pub const THERM_MASK_THRESHOLD0: u32 = 32512;
pub const THERM_INT_THRESHOLD1_ENABLE: u32 = 8388608;
pub const THERM_SHIFT_THRESHOLD1: u32 = 16;
pub const THERM_MASK_THRESHOLD1: u32 = 8323072;
pub const THERM_STATUS_THRESHOLD0: u32 = 64;
pub const THERM_LOG_THRESHOLD0: u32 = 128;
pub const THERM_STATUS_THRESHOLD1: u32 = 256;
pub const THERM_LOG_THRESHOLD1: u32 = 512;
pub const MSR_IA32_MISC_ENABLE_FAST_STRING_BIT: u32 = 0;
pub const MSR_IA32_MISC_ENABLE_FAST_STRING: u32 = 1;
pub const MSR_IA32_MISC_ENABLE_TCC_BIT: u32 = 1;
pub const MSR_IA32_MISC_ENABLE_TCC: u32 = 2;
pub const MSR_IA32_MISC_ENABLE_EMON_BIT: u32 = 7;
pub const MSR_IA32_MISC_ENABLE_EMON: u32 = 128;
pub const MSR_IA32_MISC_ENABLE_BTS_UNAVAIL_BIT: u32 = 11;
pub const MSR_IA32_MISC_ENABLE_BTS_UNAVAIL: u32 = 2048;
pub const MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL_BIT: u32 = 12;
pub const MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL: u32 = 4096;
pub const MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP_BIT: u32 = 16;
pub const MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP: u32 = 65536;
pub const MSR_IA32_MISC_ENABLE_MWAIT_BIT: u32 = 18;
pub const MSR_IA32_MISC_ENABLE_MWAIT: u32 = 262144;
pub const MSR_IA32_MISC_ENABLE_LIMIT_CPUID_BIT: u32 = 22;
pub const MSR_IA32_MISC_ENABLE_LIMIT_CPUID: u32 = 4194304;
pub const MSR_IA32_MISC_ENABLE_XTPR_DISABLE_BIT: u32 = 23;
pub const MSR_IA32_MISC_ENABLE_XTPR_DISABLE: u32 = 8388608;
pub const MSR_IA32_MISC_ENABLE_XD_DISABLE_BIT: u32 = 34;
pub const MSR_IA32_MISC_ENABLE_XD_DISABLE: u64 = 17179869184;
pub const MSR_IA32_MISC_ENABLE_X87_COMPAT_BIT: u32 = 2;
pub const MSR_IA32_MISC_ENABLE_X87_COMPAT: u32 = 4;
pub const MSR_IA32_MISC_ENABLE_TM1_BIT: u32 = 3;
pub const MSR_IA32_MISC_ENABLE_TM1: u32 = 8;
pub const MSR_IA32_MISC_ENABLE_SPLIT_LOCK_DISABLE_BIT: u32 = 4;
pub const MSR_IA32_MISC_ENABLE_SPLIT_LOCK_DISABLE: u32 = 16;
pub const MSR_IA32_MISC_ENABLE_L3CACHE_DISABLE_BIT: u32 = 6;
pub const MSR_IA32_MISC_ENABLE_L3CACHE_DISABLE: u32 = 64;
pub const MSR_IA32_MISC_ENABLE_SUPPRESS_LOCK_BIT: u32 = 8;
pub const MSR_IA32_MISC_ENABLE_SUPPRESS_LOCK: u32 = 256;
pub const MSR_IA32_MISC_ENABLE_PREFETCH_DISABLE_BIT: u32 = 9;
pub const MSR_IA32_MISC_ENABLE_PREFETCH_DISABLE: u32 = 512;
pub const MSR_IA32_MISC_ENABLE_FERR_BIT: u32 = 10;
pub const MSR_IA32_MISC_ENABLE_FERR: u32 = 1024;
pub const MSR_IA32_MISC_ENABLE_FERR_MULTIPLEX_BIT: u32 = 10;
pub const MSR_IA32_MISC_ENABLE_FERR_MULTIPLEX: u32 = 1024;
pub const MSR_IA32_MISC_ENABLE_TM2_BIT: u32 = 13;
pub const MSR_IA32_MISC_ENABLE_TM2: u32 = 8192;
pub const MSR_IA32_MISC_ENABLE_ADJ_PREF_DISABLE_BIT: u32 = 19;
pub const MSR_IA32_MISC_ENABLE_ADJ_PREF_DISABLE: u32 = 524288;
pub const MSR_IA32_MISC_ENABLE_SPEEDSTEP_LOCK_BIT: u32 = 20;
pub const MSR_IA32_MISC_ENABLE_SPEEDSTEP_LOCK: u32 = 1048576;
pub const MSR_IA32_MISC_ENABLE_L1D_CONTEXT_BIT: u32 = 24;
pub const MSR_IA32_MISC_ENABLE_L1D_CONTEXT: u32 = 16777216;
pub const MSR_IA32_MISC_ENABLE_DCU_PREF_DISABLE_BIT: u32 = 37;
pub const MSR_IA32_MISC_ENABLE_DCU_PREF_DISABLE: u64 = 137438953472;
pub const MSR_IA32_MISC_ENABLE_TURBO_DISABLE_BIT: u32 = 38;
pub const MSR_IA32_MISC_ENABLE_TURBO_DISABLE: u64 = 274877906944;
pub const MSR_IA32_MISC_ENABLE_IP_PREF_DISABLE_BIT: u32 = 39;
pub const MSR_IA32_MISC_ENABLE_IP_PREF_DISABLE: u64 = 549755813888;
pub const MSR_MISC_FEATURES_ENABLES: u32 = 320;
pub const MSR_MISC_FEATURES_ENABLES_CPUID_FAULT_BIT: u32 = 0;
pub const MSR_MISC_FEATURES_ENABLES_RING3MWAIT_BIT: u32 = 1;
pub const MSR_IA32_TSC_DEADLINE: u32 = 1760;
pub const MSR_TSX_FORCE_ABORT: u32 = 271;
pub const MSR_TFA_RTM_FORCE_ABORT_BIT: u32 = 0;
pub const MSR_IA32_MCG_EAX: u32 = 384;
pub const MSR_IA32_MCG_EBX: u32 = 385;
pub const MSR_IA32_MCG_ECX: u32 = 386;
pub const MSR_IA32_MCG_EDX: u32 = 387;
pub const MSR_IA32_MCG_ESI: u32 = 388;
pub const MSR_IA32_MCG_EDI: u32 = 389;
pub const MSR_IA32_MCG_EBP: u32 = 390;
pub const MSR_IA32_MCG_ESP: u32 = 391;
pub const MSR_IA32_MCG_EFLAGS: u32 = 392;
pub const MSR_IA32_MCG_EIP: u32 = 393;
pub const MSR_IA32_MCG_RESERVED: u32 = 394;
pub const MSR_P4_BPU_PERFCTR0: u32 = 768;
pub const MSR_P4_BPU_PERFCTR1: u32 = 769;
pub const MSR_P4_BPU_PERFCTR2: u32 = 770;
pub const MSR_P4_BPU_PERFCTR3: u32 = 771;
pub const MSR_P4_MS_PERFCTR0: u32 = 772;
pub const MSR_P4_MS_PERFCTR1: u32 = 773;
pub const MSR_P4_MS_PERFCTR2: u32 = 774;
pub const MSR_P4_MS_PERFCTR3: u32 = 775;
pub const MSR_P4_FLAME_PERFCTR0: u32 = 776;
pub const MSR_P4_FLAME_PERFCTR1: u32 = 777;
pub const MSR_P4_FLAME_PERFCTR2: u32 = 778;
pub const MSR_P4_FLAME_PERFCTR3: u32 = 779;
pub const MSR_P4_IQ_PERFCTR0: u32 = 780;
pub const MSR_P4_IQ_PERFCTR1: u32 = 781;
pub const MSR_P4_IQ_PERFCTR2: u32 = 782;
pub const MSR_P4_IQ_PERFCTR3: u32 = 783;
pub const MSR_P4_IQ_PERFCTR4: u32 = 784;
pub const MSR_P4_IQ_PERFCTR5: u32 = 785;
pub const MSR_P4_BPU_CCCR0: u32 = 864;
pub const MSR_P4_BPU_CCCR1: u32 = 865;
pub const MSR_P4_BPU_CCCR2: u32 = 866;
pub const MSR_P4_BPU_CCCR3: u32 = 867;
pub const MSR_P4_MS_CCCR0: u32 = 868;
pub const MSR_P4_MS_CCCR1: u32 = 869;
pub const MSR_P4_MS_CCCR2: u32 = 870;
pub const MSR_P4_MS_CCCR3: u32 = 871;
pub const MSR_P4_FLAME_CCCR0: u32 = 872;
pub const MSR_P4_FLAME_CCCR1: u32 = 873;
pub const MSR_P4_FLAME_CCCR2: u32 = 874;
pub const MSR_P4_FLAME_CCCR3: u32 = 875;
pub const MSR_P4_IQ_CCCR0: u32 = 876;
pub const MSR_P4_IQ_CCCR1: u32 = 877;
pub const MSR_P4_IQ_CCCR2: u32 = 878;
pub const MSR_P4_IQ_CCCR3: u32 = 879;
pub const MSR_P4_IQ_CCCR4: u32 = 880;
pub const MSR_P4_IQ_CCCR5: u32 = 881;
pub const MSR_P4_ALF_ESCR0: u32 = 970;
pub const MSR_P4_ALF_ESCR1: u32 = 971;
pub const MSR_P4_BPU_ESCR0: u32 = 946;
pub const MSR_P4_BPU_ESCR1: u32 = 947;
pub const MSR_P4_BSU_ESCR0: u32 = 928;
pub const MSR_P4_BSU_ESCR1: u32 = 929;
pub const MSR_P4_CRU_ESCR0: u32 = 952;
pub const MSR_P4_CRU_ESCR1: u32 = 953;
pub const MSR_P4_CRU_ESCR2: u32 = 972;
pub const MSR_P4_CRU_ESCR3: u32 = 973;
pub const MSR_P4_CRU_ESCR4: u32 = 992;
pub const MSR_P4_CRU_ESCR5: u32 = 993;
pub const MSR_P4_DAC_ESCR0: u32 = 936;
pub const MSR_P4_DAC_ESCR1: u32 = 937;
pub const MSR_P4_FIRM_ESCR0: u32 = 932;
pub const MSR_P4_FIRM_ESCR1: u32 = 933;
pub const MSR_P4_FLAME_ESCR0: u32 = 934;
pub const MSR_P4_FLAME_ESCR1: u32 = 935;
pub const MSR_P4_FSB_ESCR0: u32 = 930;
pub const MSR_P4_FSB_ESCR1: u32 = 931;
pub const MSR_P4_IQ_ESCR0: u32 = 954;
pub const MSR_P4_IQ_ESCR1: u32 = 955;
pub const MSR_P4_IS_ESCR0: u32 = 948;
pub const MSR_P4_IS_ESCR1: u32 = 949;
pub const MSR_P4_ITLB_ESCR0: u32 = 950;
pub const MSR_P4_ITLB_ESCR1: u32 = 951;
pub const MSR_P4_IX_ESCR0: u32 = 968;
pub const MSR_P4_IX_ESCR1: u32 = 969;
pub const MSR_P4_MOB_ESCR0: u32 = 938;
pub const MSR_P4_MOB_ESCR1: u32 = 939;
pub const MSR_P4_MS_ESCR0: u32 = 960;
pub const MSR_P4_MS_ESCR1: u32 = 961;
pub const MSR_P4_PMH_ESCR0: u32 = 940;
pub const MSR_P4_PMH_ESCR1: u32 = 941;
pub const MSR_P4_RAT_ESCR0: u32 = 956;
pub const MSR_P4_RAT_ESCR1: u32 = 957;
pub const MSR_P4_SAAT_ESCR0: u32 = 942;
pub const MSR_P4_SAAT_ESCR1: u32 = 943;
pub const MSR_P4_SSU_ESCR0: u32 = 958;
pub const MSR_P4_SSU_ESCR1: u32 = 959;
pub const MSR_P4_TBPU_ESCR0: u32 = 962;
pub const MSR_P4_TBPU_ESCR1: u32 = 963;
pub const MSR_P4_TC_ESCR0: u32 = 964;
pub const MSR_P4_TC_ESCR1: u32 = 965;
pub const MSR_P4_U2L_ESCR0: u32 = 944;
pub const MSR_P4_U2L_ESCR1: u32 = 945;
pub const MSR_P4_PEBS_MATRIX_VERT: u32 = 1010;
pub const MSR_CORE_PERF_FIXED_CTR0: u32 = 777;
pub const MSR_CORE_PERF_FIXED_CTR1: u32 = 778;
pub const MSR_CORE_PERF_FIXED_CTR2: u32 = 779;
pub const MSR_CORE_PERF_FIXED_CTR_CTRL: u32 = 909;
pub const MSR_CORE_PERF_GLOBAL_STATUS: u32 = 910;
pub const MSR_CORE_PERF_GLOBAL_CTRL: u32 = 911;
pub const MSR_CORE_PERF_GLOBAL_OVF_CTRL: u32 = 912;
pub const MSR_GEODE_BUSCONT_CONF0: u32 = 6400;
pub const MSR_IA32_VMX_BASIC: u32 = 1152;
pub const MSR_IA32_VMX_PINBASED_CTLS: u32 = 1153;
pub const MSR_IA32_VMX_PROCBASED_CTLS: u32 = 1154;
pub const MSR_IA32_VMX_EXIT_CTLS: u32 = 1155;
pub const MSR_IA32_VMX_ENTRY_CTLS: u32 = 1156;
pub const MSR_IA32_VMX_MISC: u32 = 1157;
pub const MSR_IA32_VMX_CR0_FIXED0: u32 = 1158;
pub const MSR_IA32_VMX_CR0_FIXED1: u32 = 1159;
pub const MSR_IA32_VMX_CR4_FIXED0: u32 = 1160;
pub const MSR_IA32_VMX_CR4_FIXED1: u32 = 1161;
pub const MSR_IA32_VMX_VMCS_ENUM: u32 = 1162;
pub const MSR_IA32_VMX_PROCBASED_CTLS2: u32 = 1163;
pub const MSR_IA32_VMX_EPT_VPID_CAP: u32 = 1164;
pub const MSR_IA32_VMX_TRUE_PINBASED_CTLS: u32 = 1165;
pub const MSR_IA32_VMX_TRUE_PROCBASED_CTLS: u32 = 1166;
pub const MSR_IA32_VMX_TRUE_EXIT_CTLS: u32 = 1167;
pub const MSR_IA32_VMX_TRUE_ENTRY_CTLS: u32 = 1168;
pub const MSR_IA32_VMX_VMFUNC: u32 = 1169;
pub const VMX_BASIC_VMCS_SIZE_SHIFT: u32 = 32;
pub const VMX_BASIC_TRUE_CTLS: u64 = 36028797018963968;
pub const VMX_BASIC_64: u64 = 281474976710656;
pub const VMX_BASIC_MEM_TYPE_SHIFT: u32 = 50;
pub const VMX_BASIC_MEM_TYPE_MASK: u64 = 16888498602639360;
pub const VMX_BASIC_MEM_TYPE_WB: u32 = 6;
pub const VMX_BASIC_INOUT: u64 = 18014398509481984;
pub const MSR_IA32_VMX_MISC_VMWRITE_SHADOW_RO_FIELDS: u32 = 536870912;
pub const MSR_IA32_VMX_MISC_PREEMPTION_TIMER_SCALE: u32 = 31;
pub const MSR_VM_CR: u32 = 3221291284;
pub const MSR_VM_IGNNE: u32 = 3221291285;
pub const MSR_VM_HSAVE_PA: u32 = 3221291287;
pub const RSB_CLEAR_LOOPS: u32 = 32;
pub const RSB_FILL_LOOPS: u32 = 16;
pub const ANNOTATE_NOSPEC_ALTERNATIVE: &'static [u8; 66usize] =
    b"999:\n\t.pushsection .discard.nospec\n\t.long 999b - .\n\t.popsection\n\t\0";
pub const RETPOLINE_RAX_BPF_JIT_SIZE: u32 = 17;
pub const __TICKET_LOCK_INC: u32 = 2;
pub const _Q_LOCKED_OFFSET: u32 = 0;
pub const _Q_LOCKED_BITS: u32 = 8;
pub const _Q_PENDING_OFFSET: u32 = 8;
pub const _Q_PENDING_BITS: u32 = 8;
pub const _Q_TAIL_IDX_OFFSET: u32 = 16;
pub const _Q_TAIL_IDX_BITS: u32 = 2;
pub const _Q_TAIL_CPU_OFFSET: u32 = 18;
pub const _Q_TAIL_CPU_BITS: u32 = 14;
pub const _Q_TAIL_OFFSET: u32 = 16;
pub const _Q_LOCKED_VAL: u32 = 1;
pub const _Q_PENDING_VAL: u32 = 256;
pub const FP_XSTATE_MAGIC1: u32 = 1179670611;
pub const FP_XSTATE_MAGIC2: u32 = 1179670597;
pub const X86_FXSR_MAGIC: u32 = 0;
pub const __HAVE_ARCH_MEMCPY: u32 = 1;
pub const __HAVE_ARCH_MEMCPY_MCSAFE: u32 = 1;
pub const __HAVE_ARCH_MEMCPY_FLUSHCACHE: u32 = 1;
pub const BITMAP_MEM_ALIGNMENT: u32 = 8;
pub const BITMAP_MEM_MASK: u32 = 7;
pub const TRACEPOINT_DEFS_H: u32 = 1;
pub const PV_SAVE_ALL_CALLER_REGS: &'static [u8; 79usize] =
    b"push %rcx;push %rdx;push %rsi;push %rdi;push %r8;push %r9;push %r10;push %r11;\0";
pub const PV_RESTORE_ALL_CALLER_REGS: &'static [u8; 71usize] =
    b"pop %r11;pop %r10;pop %r9;pop %r8;pop %rdi;pop %rsi;pop %rdx;pop %rcx;\0";
pub const PV_SAVE_REGS: &'static [u8; 13usize] = b"pushq %%rdi;\0";
pub const PV_RESTORE_REGS: &'static [u8; 12usize] = b"popq %%rdi;\0";
pub const PV_FLAGS_ARG: &'static [u8; 2usize] = b"D\0";
pub const MXCSR_DEFAULT: u32 = 8064;
pub const ORC_REG_UNDEFINED: u32 = 0;
pub const ORC_REG_PREV_SP: u32 = 1;
pub const ORC_REG_DX: u32 = 2;
pub const ORC_REG_DI: u32 = 3;
pub const ORC_REG_BP: u32 = 4;
pub const ORC_REG_SP: u32 = 5;
pub const ORC_REG_R10: u32 = 6;
pub const ORC_REG_R13: u32 = 7;
pub const ORC_REG_BP_INDIRECT: u32 = 8;
pub const ORC_REG_SP_INDIRECT: u32 = 9;
pub const ORC_REG_MAX: u32 = 15;
pub const ORC_TYPE_CALL: u32 = 0;
pub const ORC_TYPE_REGS: u32 = 1;
pub const ORC_TYPE_REGS_IRET: u32 = 2;
pub const UNWIND_HINT_TYPE_SAVE: u32 = 3;
pub const UNWIND_HINT_TYPE_RESTORE: u32 = 4;
pub const MAX_ERRNO: u32 = 4095;
pub const NET_IP_ALIGN: u32 = 0;
pub const HBP_NUM: u32 = 4;
pub const ARCH_MIN_MMSTRUCT_ALIGN: u32 = 0;
pub const X86_VENDOR_INTEL: u32 = 0;
pub const X86_VENDOR_CYRIX: u32 = 1;
pub const X86_VENDOR_AMD: u32 = 2;
pub const X86_VENDOR_UMC: u32 = 3;
pub const X86_VENDOR_CENTAUR: u32 = 5;
pub const X86_VENDOR_TRANSMETA: u32 = 7;
pub const X86_VENDOR_NSC: u32 = 8;
pub const X86_VENDOR_NUM: u32 = 9;
pub const X86_VENDOR_UNKNOWN: u32 = 255;
pub const IO_BITMAP_BITS: u32 = 65536;
pub const IO_BITMAP_BYTES: u32 = 8192;
pub const INVALID_IO_BITMAP_OFFSET: u32 = 32768;
pub const HAVE_ARCH_PICK_MMAP_LAYOUT: u32 = 1;
pub const BASE_PREFETCH: &'static [u8; 15usize] = b"prefetcht0 %P1\0";
pub const X86_CAP_FMT: &'static [u8; 3usize] = b"%s\0";
pub const MAX_CPU_FEATURES: u32 = 608;
pub const CPU_FEATURE_TYPEFMT: &'static [u8; 26usize] = b"x86,ven%04Xfam%04Xmod%04X\0";
pub const TIF_SYSCALL_TRACE: u32 = 0;
pub const TIF_NOTIFY_RESUME: u32 = 1;
pub const TIF_SIGPENDING: u32 = 2;
pub const TIF_NEED_RESCHED: u32 = 3;
pub const TIF_SINGLESTEP: u32 = 4;
pub const TIF_SSBD: u32 = 5;
pub const TIF_SYSCALL_EMU: u32 = 6;
pub const TIF_SYSCALL_AUDIT: u32 = 7;
pub const TIF_SECCOMP: u32 = 8;
pub const TIF_SPEC_IB: u32 = 9;
pub const TIF_SPEC_FORCE_UPDATE: u32 = 10;
pub const TIF_USER_RETURN_NOTIFY: u32 = 11;
pub const TIF_UPROBE: u32 = 12;
pub const TIF_PATCH_PENDING: u32 = 13;
pub const TIF_NOCPUID: u32 = 15;
pub const TIF_NOTSC: u32 = 16;
pub const TIF_IA32: u32 = 17;
pub const TIF_NOHZ: u32 = 19;
pub const TIF_MEMDIE: u32 = 20;
pub const TIF_POLLING_NRFLAG: u32 = 21;
pub const TIF_IO_BITMAP: u32 = 22;
pub const TIF_FORCED_TF: u32 = 24;
pub const TIF_BLOCKSTEP: u32 = 25;
pub const TIF_LAZY_MMU_UPDATES: u32 = 27;
pub const TIF_SYSCALL_TRACEPOINT: u32 = 28;
pub const TIF_ADDR32: u32 = 29;
pub const TIF_X32: u32 = 30;
pub const TIF_FSCHECK: u32 = 31;
pub const _TIF_SYSCALL_TRACE: u32 = 1;
pub const _TIF_NOTIFY_RESUME: u32 = 2;
pub const _TIF_SIGPENDING: u32 = 4;
pub const _TIF_NEED_RESCHED: u32 = 8;
pub const _TIF_SINGLESTEP: u32 = 16;
pub const _TIF_SSBD: u32 = 32;
pub const _TIF_SYSCALL_EMU: u32 = 64;
pub const _TIF_SYSCALL_AUDIT: u32 = 128;
pub const _TIF_SECCOMP: u32 = 256;
pub const _TIF_SPEC_IB: u32 = 512;
pub const _TIF_SPEC_FORCE_UPDATE: u32 = 1024;
pub const _TIF_USER_RETURN_NOTIFY: u32 = 2048;
pub const _TIF_UPROBE: u32 = 4096;
pub const _TIF_PATCH_PENDING: u32 = 8192;
pub const _TIF_NOCPUID: u32 = 32768;
pub const _TIF_NOTSC: u32 = 65536;
pub const _TIF_IA32: u32 = 131072;
pub const _TIF_NOHZ: u32 = 524288;
pub const _TIF_POLLING_NRFLAG: u32 = 2097152;
pub const _TIF_IO_BITMAP: u32 = 4194304;
pub const _TIF_FORCED_TF: u32 = 16777216;
pub const _TIF_BLOCKSTEP: u32 = 33554432;
pub const _TIF_LAZY_MMU_UPDATES: u32 = 134217728;
pub const _TIF_SYSCALL_TRACEPOINT: u32 = 268435456;
pub const _TIF_ADDR32: u32 = 536870912;
pub const _TIF_X32: u32 = 1073741824;
pub const _TIF_FSCHECK: u32 = 2147483648;
pub const _TIF_WORK_SYSCALL_ENTRY: u32 = 268960193;
pub const _TIF_ALLWORK_MASK: u32 = 2416457951;
pub const _TIF_WORK_CTXSW_BASE: u32 = 37848096;
pub const _TIF_WORK_CTXSW: u32 = 37848608;
pub const _TIF_WORK_CTXSW_PREV: u32 = 37850656;
pub const _TIF_WORK_CTXSW_NEXT: u32 = 37848608;
pub const TS_COMPAT: u32 = 2;
pub const TS_I386_REGS_POKED: u32 = 4;
pub const TS_COMPAT_RESTART: u32 = 8;
pub const PREEMPT_ENABLED: u32 = 2147483648;
pub const PREEMPT_DISABLE_OFFSET: u32 = 0;
pub const PREEMPT_LOCK_OFFSET: u32 = 0;
pub const SOFTIRQ_LOCK_OFFSET: u32 = 512;
pub const LOCK_SECTION_NAME: &'static [u8; 13usize] = b".text..lock.\0";
pub const LOCK_SECTION_END: &'static [u8; 12usize] = b".previous\n\t\0";
pub const MAX_LOCKDEP_SUBCLASSES: u32 = 8;
pub const SINGLE_DEPTH_NESTING: u32 = 1;
pub const SPINLOCK_MAGIC: u32 = 3735899821;
pub const RWLOCK_MAGIC: u32 = 3736018669;
pub const SPIN_THRESHOLD: u32 = 32768;
pub const _Q_PENDING_LOOPS: u32 = 512;
pub const _QW_WAITING: u32 = 256;
pub const _QW_LOCKED: u32 = 255;
pub const _QW_WMASK: u32 = 511;
pub const _QR_SHIFT: u32 = 9;
pub const _QR_BIAS: u32 = 512;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const P_ALL: u32 = 0;
pub const P_PID: u32 = 1;
pub const P_PGID: u32 = 2;
pub const WQ_FLAG_EXCLUSIVE: u32 = 1;
pub const WQ_FLAG_WOKEN: u32 = 2;
pub const WQ_FLAG_BOOKMARK: u32 = 4;
pub const NODES_SHIFT: u32 = 10;
pub const MAX_NUMNODES: u32 = 1024;
pub const NUMA_NO_NODE: i32 = -1;
pub const NR_PAGEFLAGS: u32 = 25;
pub const MAX_NR_ZONES: u32 = 5;
pub const NR_CPUS_BITS: u32 = 13;
pub const SPINLOCK_SIZE: u32 = 4;
pub const ZONES_SHIFT: u32 = 3;
pub const SECTIONS_SHIFT: u32 = 19;
pub const SECTIONS_WIDTH: u32 = 0;
pub const ZONES_WIDTH: u32 = 3;
pub const NODES_WIDTH: u32 = 10;
pub const LAST__PID_SHIFT: u32 = 8;
pub const LAST__PID_MASK: u32 = 255;
pub const LAST__CPU_SHIFT: u32 = 13;
pub const LAST__CPU_MASK: u32 = 8191;
pub const LAST_CPUPID_SHIFT: u32 = 21;
pub const LAST_CPUPID_WIDTH: u32 = 21;
pub const MAX_ORDER: u32 = 11;
pub const MAX_ORDER_NR_PAGES: u32 = 1024;
pub const PAGE_ALLOC_COSTLY_ORDER: u32 = 3;
pub const LRU_BASE: u32 = 0;
pub const LRU_ACTIVE: u32 = 1;
pub const LRU_FILE: u32 = 2;
pub const DEF_PRIORITY: u32 = 12;
pub const MAX_ZONES_PER_ZONELIST: u32 = 5120;
pub const OSQ_UNLOCKED_VAL: u32 = 0;
pub const RWSEM_ACTIVE_MASK: u32 = 4294967295;
pub const RWSEM_UNLOCKED_VALUE: u32 = 0;
pub const RWSEM_ACTIVE_BIAS: u32 = 1;
pub const RWSEM_WAITING_BIAS: i64 = -4294967296;
pub const RWSEM_ACTIVE_READ_BIAS: u32 = 1;
pub const RWSEM_ACTIVE_WRITE_BIAS: i64 = -4294967295;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_SGI_CYCLE: u32 = 10;
pub const CLOCK_TAI: u32 = 11;
pub const MAX_CLOCKS: u32 = 16;
pub const CLOCKS_MASK: u32 = 1;
pub const CLOCKS_MONO: u32 = 1;
pub const TIMER_ABSTIME: u32 = 1;
pub const MSEC_PER_SEC: u32 = 1000;
pub const USEC_PER_MSEC: u32 = 1000;
pub const NSEC_PER_USEC: u32 = 1000;
pub const NSEC_PER_MSEC: u32 = 1000000;
pub const USEC_PER_SEC: u32 = 1000000;
pub const NSEC_PER_SEC: u32 = 1000000000;
pub const FSEC_PER_SEC: u64 = 1000000000000000;
pub const NTP_API: u32 = 4;
pub const ADJ_OFFSET: u32 = 1;
pub const ADJ_FREQUENCY: u32 = 2;
pub const ADJ_MAXERROR: u32 = 4;
pub const ADJ_ESTERROR: u32 = 8;
pub const ADJ_STATUS: u32 = 16;
pub const ADJ_TIMECONST: u32 = 32;
pub const ADJ_TAI: u32 = 128;
pub const ADJ_SETOFFSET: u32 = 256;
pub const ADJ_MICRO: u32 = 4096;
pub const ADJ_NANO: u32 = 8192;
pub const ADJ_TICK: u32 = 16384;
pub const MOD_OFFSET: u32 = 1;
pub const MOD_FREQUENCY: u32 = 2;
pub const MOD_MAXERROR: u32 = 4;
pub const MOD_ESTERROR: u32 = 8;
pub const MOD_STATUS: u32 = 16;
pub const MOD_TIMECONST: u32 = 32;
pub const MOD_TAI: u32 = 128;
pub const MOD_MICRO: u32 = 4096;
pub const MOD_NANO: u32 = 8192;
pub const STA_PLL: u32 = 1;
pub const STA_PPSFREQ: u32 = 2;
pub const STA_PPSTIME: u32 = 4;
pub const STA_FLL: u32 = 8;
pub const STA_INS: u32 = 16;
pub const STA_DEL: u32 = 32;
pub const STA_UNSYNC: u32 = 64;
pub const STA_FREQHOLD: u32 = 128;
pub const STA_PPSSIGNAL: u32 = 256;
pub const STA_PPSJITTER: u32 = 512;
pub const STA_PPSWANDER: u32 = 1024;
pub const STA_PPSERROR: u32 = 2048;
pub const STA_CLOCKERR: u32 = 4096;
pub const STA_NANO: u32 = 8192;
pub const STA_MODE: u32 = 16384;
pub const STA_CLK: u32 = 32768;
pub const STA_RONLY: u32 = 65280;
pub const TIME_OK: u32 = 0;
pub const TIME_INS: u32 = 1;
pub const TIME_DEL: u32 = 2;
pub const TIME_OOP: u32 = 3;
pub const TIME_WAIT: u32 = 4;
pub const TIME_ERROR: u32 = 5;
pub const TIME_BAD: u32 = 5;
pub const ADJ_ADJTIME: u32 = 32768;
pub const ADJ_OFFSET_SINGLESHOT: u32 = 1;
pub const ADJ_OFFSET_READONLY: u32 = 8192;
pub const HZ: u32 = 100;
pub const EXEC_PAGESIZE: u32 = 4096;
pub const NOGROUP: i32 = -1;
pub const MAXHOSTNAMELEN: u32 = 64;
pub const USER_HZ: u32 = 100;
pub const CLOCKS_PER_SEC: u32 = 100;
pub const NS_SCALE: u32 = 10;
pub const US_SCALE: u32 = 32;
pub const SHIFT_PLL: u32 = 2;
pub const SHIFT_FLL: u32 = 2;
pub const MAXTC: u32 = 10;
pub const SHIFT_USEC: u32 = 16;
pub const PPM_SCALE_INV_SHIFT: u32 = 19;
pub const MAXPHASE: u32 = 500000000;
pub const MAXFREQ: u32 = 500000;
pub const MINSEC: u32 = 256;
pub const MAXSEC: u32 = 2048;
pub const NTP_PHASE_LIMIT: u32 = 16000000;
pub const NTP_SCALE_SHIFT: u32 = 32;
pub const NTP_INTERVAL_FREQ: u32 = 250;
pub const NTP_INTERVAL_LENGTH: u32 = 4000000;
pub const PIT_TICK_RATE: u32 = 1193182;
pub const HZ_TO_MSEC_SHR32: u32 = 29;
pub const MSEC_TO_HZ_SHR32: u32 = 33;
pub const HZ_TO_MSEC_NUM: u32 = 4;
pub const HZ_TO_MSEC_DEN: u32 = 1;
pub const MSEC_TO_HZ_NUM: u32 = 1;
pub const MSEC_TO_HZ_DEN: u32 = 4;
pub const HZ_TO_USEC_SHR32: u32 = 20;
pub const USEC_TO_HZ_SHR32: u32 = 43;
pub const HZ_TO_USEC_NUM: u32 = 4000;
pub const HZ_TO_USEC_DEN: u32 = 1;
pub const USEC_TO_HZ_NUM: u32 = 1;
pub const USEC_TO_HZ_DEN: u32 = 4000;
pub const HZ_TO_NSEC_NUM: u32 = 4000000;
pub const HZ_TO_NSEC_DEN: u32 = 1;
pub const NSEC_TO_HZ_NUM: u32 = 1;
pub const NSEC_TO_HZ_DEN: u32 = 4000000;
pub const SHIFT_HZ: u32 = 8;
pub const TICK_NSEC: u32 = 4000000;
pub const TICK_USEC: u32 = 10000;
pub const SEC_JIFFIE_SC: u32 = 23;
pub const NSEC_JIFFIE_SC: u32 = 53;
pub const TIMESTAMP_SIZE: u32 = 30;
pub const LOW_RES_NSEC: u32 = 4000000;
pub const KTIME_LOW_RES: u32 = 4000000;
pub const TIMER_CPUMASK: u32 = 262143;
pub const TIMER_MIGRATING: u32 = 262144;
pub const TIMER_BASEMASK: u32 = 524287;
pub const TIMER_DEFERRABLE: u32 = 524288;
pub const TIMER_PINNED: u32 = 1048576;
pub const TIMER_IRQSAFE: u32 = 2097152;
pub const TIMER_ARRAYSHIFT: u32 = 22;
pub const TIMER_ARRAYMASK: u32 = 4290772992;
pub const TIMER_TRACE_FLAGMASK: u32 = 3932160;
pub const NEXT_TIMER_MAX_DELTA: u32 = 1073741823;
pub const RCU_DONE_TAIL: u32 = 0;
pub const RCU_WAIT_TAIL: u32 = 1;
pub const RCU_NEXT_READY_TAIL: u32 = 2;
pub const RCU_NEXT_TAIL: u32 = 3;
pub const RCU_CBLIST_NSEGS: u32 = 4;
pub const RCU_FANOUT: u32 = 64;
pub const RCU_FANOUT_LEAF: u32 = 16;
pub const RCU_FANOUT_1: u32 = 16;
pub const RCU_FANOUT_2: u32 = 1024;
pub const RCU_FANOUT_3: u32 = 65536;
pub const RCU_FANOUT_4: u32 = 4194304;
pub const RCU_NUM_LVLS: u32 = 3;
pub const NUM_RCU_LVL_0: u32 = 1;
pub const SRCU_STATE_IDLE: u32 = 0;
pub const SRCU_STATE_SCAN1: u32 = 1;
pub const SRCU_STATE_SCAN2: u32 = 2;
pub const NOTIFY_DONE: u32 = 0;
pub const NOTIFY_OK: u32 = 1;
pub const NOTIFY_STOP_MASK: u32 = 32768;
pub const NOTIFY_BAD: u32 = 32770;
pub const NOTIFY_STOP: u32 = 32769;
pub const NETLINK_URELEASE: u32 = 1;
pub const KBD_KEYCODE: u32 = 1;
pub const KBD_UNBOUND_KEYCODE: u32 = 2;
pub const KBD_UNICODE: u32 = 3;
pub const KBD_KEYSYM: u32 = 4;
pub const KBD_POST_KEYSYM: u32 = 5;
pub const NUMA_ZONELIST_ORDER_LEN: u32 = 16;
pub const MPC_SIGNATURE: &'static [u8; 5usize] = b"PCMP\0";
pub const MP_PROCESSOR: u32 = 0;
pub const MP_BUS: u32 = 1;
pub const MP_IOAPIC: u32 = 2;
pub const MP_INTSRC: u32 = 3;
pub const MP_LINTSRC: u32 = 4;
pub const MP_TRANSLATION: u32 = 192;
pub const CPU_ENABLED: u32 = 1;
pub const CPU_BOOTPROCESSOR: u32 = 2;
pub const CPU_STEPPING_MASK: u32 = 15;
pub const CPU_MODEL_MASK: u32 = 240;
pub const CPU_FAMILY_MASK: u32 = 3840;
pub const BUSTYPE_EISA: &'static [u8; 5usize] = b"EISA\0";
pub const BUSTYPE_ISA: &'static [u8; 4usize] = b"ISA\0";
pub const BUSTYPE_INTERN: &'static [u8; 7usize] = b"INTERN\0";
pub const BUSTYPE_MCA: &'static [u8; 4usize] = b"MCA\0";
pub const BUSTYPE_VL: &'static [u8; 3usize] = b"VL\0";
pub const BUSTYPE_PCI: &'static [u8; 4usize] = b"PCI\0";
pub const BUSTYPE_PCMCIA: &'static [u8; 7usize] = b"PCMCIA\0";
pub const BUSTYPE_CBUS: &'static [u8; 5usize] = b"CBUS\0";
pub const BUSTYPE_CBUSII: &'static [u8; 7usize] = b"CBUSII\0";
pub const BUSTYPE_FUTURE: &'static [u8; 7usize] = b"FUTURE\0";
pub const BUSTYPE_MBI: &'static [u8; 4usize] = b"MBI\0";
pub const BUSTYPE_MBII: &'static [u8; 5usize] = b"MBII\0";
pub const BUSTYPE_MPI: &'static [u8; 4usize] = b"MPI\0";
pub const BUSTYPE_MPSA: &'static [u8; 5usize] = b"MPSA\0";
pub const BUSTYPE_NUBUS: &'static [u8; 6usize] = b"NUBUS\0";
pub const BUSTYPE_TC: &'static [u8; 3usize] = b"TC\0";
pub const BUSTYPE_VME: &'static [u8; 4usize] = b"VME\0";
pub const BUSTYPE_XPRESS: &'static [u8; 7usize] = b"XPRESS\0";
pub const MPC_APIC_USABLE: u32 = 1;
pub const MP_IRQDIR_DEFAULT: u32 = 0;
pub const MP_IRQDIR_HIGH: u32 = 1;
pub const MP_IRQDIR_LOW: u32 = 3;
pub const MP_APIC_ALL: u32 = 255;
pub const MPC_OEM_SIGNATURE: &'static [u8; 5usize] = b"_OEM\0";
pub const IO_APIC_DEFAULT_PHYS_BASE: u32 = 4273995776;
pub const APIC_DEFAULT_PHYS_BASE: u32 = 4276092928;
pub const IO_APIC_SLOT_SIZE: u32 = 1024;
pub const APIC_ID: u32 = 32;
pub const APIC_LVR: u32 = 48;
pub const APIC_LVR_MASK: u32 = 16711935;
pub const APIC_LVR_DIRECTED_EOI: u32 = 16777216;
pub const APIC_TASKPRI: u32 = 128;
pub const APIC_TPRI_MASK: u32 = 255;
pub const APIC_ARBPRI: u32 = 144;
pub const APIC_ARBPRI_MASK: u32 = 255;
pub const APIC_PROCPRI: u32 = 160;
pub const APIC_EOI: u32 = 176;
pub const APIC_EOI_ACK: u32 = 0;
pub const APIC_RRR: u32 = 192;
pub const APIC_LDR: u32 = 208;
pub const APIC_LDR_MASK: u32 = 4278190080;
pub const APIC_ALL_CPUS: u32 = 255;
pub const APIC_DFR: u32 = 224;
pub const APIC_DFR_CLUSTER: u32 = 268435455;
pub const APIC_DFR_FLAT: u32 = 4294967295;
pub const APIC_SPIV: u32 = 240;
pub const APIC_SPIV_DIRECTED_EOI: u32 = 4096;
pub const APIC_SPIV_FOCUS_DISABLED: u32 = 512;
pub const APIC_SPIV_APIC_ENABLED: u32 = 256;
pub const APIC_ISR: u32 = 256;
pub const APIC_ISR_NR: u32 = 8;
pub const APIC_TMR: u32 = 384;
pub const APIC_IRR: u32 = 512;
pub const APIC_ESR: u32 = 640;
pub const APIC_ESR_SEND_CS: u32 = 1;
pub const APIC_ESR_RECV_CS: u32 = 2;
pub const APIC_ESR_SEND_ACC: u32 = 4;
pub const APIC_ESR_RECV_ACC: u32 = 8;
pub const APIC_ESR_SENDILL: u32 = 32;
pub const APIC_ESR_RECVILL: u32 = 64;
pub const APIC_ESR_ILLREGA: u32 = 128;
pub const APIC_LVTCMCI: u32 = 752;
pub const APIC_ICR: u32 = 768;
pub const APIC_DEST_SELF: u32 = 262144;
pub const APIC_DEST_ALLINC: u32 = 524288;
pub const APIC_DEST_ALLBUT: u32 = 786432;
pub const APIC_ICR_RR_MASK: u32 = 196608;
pub const APIC_ICR_RR_INVALID: u32 = 0;
pub const APIC_ICR_RR_INPROG: u32 = 65536;
pub const APIC_ICR_RR_VALID: u32 = 131072;
pub const APIC_INT_LEVELTRIG: u32 = 32768;
pub const APIC_INT_ASSERT: u32 = 16384;
pub const APIC_ICR_BUSY: u32 = 4096;
pub const APIC_DEST_LOGICAL: u32 = 2048;
pub const APIC_DEST_PHYSICAL: u32 = 0;
pub const APIC_DM_FIXED: u32 = 0;
pub const APIC_DM_FIXED_MASK: u32 = 1792;
pub const APIC_DM_LOWEST: u32 = 256;
pub const APIC_DM_SMI: u32 = 512;
pub const APIC_DM_REMRD: u32 = 768;
pub const APIC_DM_NMI: u32 = 1024;
pub const APIC_DM_INIT: u32 = 1280;
pub const APIC_DM_STARTUP: u32 = 1536;
pub const APIC_DM_EXTINT: u32 = 1792;
pub const APIC_VECTOR_MASK: u32 = 255;
pub const APIC_ICR2: u32 = 784;
pub const APIC_LVTT: u32 = 800;
pub const APIC_LVTTHMR: u32 = 816;
pub const APIC_LVTPC: u32 = 832;
pub const APIC_LVT0: u32 = 848;
pub const APIC_LVT_TIMER_BASE_MASK: u32 = 786432;
pub const APIC_TIMER_BASE_CLKIN: u32 = 0;
pub const APIC_TIMER_BASE_TMBASE: u32 = 1;
pub const APIC_TIMER_BASE_DIV: u32 = 2;
pub const APIC_LVT_TIMER_ONESHOT: u32 = 0;
pub const APIC_LVT_TIMER_PERIODIC: u32 = 131072;
pub const APIC_LVT_TIMER_TSCDEADLINE: u32 = 262144;
pub const APIC_LVT_MASKED: u32 = 65536;
pub const APIC_LVT_LEVEL_TRIGGER: u32 = 32768;
pub const APIC_LVT_REMOTE_IRR: u32 = 16384;
pub const APIC_INPUT_POLARITY: u32 = 8192;
pub const APIC_SEND_PENDING: u32 = 4096;
pub const APIC_MODE_MASK: u32 = 1792;
pub const APIC_MODE_FIXED: u32 = 0;
pub const APIC_MODE_NMI: u32 = 4;
pub const APIC_MODE_EXTINT: u32 = 7;
pub const APIC_LVT1: u32 = 864;
pub const APIC_LVTERR: u32 = 880;
pub const APIC_TMICT: u32 = 896;
pub const APIC_TMCCT: u32 = 912;
pub const APIC_TDCR: u32 = 992;
pub const APIC_SELF_IPI: u32 = 1008;
pub const APIC_TDR_DIV_TMBASE: u32 = 4;
pub const APIC_TDR_DIV_1: u32 = 11;
pub const APIC_TDR_DIV_2: u32 = 0;
pub const APIC_TDR_DIV_4: u32 = 1;
pub const APIC_TDR_DIV_8: u32 = 2;
pub const APIC_TDR_DIV_16: u32 = 3;
pub const APIC_TDR_DIV_32: u32 = 8;
pub const APIC_TDR_DIV_64: u32 = 9;
pub const APIC_TDR_DIV_128: u32 = 10;
pub const APIC_EFEAT: u32 = 1024;
pub const APIC_ECTRL: u32 = 1040;
pub const APIC_EILVT_NR_AMD_K8: u32 = 1;
pub const APIC_EILVT_NR_AMD_10H: u32 = 4;
pub const APIC_EILVT_NR_MAX: u32 = 4;
pub const APIC_EILVT_MSG_FIX: u32 = 0;
pub const APIC_EILVT_MSG_SMI: u32 = 2;
pub const APIC_EILVT_MSG_NMI: u32 = 4;
pub const APIC_EILVT_MSG_EXT: u32 = 7;
pub const APIC_EILVT_MASKED: u32 = 65536;
pub const APIC_BASE_MSR: u32 = 2048;
pub const XAPIC_ENABLE: u32 = 2048;
pub const X2APIC_ENABLE: u32 = 1024;
pub const MAX_IO_APICS: u32 = 128;
pub const MAX_LOCAL_APIC: u32 = 32768;
pub const XAPIC_DEST_CPUS_SHIFT: u32 = 4;
pub const XAPIC_DEST_CPUS_MASK: u32 = 15;
pub const XAPIC_DEST_CLUSTER_MASK: u32 = 240;
pub const BAD_APICID: u32 = 65535;
pub const MAX_MP_BUSSES: u32 = 256;
pub const MAX_IRQ_SOURCES: u32 = 1024;
pub const FIXMAP_PMD_NUM: u32 = 2;
pub const FIXMAP_PMD_TOP: u32 = 507;
pub const ACPI_PDC_P_FFH: u32 = 1;
pub const ACPI_PDC_C_C1_HALT: u32 = 2;
pub const ACPI_PDC_T_FFH: u32 = 4;
pub const ACPI_PDC_SMP_C1PT: u32 = 8;
pub const ACPI_PDC_SMP_C2C3: u32 = 16;
pub const ACPI_PDC_SMP_P_SWCOORD: u32 = 32;
pub const ACPI_PDC_SMP_C_SWCOORD: u32 = 64;
pub const ACPI_PDC_SMP_T_SWCOORD: u32 = 128;
pub const ACPI_PDC_C_C1_FFH: u32 = 256;
pub const ACPI_PDC_C_C2C3_FFH: u32 = 512;
pub const ACPI_PDC_SMP_P_HWCOORD: u32 = 2048;
pub const ACPI_PDC_EST_CAPABILITY_SMP: u32 = 11;
pub const ACPI_PDC_EST_CAPABILITY_SWSMP: u32 = 2091;
pub const ACPI_PDC_C_CAPABILITY_SMP: u32 = 794;
pub const NR_NODE_MEMBLKS: u32 = 2048;
pub const NODE_MIN_SIZE: u32 = 4194304;
pub const TH_FLAGS_SME_ACTIVE_BIT: u32 = 0;
pub const PRI_xen_pfn: &'static [u8; 3usize] = b"lx\0";
pub const PRI_xen_ulong: &'static [u8; 3usize] = b"lx\0";
pub const PRI_xen_long: &'static [u8; 3usize] = b"lx\0";
pub const MAX_VIRT_CPUS: u32 = 32;
pub const FIRST_RESERVED_GDT_PAGE: u32 = 14;
pub const FIRST_RESERVED_GDT_BYTE: u32 = 57344;
pub const FIRST_RESERVED_GDT_ENTRY: u32 = 7168;
pub const FLAT_RING3_CS32: u32 = 57379;
pub const FLAT_RING3_CS64: u32 = 57395;
pub const FLAT_RING3_DS32: u32 = 57387;
pub const FLAT_RING3_DS64: u32 = 0;
pub const FLAT_RING3_SS32: u32 = 57387;
pub const FLAT_RING3_SS64: u32 = 57387;
pub const FLAT_KERNEL_DS64: u32 = 0;
pub const FLAT_KERNEL_DS32: u32 = 57387;
pub const FLAT_KERNEL_DS: u32 = 0;
pub const FLAT_KERNEL_CS64: u32 = 57395;
pub const FLAT_KERNEL_CS32: u32 = 57379;
pub const FLAT_KERNEL_CS: u32 = 57395;
pub const FLAT_KERNEL_SS64: u32 = 57387;
pub const FLAT_KERNEL_SS32: u32 = 57387;
pub const FLAT_KERNEL_SS: u32 = 57387;
pub const FLAT_USER_DS64: u32 = 0;
pub const FLAT_USER_DS32: u32 = 57387;
pub const FLAT_USER_DS: u32 = 0;
pub const FLAT_USER_CS64: u32 = 57395;
pub const FLAT_USER_CS32: u32 = 57379;
pub const FLAT_USER_CS: u32 = 57395;
pub const FLAT_USER_SS64: u32 = 57387;
pub const FLAT_USER_SS32: u32 = 57387;
pub const FLAT_USER_SS: u32 = 57387;
pub const __HYPERVISOR_VIRT_START: i64 = -140737488355328;
pub const __HYPERVISOR_VIRT_END: i64 = -131941395333120;
pub const __MACH2PHYS_VIRT_START: i64 = -140737488355328;
pub const __MACH2PHYS_VIRT_END: i64 = -140462610448384;
pub const __MACH2PHYS_SHIFT: u32 = 3;
pub const SEGBASE_FS: u32 = 0;
pub const SEGBASE_GS_USER: u32 = 1;
pub const SEGBASE_GS_KERNEL: u32 = 2;
pub const SEGBASE_GS_USER_SEL: u32 = 3;
pub const _VGCF_in_syscall: u32 = 8;
pub const VGCF_in_syscall: u32 = 256;
pub const VGCF_IN_SYSCALL: u32 = 256;
pub const PVCLOCK_TSC_STABLE_BIT: u32 = 1;
pub const PVCLOCK_GUEST_STOPPED: u32 = 2;
pub const PVCLOCK_COUNTS_FROM_ZERO: u32 = 4;
pub const VGCF_I387_VALID: u32 = 1;
pub const VGCF_IN_KERNEL: u32 = 4;
pub const _VGCF_i387_valid: u32 = 0;
pub const VGCF_i387_valid: u32 = 1;
pub const _VGCF_in_kernel: u32 = 2;
pub const VGCF_in_kernel: u32 = 4;
pub const _VGCF_failsafe_disables_events: u32 = 3;
pub const VGCF_failsafe_disables_events: u32 = 8;
pub const _VGCF_syscall_disables_events: u32 = 4;
pub const VGCF_syscall_disables_events: u32 = 16;
pub const _VGCF_online: u32 = 5;
pub const VGCF_online: u32 = 32;
pub const PMU_CACHED: u32 = 1;
pub const PMU_SAMPLE_USER: u32 = 2;
pub const PMU_SAMPLE_REAL: u32 = 4;
pub const PMU_SAMPLE_PV: u32 = 8;
pub const XENPMU_REGS_PAD_SZ: u32 = 64;
pub const XENPMU_CTXT_PAD_SZ: u32 = 128;
pub const XEN_EMULATE_PREFIX: &'static [u8; 34usize] = b".byte 0x0f,0x0b,0x78,0x65,0x6e ; \0";
pub const XEN_CPUID: &'static [u8; 39usize] = b".byte 0x0f,0x0b,0x78,0x65,0x6e ; cpuid\0";
pub const __HYPERVISOR_set_trap_table: u32 = 0;
pub const __HYPERVISOR_mmu_update: u32 = 1;
pub const __HYPERVISOR_set_gdt: u32 = 2;
pub const __HYPERVISOR_stack_switch: u32 = 3;
pub const __HYPERVISOR_set_callbacks: u32 = 4;
pub const __HYPERVISOR_fpu_taskswitch: u32 = 5;
pub const __HYPERVISOR_sched_op_compat: u32 = 6;
pub const __HYPERVISOR_platform_op: u32 = 7;
pub const __HYPERVISOR_set_debugreg: u32 = 8;
pub const __HYPERVISOR_get_debugreg: u32 = 9;
pub const __HYPERVISOR_update_descriptor: u32 = 10;
pub const __HYPERVISOR_memory_op: u32 = 12;
pub const __HYPERVISOR_multicall: u32 = 13;
pub const __HYPERVISOR_update_va_mapping: u32 = 14;
pub const __HYPERVISOR_set_timer_op: u32 = 15;
pub const __HYPERVISOR_event_channel_op_compat: u32 = 16;
pub const __HYPERVISOR_xen_version: u32 = 17;
pub const __HYPERVISOR_console_io: u32 = 18;
pub const __HYPERVISOR_physdev_op_compat: u32 = 19;
pub const __HYPERVISOR_grant_table_op: u32 = 20;
pub const __HYPERVISOR_vm_assist: u32 = 21;
pub const __HYPERVISOR_update_va_mapping_otherdomain: u32 = 22;
pub const __HYPERVISOR_iret: u32 = 23;
pub const __HYPERVISOR_vcpu_op: u32 = 24;
pub const __HYPERVISOR_set_segment_base: u32 = 25;
pub const __HYPERVISOR_mmuext_op: u32 = 26;
pub const __HYPERVISOR_xsm_op: u32 = 27;
pub const __HYPERVISOR_nmi_op: u32 = 28;
pub const __HYPERVISOR_sched_op: u32 = 29;
pub const __HYPERVISOR_callback_op: u32 = 30;
pub const __HYPERVISOR_xenoprof_op: u32 = 31;
pub const __HYPERVISOR_event_channel_op: u32 = 32;
pub const __HYPERVISOR_physdev_op: u32 = 33;
pub const __HYPERVISOR_hvm_op: u32 = 34;
pub const __HYPERVISOR_sysctl: u32 = 35;
pub const __HYPERVISOR_domctl: u32 = 36;
pub const __HYPERVISOR_kexec_op: u32 = 37;
pub const __HYPERVISOR_tmem_op: u32 = 38;
pub const __HYPERVISOR_xc_reserved_op: u32 = 39;
pub const __HYPERVISOR_xenpmu_op: u32 = 40;
pub const __HYPERVISOR_dm_op: u32 = 41;
pub const __HYPERVISOR_arch_0: u32 = 48;
pub const __HYPERVISOR_arch_1: u32 = 49;
pub const __HYPERVISOR_arch_2: u32 = 50;
pub const __HYPERVISOR_arch_3: u32 = 51;
pub const __HYPERVISOR_arch_4: u32 = 52;
pub const __HYPERVISOR_arch_5: u32 = 53;
pub const __HYPERVISOR_arch_6: u32 = 54;
pub const __HYPERVISOR_arch_7: u32 = 55;
pub const VIRQ_TIMER: u32 = 0;
pub const VIRQ_DEBUG: u32 = 1;
pub const VIRQ_CONSOLE: u32 = 2;
pub const VIRQ_DOM_EXC: u32 = 3;
pub const VIRQ_TBUF: u32 = 4;
pub const VIRQ_DEBUGGER: u32 = 6;
pub const VIRQ_XENOPROF: u32 = 7;
pub const VIRQ_CON_RING: u32 = 8;
pub const VIRQ_PCPU_STATE: u32 = 9;
pub const VIRQ_MEM_EVENT: u32 = 10;
pub const VIRQ_XC_RESERVED: u32 = 11;
pub const VIRQ_ENOMEM: u32 = 12;
pub const VIRQ_XENPMU: u32 = 13;
pub const VIRQ_ARCH_0: u32 = 16;
pub const VIRQ_ARCH_1: u32 = 17;
pub const VIRQ_ARCH_2: u32 = 18;
pub const VIRQ_ARCH_3: u32 = 19;
pub const VIRQ_ARCH_4: u32 = 20;
pub const VIRQ_ARCH_5: u32 = 21;
pub const VIRQ_ARCH_6: u32 = 22;
pub const VIRQ_ARCH_7: u32 = 23;
pub const NR_VIRQS: u32 = 24;
pub const MMU_NORMAL_PT_UPDATE: u32 = 0;
pub const MMU_MACHPHYS_UPDATE: u32 = 1;
pub const MMU_PT_UPDATE_PRESERVE_AD: u32 = 2;
pub const MMUEXT_PIN_L1_TABLE: u32 = 0;
pub const MMUEXT_PIN_L2_TABLE: u32 = 1;
pub const MMUEXT_PIN_L3_TABLE: u32 = 2;
pub const MMUEXT_PIN_L4_TABLE: u32 = 3;
pub const MMUEXT_UNPIN_TABLE: u32 = 4;
pub const MMUEXT_NEW_BASEPTR: u32 = 5;
pub const MMUEXT_TLB_FLUSH_LOCAL: u32 = 6;
pub const MMUEXT_INVLPG_LOCAL: u32 = 7;
pub const MMUEXT_TLB_FLUSH_MULTI: u32 = 8;
pub const MMUEXT_INVLPG_MULTI: u32 = 9;
pub const MMUEXT_TLB_FLUSH_ALL: u32 = 10;
pub const MMUEXT_INVLPG_ALL: u32 = 11;
pub const MMUEXT_FLUSH_CACHE: u32 = 12;
pub const MMUEXT_SET_LDT: u32 = 13;
pub const MMUEXT_NEW_USER_BASEPTR: u32 = 15;
pub const MMUEXT_CLEAR_PAGE: u32 = 16;
pub const MMUEXT_COPY_PAGE: u32 = 17;
pub const MMUEXT_FLUSH_CACHE_GLOBAL: u32 = 18;
pub const MMUEXT_MARK_SUPER: u32 = 19;
pub const MMUEXT_UNMARK_SUPER: u32 = 20;
pub const UVMF_NONE: u32 = 0;
pub const UVMF_TLB_FLUSH: u32 = 1;
pub const UVMF_INVLPG: u32 = 2;
pub const UVMF_FLUSHTYPE_MASK: u32 = 3;
pub const UVMF_MULTI: u32 = 0;
pub const UVMF_LOCAL: u32 = 0;
pub const UVMF_ALL: u32 = 4;
pub const CONSOLEIO_write: u32 = 0;
pub const CONSOLEIO_read: u32 = 1;
pub const VMASST_CMD_enable: u32 = 0;
pub const VMASST_CMD_disable: u32 = 1;
pub const VMASST_TYPE_4gb_segments: u32 = 0;
pub const VMASST_TYPE_4gb_segments_notify: u32 = 1;
pub const VMASST_TYPE_writable_pagetables: u32 = 2;
pub const VMASST_TYPE_pae_extended_cr3: u32 = 3;
pub const VMASST_TYPE_architectural_iopl: u32 = 4;
pub const VMASST_TYPE_runstate_update_flag: u32 = 5;
pub const MAX_VMASST_TYPE: u32 = 5;
pub const DOMID_FIRST_RESERVED: u32 = 32752;
pub const DOMID_SELF: u32 = 32752;
pub const DOMID_IO: u32 = 32753;
pub const DOMID_XEN: u32 = 32754;
pub const DOMID_COW: u32 = 32755;
pub const DOMID_INVALID: u32 = 32756;
pub const DOMID_IDLE: u32 = 32767;
pub const MAX_GUEST_CMDLINE: u32 = 1024;
pub const SIF_PRIVILEGED: u32 = 1;
pub const SIF_INITDOMAIN: u32 = 2;
pub const SIF_MULTIBOOT_MOD: u32 = 4;
pub const SIF_MOD_START_PFN: u32 = 8;
pub const SIF_VIRT_P2M_4TOOLS: u32 = 16;
pub const SIF_PM_MASK: u32 = 65280;
pub const XEN_VGATYPE_TEXT_MODE_3: u32 = 3;
pub const XEN_VGATYPE_VESA_LFB: u32 = 35;
pub const XEN_VGATYPE_EFI_LFB: u32 = 112;
pub const TMEM_SPEC_VERSION: u32 = 1;
pub const IO_SPACE_LIMIT: u32 = 65535;
pub const NR_FWNODE_REFERENCE_ARGS: u32 = 8;
pub const MMIO_UPPER_LIMIT: u32 = 65535;
pub const VM_IOREMAP: u32 = 1;
pub const VM_ALLOC: u32 = 2;
pub const VM_MAP: u32 = 4;
pub const VM_USERMAP: u32 = 8;
pub const VM_UNINITIALIZED: u32 = 32;
pub const VM_NO_GUARD: u32 = 64;
pub const VM_KASAN: u32 = 128;
pub const ARCH_HAS_POWER_INIT: u32 = 1;
pub const VSYSCALL_ADDR: i32 = -10485760;
pub const NR_FIX_BTMAPS: u32 = 64;
pub const FIX_BTMAPS_SLOTS: u32 = 8;
pub const TOTAL_FIX_BTMAPS: u32 = 512;
pub const ARCH_APICTIMER_STOPS_ON_C3: u32 = 1;
pub const APIC_QUIET: u32 = 0;
pub const APIC_VERBOSE: u32 = 1;
pub const APIC_DEBUG: u32 = 2;
pub const APIC_EXTNMI_BSP: u32 = 0;
pub const APIC_EXTNMI_ALL: u32 = 1;
pub const APIC_EXTNMI_NONE: u32 = 2;
pub const TRAMPOLINE_PHYS_LOW: u32 = 1127;
pub const TRAMPOLINE_PHYS_HIGH: u32 = 1129;
pub const APIC_DFR_VALUE: u32 = 4294967295;
pub const NMI_VECTOR: u32 = 2;
pub const MCE_VECTOR: u32 = 18;
pub const FIRST_EXTERNAL_VECTOR: u32 = 32;
pub const VECTOR_OFFSET_START: u32 = 1;
pub const IRQ_MOVE_CLEANUP_VECTOR: u32 = 32;
pub const IA32_SYSCALL_VECTOR: u32 = 128;
pub const SPURIOUS_APIC_VECTOR: u32 = 255;
pub const ERROR_APIC_VECTOR: u32 = 254;
pub const RESCHEDULE_VECTOR: u32 = 253;
pub const CALL_FUNCTION_VECTOR: u32 = 252;
pub const CALL_FUNCTION_SINGLE_VECTOR: u32 = 251;
pub const THERMAL_APIC_VECTOR: u32 = 250;
pub const THRESHOLD_APIC_VECTOR: u32 = 249;
pub const REBOOT_VECTOR: u32 = 248;
pub const X86_PLATFORM_IPI_VECTOR: u32 = 247;
pub const IRQ_WORK_VECTOR: u32 = 246;
pub const UV_BAU_MESSAGE: u32 = 245;
pub const DEFERRED_ERROR_VECTOR: u32 = 244;
pub const HYPERVISOR_CALLBACK_VECTOR: u32 = 243;
pub const POSTED_INTR_VECTOR: u32 = 242;
pub const POSTED_INTR_WAKEUP_VECTOR: u32 = 241;
pub const POSTED_INTR_NESTED_VECTOR: u32 = 240;
pub const MANAGED_IRQ_SHUTDOWN_VECTOR: u32 = 239;
pub const LOCAL_TIMER_VECTOR: u32 = 238;
pub const NR_VECTORS: u32 = 256;
pub const FIRST_SYSTEM_VECTOR: u32 = 238;
pub const FPU_IRQ: u32 = 13;
pub const NR_IRQS_LEGACY: u32 = 16;
pub const CPU_VECTOR_LIMIT: u32 = 524288;
pub const IO_APIC_VECTOR_LIMIT: u32 = 4096;
pub const IO_APIC_REDIR_VECTOR_MASK: u32 = 255;
pub const IO_APIC_REDIR_DEST_LOGICAL: u32 = 2048;
pub const IO_APIC_REDIR_DEST_PHYSICAL: u32 = 0;
pub const IO_APIC_REDIR_SEND_PENDING: u32 = 4096;
pub const IO_APIC_REDIR_REMOTE_IRR: u32 = 16384;
pub const IO_APIC_REDIR_LEVEL_TRIGGER: u32 = 32768;
pub const IO_APIC_REDIR_MASKED: u32 = 65536;
pub const IOAPIC_AUTO: i32 = -1;
pub const IOAPIC_EDGE: u32 = 0;
pub const IOAPIC_LEVEL: u32 = 1;
pub const IOAPIC_MASKED: u32 = 1;
pub const IOAPIC_UNMASKED: u32 = 0;
pub const IOAPIC_POL_HIGH: u32 = 0;
pub const IOAPIC_POL_LOW: u32 = 1;
pub const IOAPIC_DEST_MODE_PHYSICAL: u32 = 0;
pub const IOAPIC_DEST_MODE_LOGICAL: u32 = 1;
pub const IOAPIC_MAP_ALLOC: u32 = 1;
pub const IOAPIC_MAP_CHECK: u32 = 2;
pub const PA_SECTION_SHIFT: u32 = 27;
pub const PFN_SECTION_SHIFT: u32 = 15;
pub const NR_MEM_SECTIONS: u32 = 524288;
pub const PAGES_PER_SECTION: u32 = 32768;
pub const PAGE_SECTION_MASK: i32 = -32768;
pub const SECTION_MARKED_PRESENT: u32 = 1;
pub const SECTION_HAS_MEM_MAP: u32 = 2;
pub const SECTION_IS_ONLINE: u32 = 4;
pub const SECTION_MAP_LAST_BIT: u32 = 8;
pub const SECTION_MAP_MASK: i32 = -8;
pub const SECTION_NID_SHIFT: u32 = 3;
pub const PERCPU_MODULE_RESERVE: u32 = 8192;
pub const PCPU_MIN_ALLOC_SHIFT: u32 = 2;
pub const PCPU_MIN_ALLOC_SIZE: u32 = 4;
pub const PERCPU_DYNAMIC_EARLY_SLOTS: u32 = 128;
pub const PERCPU_DYNAMIC_EARLY_SIZE: u32 = 12288;
pub const PERCPU_DYNAMIC_RESERVE: u32 = 28672;
pub const LOCAL_DISTANCE: u32 = 10;
pub const REMOTE_DISTANCE: u32 = 20;
pub const RECLAIM_DISTANCE: u32 = 30;
pub const PENALTY_FOR_NODE_WITH_CPUS: u32 = 1;
pub const ___GFP_DMA: u32 = 1;
pub const ___GFP_HIGHMEM: u32 = 2;
pub const ___GFP_DMA32: u32 = 4;
pub const ___GFP_MOVABLE: u32 = 8;
pub const ___GFP_RECLAIMABLE: u32 = 16;
pub const ___GFP_HIGH: u32 = 32;
pub const ___GFP_IO: u32 = 64;
pub const ___GFP_FS: u32 = 128;
pub const ___GFP_NOWARN: u32 = 512;
pub const ___GFP_RETRY_MAYFAIL: u32 = 1024;
pub const ___GFP_NOFAIL: u32 = 2048;
pub const ___GFP_NORETRY: u32 = 4096;
pub const ___GFP_MEMALLOC: u32 = 8192;
pub const ___GFP_COMP: u32 = 16384;
pub const ___GFP_ZERO: u32 = 32768;
pub const ___GFP_NOMEMALLOC: u32 = 65536;
pub const ___GFP_HARDWALL: u32 = 131072;
pub const ___GFP_THISNODE: u32 = 262144;
pub const ___GFP_ATOMIC: u32 = 524288;
pub const ___GFP_ACCOUNT: u32 = 1048576;
pub const ___GFP_DIRECT_RECLAIM: u32 = 4194304;
pub const ___GFP_WRITE: u32 = 8388608;
pub const ___GFP_KSWAPD_RECLAIM: u32 = 16777216;
pub const ___GFP_NOLOCKDEP: u32 = 0;
pub const GFP_MOVABLE_SHIFT: u32 = 3;
pub const GFP_ZONES_SHIFT: u32 = 2;
pub const SLAB_DEBUG_OBJECTS: u32 = 0;
pub const SLAB_FAILSLAB: u32 = 0;
pub const SLAB_KASAN: u32 = 0;
pub const KMALLOC_SHIFT_HIGH: u32 = 13;
pub const KMALLOC_SHIFT_MAX: u32 = 22;
pub const KMALLOC_SHIFT_LOW: u32 = 3;
pub const KMALLOC_MAX_SIZE: u32 = 4194304;
pub const KMALLOC_MAX_CACHE_SIZE: u32 = 8192;
pub const KMALLOC_MAX_ORDER: u32 = 10;
pub const KMALLOC_MIN_SIZE: u32 = 8;
pub const HRTIMER_STATE_INACTIVE: u32 = 0;
pub const HRTIMER_STATE_ENQUEUED: u32 = 1;
pub const HRTIMER_CLOCK_BASE_ALIGN: u32 = 64;
pub const HIGH_RES_NSEC: u32 = 1;
pub const KTIME_HIGH_RES: u32 = 1;
pub const MONOTONIC_RES_NSEC: u32 = 1;
pub const KTIME_MONOTONIC_RES: u32 = 1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ftrace_branch_data {
    pub func: *const ::std::os::raw::c_char,
    pub file: *const ::std::os::raw::c_char,
    pub line: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: ftrace_branch_data__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ftrace_branch_data__bindgen_ty_1 {
    pub __bindgen_anon_1: ftrace_branch_data__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: ftrace_branch_data__bindgen_ty_1__bindgen_ty_2,
    pub miss_hit: [::std::os::raw::c_ulong; 2usize],
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ftrace_branch_data__bindgen_ty_1__bindgen_ty_1 {
    pub correct: ::std::os::raw::c_ulong,
    pub incorrect: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ftrace_branch_data__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(ftrace_branch_data__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ftrace_branch_data__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_1>())).correct
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_branch_data__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(correct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_1>())).incorrect
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_branch_data__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(incorrect)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ftrace_branch_data__bindgen_ty_1__bindgen_ty_2 {
    pub miss: ::std::os::raw::c_ulong,
    pub hit: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ftrace_branch_data__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(ftrace_branch_data__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ftrace_branch_data__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_2>())).miss
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_branch_data__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(miss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_2>())).hit
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_branch_data__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(hit)
        )
    );
}
#[test]
fn bindgen_test_layout_ftrace_branch_data__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ftrace_branch_data__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(ftrace_branch_data__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ftrace_branch_data__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ftrace_branch_data__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ftrace_branch_data__bindgen_ty_1>())).miss_hit as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_branch_data__bindgen_ty_1),
            "::",
            stringify!(miss_hit)
        )
    );
}
#[test]
fn bindgen_test_layout_ftrace_branch_data() {
    assert_eq!(
        ::std::mem::size_of::<ftrace_branch_data>(),
        40usize,
        concat!("Size of: ", stringify!(ftrace_branch_data))
    );
    assert_eq!(
        ::std::mem::align_of::<ftrace_branch_data>(),
        8usize,
        concat!("Alignment of ", stringify!(ftrace_branch_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ftrace_branch_data>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_branch_data),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ftrace_branch_data>())).file as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_branch_data),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ftrace_branch_data>())).line as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_branch_data),
            "::",
            stringify!(line)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ftrace_likely_data {
    pub data: ftrace_branch_data,
    pub constant: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ftrace_likely_data() {
    assert_eq!(
        ::std::mem::size_of::<ftrace_likely_data>(),
        48usize,
        concat!("Size of: ", stringify!(ftrace_likely_data))
    );
    assert_eq!(
        ::std::mem::align_of::<ftrace_likely_data>(),
        8usize,
        concat!("Alignment of ", stringify!(ftrace_likely_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ftrace_likely_data>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_likely_data),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ftrace_likely_data>())).constant as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_likely_data),
            "::",
            stringify!(constant)
        )
    );
}
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
pub type s8 = ::std::os::raw::c_schar;
pub type u8 = ::std::os::raw::c_uchar;
pub type s16 = ::std::os::raw::c_short;
pub type u16 = ::std::os::raw::c_ushort;
pub type s32 = ::std::os::raw::c_int;
pub type u32 = ::std::os::raw::c_uint;
pub type s64 = ::std::os::raw::c_longlong;
pub const __false: _bindgen_ty_1 = 0;
pub const __true: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fsid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __kernel_dev_t = __u32;
pub type fd_set = __kernel_fd_set;
pub type dev_t = __kernel_dev_t;
pub type ino_t = __kernel_ino_t;
pub type mode_t = __kernel_mode_t;
pub type umode_t = ::std::os::raw::c_ushort;
pub type nlink_t = __u32;
pub type off_t = __kernel_off_t;
pub type pid_t = __kernel_pid_t;
pub type daddr_t = __kernel_daddr_t;
pub type key_t = __kernel_key_t;
pub type suseconds_t = __kernel_suseconds_t;
pub type timer_t = __kernel_timer_t;
pub type clockid_t = __kernel_clockid_t;
pub type mqd_t = __kernel_mqd_t;
pub type bool_ = bool;
pub type uid_t = __kernel_uid32_t;
pub type gid_t = __kernel_gid32_t;
pub type uid16_t = __kernel_uid16_t;
pub type gid16_t = __kernel_gid16_t;
pub type old_uid_t = __kernel_old_uid_t;
pub type old_gid_t = __kernel_old_gid_t;
pub type loff_t = __kernel_loff_t;
pub type time_t = __kernel_time_t;
pub type clock_t = __kernel_clock_t;
pub type caddr_t = __kernel_caddr_t;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type unchar = ::std::os::raw::c_uchar;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type ulong = ::std::os::raw::c_ulong;
pub type u_int8_t = __u8;
pub type u_int16_t = __u16;
pub type u_int32_t = __u32;
pub type u_int64_t = __u64;
pub type sector_t = ::std::os::raw::c_ulong;
pub type blkcnt_t = ::std::os::raw::c_ulong;
pub type dma_addr_t = __u64;
pub type gfp_t = ::std::os::raw::c_uint;
pub type slab_flags_t = ::std::os::raw::c_uint;
pub type fmode_t = ::std::os::raw::c_uint;
pub type phys_addr_t = __u64;
pub type resource_size_t = phys_addr_t;
pub type irq_hw_number_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct atomic_t {
    pub counter: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_atomic_t() {
    assert_eq!(
        ::std::mem::size_of::<atomic_t>(),
        4usize,
        concat!("Size of: ", stringify!(atomic_t))
    );
    assert_eq!(
        ::std::mem::align_of::<atomic_t>(),
        4usize,
        concat!("Alignment of ", stringify!(atomic_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atomic_t>())).counter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atomic_t),
            "::",
            stringify!(counter)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct atomic64_t {
    pub counter: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_atomic64_t() {
    assert_eq!(
        ::std::mem::size_of::<atomic64_t>(),
        8usize,
        concat!("Size of: ", stringify!(atomic64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<atomic64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(atomic64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atomic64_t>())).counter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atomic64_t),
            "::",
            stringify!(counter)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct list_head {
    pub next: *mut list_head,
    pub prev: *mut list_head,
}
#[test]
fn bindgen_test_layout_list_head() {
    assert_eq!(
        ::std::mem::size_of::<list_head>(),
        16usize,
        concat!("Size of: ", stringify!(list_head))
    );
    assert_eq!(
        ::std::mem::align_of::<list_head>(),
        8usize,
        concat!("Alignment of ", stringify!(list_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<list_head>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_head),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<list_head>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(list_head),
            "::",
            stringify!(prev)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hlist_head {
    pub first: *mut hlist_node,
}
#[test]
fn bindgen_test_layout_hlist_head() {
    assert_eq!(
        ::std::mem::size_of::<hlist_head>(),
        8usize,
        concat!("Size of: ", stringify!(hlist_head))
    );
    assert_eq!(
        ::std::mem::align_of::<hlist_head>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hlist_head>())).first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_head),
            "::",
            stringify!(first)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hlist_node {
    pub next: *mut hlist_node,
    pub pprev: *mut *mut hlist_node,
}
#[test]
fn bindgen_test_layout_hlist_node() {
    assert_eq!(
        ::std::mem::size_of::<hlist_node>(),
        16usize,
        concat!("Size of: ", stringify!(hlist_node))
    );
    assert_eq!(
        ::std::mem::align_of::<hlist_node>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hlist_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hlist_node>())).pprev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_node),
            "::",
            stringify!(pprev)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ustat {
    pub f_tfree: __kernel_daddr_t,
    pub f_tinode: __kernel_ino_t,
    pub f_fname: [::std::os::raw::c_char; 6usize],
    pub f_fpack: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout_ustat() {
    assert_eq!(
        ::std::mem::size_of::<ustat>(),
        32usize,
        concat!("Size of: ", stringify!(ustat))
    );
    assert_eq!(
        ::std::mem::align_of::<ustat>(),
        8usize,
        concat!("Alignment of ", stringify!(ustat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ustat>())).f_tfree as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ustat),
            "::",
            stringify!(f_tfree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ustat>())).f_tinode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ustat),
            "::",
            stringify!(f_tinode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ustat>())).f_fname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ustat),
            "::",
            stringify!(f_fname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ustat>())).f_fpack as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(ustat),
            "::",
            stringify!(f_fpack)
        )
    );
}
#[doc = " struct callback_head - callback structure for use with RCU and task_work"]
#[doc = " @next: next update requests in a list"]
#[doc = " @func: actual update function to call after the grace period."]
#[doc = ""]
#[doc = " The struct is aligned to size of pointer. On most architectures it happens"]
#[doc = " naturally due ABI requirements, but some architectures (like CRIS) have"]
#[doc = " weird ABI and we need to ask it explicitly."]
#[doc = ""]
#[doc = " The alignment is required to guarantee that bit 0 of @next will be"]
#[doc = " clear under normal conditions -- as long as we use call_rcu(),"]
#[doc = " call_rcu_bh(), call_rcu_sched(), or call_srcu() to queue callback."]
#[doc = ""]
#[doc = " This guarantee is important for few reasons:"]
#[doc = "  - future call_rcu_lazy() will make use of lower bits in the pointer;"]
#[doc = "  - the structure shares storage spacer in struct page with @compound_head,"]
#[doc = "    which encode PageTail() in bit 0. The guarantee is needed to avoid"]
#[doc = "    false-positive PageTail()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct callback_head {
    pub next: *mut callback_head,
    pub func: ::std::option::Option<unsafe extern "C" fn(head: *mut callback_head)>,
}
#[test]
fn bindgen_test_layout_callback_head() {
    assert_eq!(
        ::std::mem::size_of::<callback_head>(),
        16usize,
        concat!("Size of: ", stringify!(callback_head))
    );
    assert_eq!(
        ::std::mem::align_of::<callback_head>(),
        8usize,
        concat!("Alignment of ", stringify!(callback_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<callback_head>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callback_head),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<callback_head>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(callback_head),
            "::",
            stringify!(func)
        )
    );
}
pub type rcu_callback_t = ::std::option::Option<unsafe extern "C" fn(head: *mut callback_head)>;
pub type call_rcu_func_t =
    ::std::option::Option<unsafe extern "C" fn(head: *mut callback_head, func: rcu_callback_t)>;
extern "C" {
    #[link_name = "\u{1}rsp"]
    pub static mut current_stack_pointer: ::std::os::raw::c_ulong;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct alt_instr {
    pub instr_offset: s32,
    pub repl_offset: s32,
    pub cpuid: u16,
    pub instrlen: u8,
    pub replacementlen: u8,
    pub padlen: u8,
}
#[test]
fn bindgen_test_layout_alt_instr() {
    assert_eq!(
        ::std::mem::size_of::<alt_instr>(),
        13usize,
        concat!("Size of: ", stringify!(alt_instr))
    );
    assert_eq!(
        ::std::mem::align_of::<alt_instr>(),
        1usize,
        concat!("Alignment of ", stringify!(alt_instr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alt_instr>())).instr_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(alt_instr),
            "::",
            stringify!(instr_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alt_instr>())).repl_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(alt_instr),
            "::",
            stringify!(repl_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alt_instr>())).cpuid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(alt_instr),
            "::",
            stringify!(cpuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alt_instr>())).instrlen as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(alt_instr),
            "::",
            stringify!(instrlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alt_instr>())).replacementlen as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(alt_instr),
            "::",
            stringify!(replacementlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alt_instr>())).padlen as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(alt_instr),
            "::",
            stringify!(padlen)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}alternatives_patched"]
    pub static mut alternatives_patched: ::std::os::raw::c_int;
}
extern "C" {
    pub fn alternative_instructions();
}
extern "C" {
    pub fn apply_alternatives(start: *mut alt_instr, end: *mut alt_instr);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct module {
    _unused: [u8; 0],
}
extern "C" {
    pub fn alternatives_smp_module_add(
        mod_: *mut module,
        name: *mut ::std::os::raw::c_char,
        locks: *mut ::std::os::raw::c_void,
        locks_end: *mut ::std::os::raw::c_void,
        text: *mut ::std::os::raw::c_void,
        text_end: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn alternatives_smp_module_del(mod_: *mut module);
}
extern "C" {
    pub fn alternatives_enable_smp();
}
extern "C" {
    pub fn alternatives_text_reserved(
        start: *mut ::std::os::raw::c_void,
        end: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}skip_smp_alternatives"]
    pub static mut skip_smp_alternatives: bool_;
}
extern "C" {
    #[link_name = "\u{1}ideal_nops"]
    pub static mut ideal_nops: *const *const ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn arch_init_ideal_nops();
}
pub type initcall_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
pub type exitcall_t = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[link_name = "\u{1}__con_initcall_start"]
    pub static mut __con_initcall_start: [initcall_t; 0usize];
}
extern "C" {
    #[link_name = "\u{1}__con_initcall_end"]
    pub static mut __con_initcall_end: [initcall_t; 0usize];
}
extern "C" {
    #[link_name = "\u{1}__security_initcall_start"]
    pub static mut __security_initcall_start: [initcall_t; 0usize];
}
extern "C" {
    #[link_name = "\u{1}__security_initcall_end"]
    pub static mut __security_initcall_end: [initcall_t; 0usize];
}
pub type ctor_fn_t = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn do_one_initcall(fn_: initcall_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}boot_command_line"]
    pub static mut boot_command_line: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}saved_command_line"]
    pub static mut saved_command_line: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}reset_devices"]
    pub static mut reset_devices: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn setup_arch(arg1: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn prepare_namespace();
}
extern "C" {
    pub fn load_default_modules();
}
extern "C" {
    pub fn init_rootfs() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}rodata_enabled"]
    pub static mut rodata_enabled: bool_;
}
extern "C" {
    pub fn mark_rodata_ro();
}
extern "C" {
    #[link_name = "\u{1}late_time_init"]
    pub static mut late_time_init: ::std::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    #[link_name = "\u{1}initcall_debug"]
    pub static mut initcall_debug: bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_symbol {
    pub value: ::std::os::raw::c_ulong,
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_kernel_symbol() {
    assert_eq!(
        ::std::mem::size_of::<kernel_symbol>(),
        16usize,
        concat!("Size of: ", stringify!(kernel_symbol))
    );
    assert_eq!(
        ::std::mem::align_of::<kernel_symbol>(),
        8usize,
        concat!("Alignment of ", stringify!(kernel_symbol))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_symbol>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_symbol),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_symbol>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_symbol),
            "::",
            stringify!(name)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__this_module"]
    pub static mut __this_module: module;
}
#[repr(C)]
pub struct sysinfo {
    pub uptime: __kernel_long_t,
    pub loads: [__kernel_ulong_t; 3usize],
    pub totalram: __kernel_ulong_t,
    pub freeram: __kernel_ulong_t,
    pub sharedram: __kernel_ulong_t,
    pub bufferram: __kernel_ulong_t,
    pub totalswap: __kernel_ulong_t,
    pub freeswap: __kernel_ulong_t,
    pub procs: __u16,
    pub pad: __u16,
    pub totalhigh: __kernel_ulong_t,
    pub freehigh: __kernel_ulong_t,
    pub mem_unit: __u32,
    pub _f: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_sysinfo() {
    assert_eq!(
        ::std::mem::size_of::<sysinfo>(),
        112usize,
        concat!("Size of: ", stringify!(sysinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<sysinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(sysinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).uptime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(uptime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).loads as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(loads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).totalram as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(totalram)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).freeram as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(freeram)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).sharedram as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(sharedram)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).bufferram as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(bufferram)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).totalswap as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(totalswap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).freeswap as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(freeswap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).procs as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(procs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).pad as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).totalhigh as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(totalhigh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).freehigh as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(freehigh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).mem_unit as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(mem_unit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>()))._f as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(_f)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}linux_banner"]
    pub static mut linux_banner: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}linux_proc_banner"]
    pub static mut linux_proc_banner: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}console_printk"]
    pub static mut console_printk: [::std::os::raw::c_int; 0usize];
}
extern "C" {
    #[link_name = "\u{1}devkmsg_log_str"]
    pub static mut devkmsg_log_str: [::std::os::raw::c_char; 0usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct va_format {
    pub fmt: *const ::std::os::raw::c_char,
    pub va: *mut va_list,
}
#[test]
fn bindgen_test_layout_va_format() {
    assert_eq!(
        ::std::mem::size_of::<va_format>(),
        16usize,
        concat!("Size of: ", stringify!(va_format))
    );
    assert_eq!(
        ::std::mem::align_of::<va_format>(),
        8usize,
        concat!("Alignment of ", stringify!(va_format))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<va_format>())).fmt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(va_format),
            "::",
            stringify!(fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<va_format>())).va as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(va_format),
            "::",
            stringify!(va)
        )
    );
}
extern "C" {
    pub fn early_printk(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn printk_nmi_enter();
}
extern "C" {
    pub fn printk_nmi_exit();
}
extern "C" {
    pub fn printk_nmi_direct_enter();
}
extern "C" {
    pub fn printk_nmi_direct_exit();
}
extern "C" {
    pub fn vprintk_emit(
        facility: ::std::os::raw::c_int,
        level: ::std::os::raw::c_int,
        dict: *const ::std::os::raw::c_char,
        dictlen: usize,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintk(
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printk_emit(
        facility: ::std::os::raw::c_int,
        level: ::std::os::raw::c_int,
        dict: *const ::std::os::raw::c_char,
        dictlen: usize,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printk(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printk_deferred(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __printk_ratelimit(func: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printk_timed_ratelimit(
        caller_jiffies: *mut ::std::os::raw::c_ulong,
        interval_msec: ::std::os::raw::c_uint,
    ) -> bool_;
}
extern "C" {
    #[link_name = "\u{1}printk_delay_msec"]
    pub static mut printk_delay_msec: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}dmesg_restrict"]
    pub static mut dmesg_restrict: ::std::os::raw::c_int;
}
extern "C" {
    pub fn devkmsg_sysctl_set_loglvl(
        table: *mut ctl_table,
        write: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wake_up_klogd();
}
extern "C" {
    pub fn log_buf_addr_get() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn log_buf_len_get() -> u32;
}
extern "C" {
    pub fn log_buf_vmcoreinfo_setup();
}
extern "C" {
    pub fn setup_log_buf(early: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dump_stack_set_arch_desc(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn dump_stack_print_info(log_lvl: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn show_regs_print_info(log_lvl: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printk_safe_init();
}
extern "C" {
    pub fn printk_safe_flush();
}
extern "C" {
    pub fn printk_safe_flush_on_panic();
}
extern "C" {
    #[link_name = "\u{1}kptr_restrict"]
    pub static mut kptr_restrict: ::std::os::raw::c_int;
}
extern "C" {
    pub fn dump_stack();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ddebug {
    pub modname: *const ::std::os::raw::c_char,
    pub function: *const ::std::os::raw::c_char,
    pub filename: *const ::std::os::raw::c_char,
    pub format: *const ::std::os::raw::c_char,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout__ddebug() {
    assert_eq!(
        ::std::mem::size_of::<_ddebug>(),
        40usize,
        concat!("Size of: ", stringify!(_ddebug))
    );
    assert_eq!(
        ::std::mem::align_of::<_ddebug>(),
        8usize,
        concat!("Alignment of ", stringify!(_ddebug))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ddebug>())).modname as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug),
            "::",
            stringify!(modname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ddebug>())).function as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ddebug>())).filename as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ddebug>())).format as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug),
            "::",
            stringify!(format)
        )
    );
}
impl _ddebug {
    #[inline]
    pub fn lineno(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_lineno(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lineno: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 18u8, {
            let lineno: u32 = unsafe { ::std::mem::transmute(lineno) };
            lineno as u64
        });
        __bindgen_bitfield_unit.set(18usize, 8u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ddebug_add_module(
        tab: *mut _ddebug,
        n: ::std::os::raw::c_uint,
        modname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ddebug_remove_module(mod_name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __dynamic_pr_debug(descriptor: *mut _ddebug, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn ddebug_dyndbg_module_param_cb(
        param: *mut ::std::os::raw::c_char,
        val: *mut ::std::os::raw::c_char,
        modname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __dynamic_dev_dbg(
        descriptor: *mut _ddebug,
        dev: *const device,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct net_device {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __dynamic_netdev_dbg(
        descriptor: *mut _ddebug,
        dev: *const net_device,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_operations {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}kmsg_fops"]
    pub static kmsg_fops: file_operations;
}
pub const DUMP_PREFIX_NONE: _bindgen_ty_2 = 0;
pub const DUMP_PREFIX_ADDRESS: _bindgen_ty_2 = 1;
pub const DUMP_PREFIX_OFFSET: _bindgen_ty_2 = 2;
pub type _bindgen_ty_2 = u32;
extern "C" {
    pub fn hex_dump_to_buffer(
        buf: *const ::std::os::raw::c_void,
        len: usize,
        rowsize: ::std::os::raw::c_int,
        groupsize: ::std::os::raw::c_int,
        linebuf: *mut ::std::os::raw::c_char,
        linebuflen: usize,
        ascii: bool_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn print_hex_dump(
        level: *const ::std::os::raw::c_char,
        prefix_str: *const ::std::os::raw::c_char,
        prefix_type: ::std::os::raw::c_int,
        rowsize: ::std::os::raw::c_int,
        groupsize: ::std::os::raw::c_int,
        buf: *const ::std::os::raw::c_void,
        len: usize,
        ascii: bool_,
    );
}
extern "C" {
    pub fn __sw_hweight8(w: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __sw_hweight16(w: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __sw_hweight32(w: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __sw_hweight64(w: __u64) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " find_next_bit - find the next set bit in a memory region"]
    #[doc = " @addr: The address to base the search on"]
    #[doc = " @offset: The bitnumber to start searching at"]
    #[doc = " @size: The bitmap size in bits"]
    #[doc = ""]
    #[doc = " Returns the bit number for the next set bit"]
    #[doc = " If no bits are set, returns @size."]
    pub fn find_next_bit(
        addr: *const ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
        offset: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " find_next_zero_bit - find the next cleared bit in a memory region"]
    #[doc = " @addr: The address to base the search on"]
    #[doc = " @offset: The bitnumber to start searching at"]
    #[doc = " @size: The bitmap size in bits"]
    #[doc = ""]
    #[doc = " Returns the bit number of the next zero bit"]
    #[doc = " If no bits are zero, returns @size."]
    pub fn find_next_zero_bit(
        addr: *const ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
        offset: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " find_first_bit - find the first set bit in a memory region"]
    #[doc = " @addr: The address to start the search at"]
    #[doc = " @size: The maximum number of bits to search"]
    #[doc = ""]
    #[doc = " Returns the bit number of the first set bit."]
    #[doc = " If no bits are set, returns @size."]
    pub fn find_first_bit(
        addr: *const ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " find_first_zero_bit - find the first cleared bit in a memory region"]
    #[doc = " @addr: The address to start the search at"]
    #[doc = " @size: The maximum number of bits to search"]
    #[doc = ""]
    #[doc = " Returns the bit number of the first cleared bit."]
    #[doc = " If no bits are zero, returns @size."]
    pub fn find_first_zero_bit(
        addr: *const ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " find_last_bit - find the last set bit in a memory region"]
    #[doc = " @addr: The address to start the search at"]
    #[doc = " @size: The number of bits to search"]
    #[doc = ""]
    #[doc = " Returns the bit number of the last set bit, or size."]
    pub fn find_last_bit(
        addr: *const ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user {
    _unused: [u8; 0],
}
extern "C" {
    pub fn _cond_resched() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct atomic_notifier_head {
    pub lock: spinlock_t,
    pub head: *mut notifier_block,
}
#[test]
fn bindgen_test_layout_atomic_notifier_head() {
    assert_eq!(
        ::std::mem::size_of::<atomic_notifier_head>(),
        16usize,
        concat!("Size of: ", stringify!(atomic_notifier_head))
    );
    assert_eq!(
        ::std::mem::align_of::<atomic_notifier_head>(),
        8usize,
        concat!("Alignment of ", stringify!(atomic_notifier_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atomic_notifier_head>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atomic_notifier_head),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atomic_notifier_head>())).head as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(atomic_notifier_head),
            "::",
            stringify!(head)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}panic_notifier_list"]
    pub static mut panic_notifier_list: atomic_notifier_head;
}
extern "C" {
    #[link_name = "\u{1}panic_blink"]
    pub static mut panic_blink: ::std::option::Option<
        unsafe extern "C" fn(state: ::std::os::raw::c_int) -> ::std::os::raw::c_long,
    >;
}
extern "C" {
    pub fn panic(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn nmi_panic(regs: *mut pt_regs, msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn oops_enter();
}
extern "C" {
    pub fn oops_exit();
}
extern "C" {
    pub fn print_oops_end_marker();
}
extern "C" {
    pub fn oops_may_print() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_exit(error_code: ::std::os::raw::c_long);
}
extern "C" {
    pub fn complete_and_exit(arg1: *mut completion, arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn refcount_error_report(regs: *mut pt_regs, err: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __kernel_is_locked_down(what: *const ::std::os::raw::c_char, first: bool_) -> bool_;
}
extern "C" {
    pub fn _kstrtoul(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _kstrtol(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoull(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoll(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtouint(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoint(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtou16(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtos16(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut s16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtou8(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtos8(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut s8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtobool(s: *const ::std::os::raw::c_char, res: *mut bool_) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoull_from_user(
        s: *const ::std::os::raw::c_char,
        count: usize,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoll_from_user(
        s: *const ::std::os::raw::c_char,
        count: usize,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoul_from_user(
        s: *const ::std::os::raw::c_char,
        count: usize,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtol_from_user(
        s: *const ::std::os::raw::c_char,
        count: usize,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtouint_from_user(
        s: *const ::std::os::raw::c_char,
        count: usize,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoint_from_user(
        s: *const ::std::os::raw::c_char,
        count: usize,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtou16_from_user(
        s: *const ::std::os::raw::c_char,
        count: usize,
        base: ::std::os::raw::c_uint,
        res: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtos16_from_user(
        s: *const ::std::os::raw::c_char,
        count: usize,
        base: ::std::os::raw::c_uint,
        res: *mut s16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtou8_from_user(
        s: *const ::std::os::raw::c_char,
        count: usize,
        base: ::std::os::raw::c_uint,
        res: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtos8_from_user(
        s: *const ::std::os::raw::c_char,
        count: usize,
        base: ::std::os::raw::c_uint,
        res: *mut s8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtobool_from_user(
        s: *const ::std::os::raw::c_char,
        count: usize,
        res: *mut bool_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn simple_strtoul(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn simple_strtol(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn simple_strtoull(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn simple_strtoll(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn num_to_str(
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        num: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        buf: *mut ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        buf: *mut ::std::os::raw::c_char,
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        buf: *mut ::std::os::raw::c_char,
        size: usize,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        buf: *mut ::std::os::raw::c_char,
        size: usize,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scnprintf(
        buf: *mut ::std::os::raw::c_char,
        size: usize,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscnprintf(
        buf: *mut ::std::os::raw::c_char,
        size: usize,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kasprintf(
        gfp: gfp_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn kvasprintf(
        gfp: gfp_t,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn kvasprintf_const(
        gfp: gfp_t,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_option(
        str: *mut *mut ::std::os::raw::c_char,
        pint: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_options(
        str: *const ::std::os::raw::c_char,
        nints: ::std::os::raw::c_int,
        ints: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memparse(
        ptr: *const ::std::os::raw::c_char,
        retptr: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn parse_option_str(
        str: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
    ) -> bool_;
}
extern "C" {
    pub fn next_arg(
        args: *mut ::std::os::raw::c_char,
        param: *mut *mut ::std::os::raw::c_char,
        val: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn core_kernel_text(addr: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn core_kernel_data(addr: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __kernel_text_address(addr: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kernel_text_address(addr: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn func_ptr_is_kernel_text(ptr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn int_sqrt(arg1: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn bust_spinlocks(yes: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}oops_in_progress"]
    pub static mut oops_in_progress: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}panic_timeout"]
    pub static mut panic_timeout: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}panic_on_oops"]
    pub static mut panic_on_oops: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}panic_on_unrecovered_nmi"]
    pub static mut panic_on_unrecovered_nmi: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}panic_on_io_nmi"]
    pub static mut panic_on_io_nmi: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}panic_on_warn"]
    pub static mut panic_on_warn: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}sysctl_panic_on_rcu_stall"]
    pub static mut sysctl_panic_on_rcu_stall: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}sysctl_panic_on_stackoverflow"]
    pub static mut sysctl_panic_on_stackoverflow: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}crash_kexec_post_notifiers"]
    pub static mut crash_kexec_post_notifiers: bool_;
}
extern "C" {
    #[link_name = "\u{1}panic_cpu"]
    pub static mut panic_cpu: atomic_t;
}
extern "C" {
    pub fn print_tainted() -> *const ::std::os::raw::c_char;
}
pub const lockdep_ok_LOCKDEP_STILL_OK: lockdep_ok = 0;
pub const lockdep_ok_LOCKDEP_NOW_UNRELIABLE: lockdep_ok = 1;
pub type lockdep_ok = u32;
extern "C" {
    pub fn add_taint(flag: ::std::os::raw::c_uint, arg1: lockdep_ok);
}
extern "C" {
    pub fn test_taint(flag: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_taint() -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}root_mountflags"]
    pub static mut root_mountflags: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}early_boot_irqs_disabled"]
    pub static mut early_boot_irqs_disabled: bool_;
}
pub const system_states_SYSTEM_BOOTING: system_states = 0;
pub const system_states_SYSTEM_SCHEDULING: system_states = 1;
pub const system_states_SYSTEM_RUNNING: system_states = 2;
pub const system_states_SYSTEM_HALT: system_states = 3;
pub const system_states_SYSTEM_POWER_OFF: system_states = 4;
pub const system_states_SYSTEM_RESTART: system_states = 5;
pub type system_states = u32;
extern "C" {
    #[link_name = "\u{1}system_state"]
    pub static mut system_state: system_states;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct taint_flag {
    pub c_true: ::std::os::raw::c_char,
    pub c_false: ::std::os::raw::c_char,
    pub module: bool_,
}
#[test]
fn bindgen_test_layout_taint_flag() {
    assert_eq!(
        ::std::mem::size_of::<taint_flag>(),
        3usize,
        concat!("Size of: ", stringify!(taint_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<taint_flag>(),
        1usize,
        concat!("Alignment of ", stringify!(taint_flag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<taint_flag>())).c_true as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(taint_flag),
            "::",
            stringify!(c_true)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<taint_flag>())).c_false as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(taint_flag),
            "::",
            stringify!(c_false)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<taint_flag>())).module as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(taint_flag),
            "::",
            stringify!(module)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}taint_flags"]
    pub static mut taint_flags: [taint_flag; 17usize];
}
extern "C" {
    #[link_name = "\u{1}hex_asc"]
    pub static mut hex_asc: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}hex_asc_upper"]
    pub static mut hex_asc_upper: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn hex_to_bin(ch: ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hex2bin(
        dst: *mut u8,
        src: *const ::std::os::raw::c_char,
        count: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bin2hex(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_void,
        count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mac_pton(s: *const ::std::os::raw::c_char, mac: *mut u8) -> bool_;
}
pub const ftrace_dump_mode_DUMP_NONE: ftrace_dump_mode = 0;
pub const ftrace_dump_mode_DUMP_ALL: ftrace_dump_mode = 1;
pub const ftrace_dump_mode_DUMP_ORIG: ftrace_dump_mode = 2;
pub type ftrace_dump_mode = u32;
extern "C" {
    pub fn tracing_on();
}
extern "C" {
    pub fn tracing_off();
}
extern "C" {
    pub fn tracing_is_on() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tracing_snapshot();
}
extern "C" {
    pub fn tracing_snapshot_alloc();
}
extern "C" {
    pub fn tracing_start();
}
extern "C" {
    pub fn tracing_stop();
}
extern "C" {
    pub fn __trace_bprintk(
        ip: ::std::os::raw::c_ulong,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __trace_printk(
        ip: ::std::os::raw::c_ulong,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __trace_bputs(
        ip: ::std::os::raw::c_ulong,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __trace_puts(
        ip: ::std::os::raw::c_ulong,
        str: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn trace_dump_stack(skip: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __ftrace_vbprintk(
        ip: ::std::os::raw::c_ulong,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ftrace_vprintk(
        ip: ::std::os::raw::c_ulong,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftrace_dump(oops_dump_mode: ftrace_dump_mode);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bug_entry {
    pub bug_addr_disp: ::std::os::raw::c_int,
    pub file_disp: ::std::os::raw::c_int,
    pub line: ::std::os::raw::c_ushort,
    pub flags: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_bug_entry() {
    assert_eq!(
        ::std::mem::size_of::<bug_entry>(),
        12usize,
        concat!("Size of: ", stringify!(bug_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<bug_entry>(),
        4usize,
        concat!("Alignment of ", stringify!(bug_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bug_entry>())).bug_addr_disp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bug_entry),
            "::",
            stringify!(bug_addr_disp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bug_entry>())).file_disp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bug_entry),
            "::",
            stringify!(file_disp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bug_entry>())).line as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bug_entry),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bug_entry>())).flags as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(bug_entry),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn __warn_printk(fmt: *const ::std::os::raw::c_char, ...);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct warn_args {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __warn(
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        caller: *mut ::std::os::raw::c_void,
        taint: ::std::os::raw::c_uint,
        regs: *mut pt_regs,
        args: *mut warn_args,
    );
}
pub const bug_trap_type_BUG_TRAP_TYPE_NONE: bug_trap_type = 0;
pub const bug_trap_type_BUG_TRAP_TYPE_WARN: bug_trap_type = 1;
pub const bug_trap_type_BUG_TRAP_TYPE_BUG: bug_trap_type = 2;
pub type bug_trap_type = u32;
extern "C" {
    pub fn find_bug(bugaddr: ::std::os::raw::c_ulong) -> *mut bug_entry;
}
extern "C" {
    pub fn report_bug(bug_addr: ::std::os::raw::c_ulong, regs: *mut pt_regs) -> bug_trap_type;
}
extern "C" {
    pub fn is_valid_bugaddr(addr: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn generic_bug_clear_once();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_area_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mm_struct {
    _unused: [u8; 0],
}
extern "C" {
    pub fn dump_page(page: *mut page, reason: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __dump_page(page: *mut page, reason: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn dump_vma(vma: *const vm_area_struct);
}
extern "C" {
    pub fn dump_mm(mm: *const mm_struct);
}
extern "C" {
    pub fn __bad_percpu_size();
}
extern "C" {
    pub fn __bad_size_call_parameter();
}
extern "C" {
    #[link_name = "\u{1}__per_cpu_offset"]
    pub static mut __per_cpu_offset: [::std::os::raw::c_ulong; 8192usize];
}
extern "C" {
    pub fn setup_per_cpu_areas();
}
extern "C" {
    #[link_name = "\u{1}this_cpu_off"]
    pub static mut this_cpu_off: ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_timespec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pollfd {
    _unused: [u8; 0],
}
pub const timespec_type_TT_NONE: timespec_type = 0;
pub const timespec_type_TT_NATIVE: timespec_type = 1;
pub const timespec_type_TT_COMPAT: timespec_type = 2;
pub type timespec_type = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block {
    pub fn_: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut restart_block) -> ::std::os::raw::c_long,
    >,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union restart_block__bindgen_ty_1 {
    pub futex: restart_block__bindgen_ty_1__bindgen_ty_1,
    pub nanosleep: restart_block__bindgen_ty_1__bindgen_ty_2,
    pub poll: restart_block__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_1 {
    pub uaddr: *mut u32,
    pub val: u32,
    pub flags: u32,
    pub bitset: u32,
    pub time: __u64,
    pub uaddr2: *mut u32,
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_1>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).uaddr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(uaddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).val as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).flags as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).bitset as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(bitset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).time as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).uaddr2 as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(uaddr2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_2 {
    pub clockid: clockid_t,
    pub type_: timespec_type,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub expires: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub rmtp: *mut timespec,
    pub compat_rmtp: *mut compat_timespec,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>())).rmtp
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(rmtp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()))
                .compat_rmtp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(compat_rmtp)
        )
    );
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2>())).clockid
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(clockid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2>())).type_ as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2>())).expires
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(expires)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_3 {
    pub ufds: *mut pollfd,
    pub nfds: ::std::os::raw::c_int,
    pub has_timeout: ::std::os::raw::c_int,
    pub tv_sec: ::std::os::raw::c_ulong,
    pub tv_nsec: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_3>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).ufds as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(ufds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).nfds as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(nfds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).has_timeout
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(has_timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).tv_sec as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).tv_nsec
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<restart_block__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(restart_block__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<restart_block__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(restart_block__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1>())).futex as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1),
            "::",
            stringify!(futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1>())).nanosleep as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1),
            "::",
            stringify!(nanosleep)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1>())).poll as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1),
            "::",
            stringify!(poll)
        )
    );
}
#[test]
fn bindgen_test_layout_restart_block() {
    assert_eq!(
        ::std::mem::size_of::<restart_block>(),
        48usize,
        concat!("Size of: ", stringify!(restart_block))
    );
    assert_eq!(
        ::std::mem::align_of::<restart_block>(),
        8usize,
        concat!("Alignment of ", stringify!(restart_block))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<restart_block>())).fn_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block),
            "::",
            stringify!(fn_)
        )
    );
}
extern "C" {
    pub fn do_no_restart_syscall(parm: *mut restart_block) -> ::std::os::raw::c_long;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct task_struct {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}current_task"]
    pub static mut current_task: *mut task_struct;
}
pub const BAD_STACK: _bindgen_ty_3 = -1;
pub const NOT_STACK: _bindgen_ty_3 = 0;
pub const GOOD_FRAME: _bindgen_ty_3 = 1;
pub const GOOD_STACK: _bindgen_ty_3 = 2;
pub type _bindgen_ty_3 = i32;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct screen_info {
    pub orig_x: __u8,
    pub orig_y: __u8,
    pub ext_mem_k: __u16,
    pub orig_video_page: __u16,
    pub orig_video_mode: __u8,
    pub orig_video_cols: __u8,
    pub flags: __u8,
    pub unused2: __u8,
    pub orig_video_ega_bx: __u16,
    pub unused3: __u16,
    pub orig_video_lines: __u8,
    pub orig_video_isVGA: __u8,
    pub orig_video_points: __u16,
    pub lfb_width: __u16,
    pub lfb_height: __u16,
    pub lfb_depth: __u16,
    pub lfb_base: __u32,
    pub lfb_size: __u32,
    pub cl_magic: __u16,
    pub cl_offset: __u16,
    pub lfb_linelength: __u16,
    pub red_size: __u8,
    pub red_pos: __u8,
    pub green_size: __u8,
    pub green_pos: __u8,
    pub blue_size: __u8,
    pub blue_pos: __u8,
    pub rsvd_size: __u8,
    pub rsvd_pos: __u8,
    pub vesapm_seg: __u16,
    pub vesapm_off: __u16,
    pub pages: __u16,
    pub vesa_attributes: __u16,
    pub capabilities: __u32,
    pub ext_lfb_base: __u32,
    pub _reserved: [__u8; 2usize],
}
#[test]
fn bindgen_test_layout_screen_info() {
    assert_eq!(
        ::std::mem::size_of::<screen_info>(),
        64usize,
        concat!("Size of: ", stringify!(screen_info))
    );
    assert_eq!(
        ::std::mem::align_of::<screen_info>(),
        1usize,
        concat!("Alignment of ", stringify!(screen_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_y as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).ext_mem_k as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(ext_mem_k)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_video_page as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_video_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_video_mode as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_video_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_video_cols as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_video_cols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).unused2 as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(unused2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_video_ega_bx as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_video_ega_bx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).unused3 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(unused3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_video_lines as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_video_lines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_video_isVGA as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_video_isVGA)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_video_points as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_video_points)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).lfb_width as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(lfb_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).lfb_height as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(lfb_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).lfb_depth as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(lfb_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).lfb_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(lfb_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).lfb_size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(lfb_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).cl_magic as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(cl_magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).cl_offset as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(cl_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).lfb_linelength as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(lfb_linelength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).red_size as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(red_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).red_pos as *const _ as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(red_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).green_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(green_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).green_pos as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(green_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).blue_size as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(blue_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).blue_pos as *const _ as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(blue_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).rsvd_size as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(rsvd_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).rsvd_pos as *const _ as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(rsvd_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).vesapm_seg as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(vesapm_seg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).vesapm_off as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(vesapm_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).pages as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).vesa_attributes as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(vesa_attributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).capabilities as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).ext_lfb_base as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(ext_lfb_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>()))._reserved as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(_reserved)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}screen_info"]
    pub static mut screen_info: screen_info;
}
pub type apm_event_t = ::std::os::raw::c_ushort;
pub type apm_eventinfo_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct apm_bios_info {
    pub version: __u16,
    pub cseg: __u16,
    pub offset: __u32,
    pub cseg_16: __u16,
    pub dseg: __u16,
    pub flags: __u16,
    pub cseg_len: __u16,
    pub cseg_16_len: __u16,
    pub dseg_len: __u16,
}
#[test]
fn bindgen_test_layout_apm_bios_info() {
    assert_eq!(
        ::std::mem::size_of::<apm_bios_info>(),
        20usize,
        concat!("Size of: ", stringify!(apm_bios_info))
    );
    assert_eq!(
        ::std::mem::align_of::<apm_bios_info>(),
        4usize,
        concat!("Alignment of ", stringify!(apm_bios_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).cseg as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(cseg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).cseg_16 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(cseg_16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).dseg as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(dseg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).cseg_len as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(cseg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).cseg_16_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(cseg_16_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).dseg_len as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(dseg_len)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__invalid_size_argument_for_IOC"]
    pub static mut __invalid_size_argument_for_IOC: ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct apm_info {
    pub bios: apm_bios_info,
    pub connection_version: ::std::os::raw::c_ushort,
    pub get_power_status_broken: ::std::os::raw::c_int,
    pub get_power_status_swabinminutes: ::std::os::raw::c_int,
    pub allow_ints: ::std::os::raw::c_int,
    pub forbid_idle: ::std::os::raw::c_int,
    pub realmode_power_off: ::std::os::raw::c_int,
    pub disabled: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_apm_info() {
    assert_eq!(
        ::std::mem::size_of::<apm_info>(),
        48usize,
        concat!("Size of: ", stringify!(apm_info))
    );
    assert_eq!(
        ::std::mem::align_of::<apm_info>(),
        4usize,
        concat!("Alignment of ", stringify!(apm_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_info>())).bios as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_info),
            "::",
            stringify!(bios)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_info>())).connection_version as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_info),
            "::",
            stringify!(connection_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apm_info>())).get_power_status_broken as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_info),
            "::",
            stringify!(get_power_status_broken)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apm_info>())).get_power_status_swabinminutes as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_info),
            "::",
            stringify!(get_power_status_swabinminutes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_info>())).allow_ints as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_info),
            "::",
            stringify!(allow_ints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_info>())).forbid_idle as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_info),
            "::",
            stringify!(forbid_idle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_info>())).realmode_power_off as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_info),
            "::",
            stringify!(realmode_power_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_info>())).disabled as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_info),
            "::",
            stringify!(disabled)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}apm_info"]
    pub static mut apm_info: apm_info;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct edd_device_params {
    pub length: __u16,
    pub info_flags: __u16,
    pub num_default_cylinders: __u32,
    pub num_default_heads: __u32,
    pub sectors_per_track: __u32,
    pub number_of_sectors: __u64,
    pub bytes_per_sector: __u16,
    pub dpte_ptr: __u32,
    pub key: __u16,
    pub device_path_info_length: __u8,
    pub reserved2: __u8,
    pub reserved3: __u16,
    pub host_bus_type: [__u8; 4usize],
    pub interface_type: [__u8; 8usize],
    pub interface_path: edd_device_params__bindgen_ty_1,
    pub device_path: edd_device_params__bindgen_ty_2,
    pub reserved4: __u8,
    pub checksum: __u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union edd_device_params__bindgen_ty_1 {
    pub isa: edd_device_params__bindgen_ty_1__bindgen_ty_1,
    pub pci: edd_device_params__bindgen_ty_1__bindgen_ty_2,
    pub ibnd: edd_device_params__bindgen_ty_1__bindgen_ty_3,
    pub xprs: edd_device_params__bindgen_ty_1__bindgen_ty_4,
    pub htpt: edd_device_params__bindgen_ty_1__bindgen_ty_5,
    pub unknown: edd_device_params__bindgen_ty_1__bindgen_ty_6,
    _bindgen_union_align: [u8; 8usize],
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_1 {
    pub base_address: __u16,
    pub reserved1: __u16,
    pub reserved2: __u32,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_1>())).base_address
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(base_address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_1>())).reserved1
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_1>())).reserved2
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_2 {
    pub bus: __u8,
    pub slot: __u8,
    pub function: __u8,
    pub channel: __u8,
    pub reserved: __u32,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_2>())).bus
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_2>())).slot
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(slot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_2>())).function
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_2>())).channel
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_2>())).reserved
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_3 {
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_1__bindgen_ty_3>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_3>())).reserved
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_4 {
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_1__bindgen_ty_4>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_4>())).reserved
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_5 {
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_1__bindgen_ty_5>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_5>())).reserved
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_6 {
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_1__bindgen_ty_6>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_6>())).reserved
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(edd_device_params__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(edd_device_params__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1>())).isa as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1),
            "::",
            stringify!(isa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1>())).pci as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1),
            "::",
            stringify!(pci)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1>())).ibnd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1),
            "::",
            stringify!(ibnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1>())).xprs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1),
            "::",
            stringify!(xprs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1>())).htpt as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1),
            "::",
            stringify!(htpt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1>())).unknown as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1),
            "::",
            stringify!(unknown)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union edd_device_params__bindgen_ty_2 {
    pub ata: edd_device_params__bindgen_ty_2__bindgen_ty_1,
    pub atapi: edd_device_params__bindgen_ty_2__bindgen_ty_2,
    pub scsi: edd_device_params__bindgen_ty_2__bindgen_ty_3,
    pub usb: edd_device_params__bindgen_ty_2__bindgen_ty_4,
    pub i1394: edd_device_params__bindgen_ty_2__bindgen_ty_5,
    pub fibre: edd_device_params__bindgen_ty_2__bindgen_ty_6,
    pub i2o: edd_device_params__bindgen_ty_2__bindgen_ty_7,
    pub raid: edd_device_params__bindgen_ty_2__bindgen_ty_8,
    pub sata: edd_device_params__bindgen_ty_2__bindgen_ty_9,
    pub unknown: edd_device_params__bindgen_ty_2__bindgen_ty_10,
    _bindgen_union_align: [u8; 16usize],
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_1 {
    pub device: __u8,
    pub reserved1: __u8,
    pub reserved2: __u16,
    pub reserved3: __u32,
    pub reserved4: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_1>())).device
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_1>())).reserved1
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_1>())).reserved2
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_1>())).reserved3
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_1>())).reserved4
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(reserved4)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_2 {
    pub device: __u8,
    pub lun: __u8,
    pub reserved1: __u8,
    pub reserved2: __u8,
    pub reserved3: __u32,
    pub reserved4: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_2>())).device
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_2>())).lun
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(lun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_2>())).reserved1
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_2>())).reserved2
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_2>())).reserved3
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_2>())).reserved4
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(reserved4)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_3 {
    pub id: __u16,
    pub lun: __u64,
    pub reserved1: __u16,
    pub reserved2: __u32,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_3>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_3>())).id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_3>())).lun
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(lun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_3>())).reserved1
                as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_3>())).reserved2
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_4 {
    pub serial_number: __u64,
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_4>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_4>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_4>())).serial_number
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_4),
            "::",
            stringify!(serial_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_4>())).reserved
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_4),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_5 {
    pub eui: __u64,
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_5>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_5>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_5>())).eui
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_5),
            "::",
            stringify!(eui)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_5>())).reserved
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_5),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_6 {
    pub wwid: __u64,
    pub lun: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_6>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_6>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_6>())).wwid
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_6),
            "::",
            stringify!(wwid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_6>())).lun
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_6),
            "::",
            stringify!(lun)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_7 {
    pub identity_tag: __u64,
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_7>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_7>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_7>())).identity_tag
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_7),
            "::",
            stringify!(identity_tag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_7>())).reserved
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_7),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_8 {
    pub array_number: __u32,
    pub reserved1: __u32,
    pub reserved2: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_8() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_8>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_8)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_8>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_8>())).array_number
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_8),
            "::",
            stringify!(array_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_8>())).reserved1
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_8),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_8>())).reserved2
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_8),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_9 {
    pub device: __u8,
    pub reserved1: __u8,
    pub reserved2: __u16,
    pub reserved3: __u32,
    pub reserved4: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_9() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_9>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_9)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_9>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_9>())).device
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_9),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_9>())).reserved1
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_9),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_9>())).reserved2
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_9),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_9>())).reserved3
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_9),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_9>())).reserved4
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_9),
            "::",
            stringify!(reserved4)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_10 {
    pub reserved1: __u64,
    pub reserved2: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_10() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_10>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_10)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_10>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_10>())).reserved1
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_10),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_10>())).reserved2
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_10),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(edd_device_params__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(edd_device_params__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).ata as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(ata)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).atapi as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(atapi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).scsi as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(scsi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).usb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(usb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).i1394 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(i1394)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).fibre as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(fibre)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).i2o as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(i2o)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).raid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(raid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).sata as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(sata)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).unknown as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(unknown)
        )
    );
}
#[test]
fn bindgen_test_layout_edd_device_params() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params>(),
        74usize,
        concat!("Size of: ", stringify!(edd_device_params))
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params>(),
        1usize,
        concat!("Alignment of ", stringify!(edd_device_params))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).info_flags as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(info_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params>())).num_default_cylinders as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(num_default_cylinders)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params>())).num_default_heads as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(num_default_heads)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params>())).sectors_per_track as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(sectors_per_track)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params>())).number_of_sectors as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(number_of_sectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params>())).bytes_per_sector as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(bytes_per_sector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).dpte_ptr as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(dpte_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).key as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params>())).device_path_info_length as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(device_path_info_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).reserved2 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).reserved3 as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).host_bus_type as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(host_bus_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params>())).interface_type as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(interface_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params>())).interface_path as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(interface_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).device_path as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(device_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).reserved4 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).checksum as *const _ as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(checksum)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct edd_info {
    pub device: __u8,
    pub version: __u8,
    pub interface_support: __u16,
    pub legacy_max_cylinder: __u16,
    pub legacy_max_head: __u8,
    pub legacy_sectors_per_track: __u8,
    pub params: edd_device_params,
}
#[test]
fn bindgen_test_layout_edd_info() {
    assert_eq!(
        ::std::mem::size_of::<edd_info>(),
        82usize,
        concat!("Size of: ", stringify!(edd_info))
    );
    assert_eq!(
        ::std::mem::align_of::<edd_info>(),
        1usize,
        concat!("Alignment of ", stringify!(edd_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_info>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_info),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_info>())).version as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_info),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_info>())).interface_support as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_info),
            "::",
            stringify!(interface_support)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_info>())).legacy_max_cylinder as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_info),
            "::",
            stringify!(legacy_max_cylinder)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_info>())).legacy_max_head as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_info),
            "::",
            stringify!(legacy_max_head)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_info>())).legacy_sectors_per_track as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_info),
            "::",
            stringify!(legacy_sectors_per_track)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_info>())).params as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_info),
            "::",
            stringify!(params)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct edd {
    pub mbr_signature: [::std::os::raw::c_uint; 16usize],
    pub edd_info: [edd_info; 6usize],
    pub mbr_signature_nr: ::std::os::raw::c_uchar,
    pub edd_info_nr: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_edd() {
    assert_eq!(
        ::std::mem::size_of::<edd>(),
        560usize,
        concat!("Size of: ", stringify!(edd))
    );
    assert_eq!(
        ::std::mem::align_of::<edd>(),
        4usize,
        concat!("Alignment of ", stringify!(edd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd>())).mbr_signature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd),
            "::",
            stringify!(mbr_signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd>())).edd_info as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(edd),
            "::",
            stringify!(edd_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd>())).mbr_signature_nr as *const _ as usize },
        556usize,
        concat!(
            "Offset of field: ",
            stringify!(edd),
            "::",
            stringify!(mbr_signature_nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd>())).edd_info_nr as *const _ as usize },
        557usize,
        concat!(
            "Offset of field: ",
            stringify!(edd),
            "::",
            stringify!(edd_info_nr)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}edd"]
    pub static mut edd: edd;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ist_info {
    pub signature: __u32,
    pub command: __u32,
    pub event: __u32,
    pub perf_level: __u32,
}
#[test]
fn bindgen_test_layout_ist_info() {
    assert_eq!(
        ::std::mem::size_of::<ist_info>(),
        16usize,
        concat!("Size of: ", stringify!(ist_info))
    );
    assert_eq!(
        ::std::mem::align_of::<ist_info>(),
        4usize,
        concat!("Alignment of ", stringify!(ist_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ist_info>())).signature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ist_info),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ist_info>())).command as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ist_info),
            "::",
            stringify!(command)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ist_info>())).event as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ist_info),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ist_info>())).perf_level as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ist_info),
            "::",
            stringify!(perf_level)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}ist_info"]
    pub static mut ist_info: ist_info;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct edid_info {
    pub dummy: [::std::os::raw::c_uchar; 128usize],
}
#[test]
fn bindgen_test_layout_edid_info() {
    assert_eq!(
        ::std::mem::size_of::<edid_info>(),
        128usize,
        concat!("Size of: ", stringify!(edid_info))
    );
    assert_eq!(
        ::std::mem::align_of::<edid_info>(),
        1usize,
        concat!("Alignment of ", stringify!(edid_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edid_info>())).dummy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edid_info),
            "::",
            stringify!(dummy)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}edid_info"]
    pub static mut edid_info: edid_info;
}
#[repr(C)]
pub struct setup_data {
    pub next: __u64,
    pub type_: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[test]
fn bindgen_test_layout_setup_data() {
    assert_eq!(
        ::std::mem::size_of::<setup_data>(),
        16usize,
        concat!("Size of: ", stringify!(setup_data))
    );
    assert_eq!(
        ::std::mem::align_of::<setup_data>(),
        8usize,
        concat!("Alignment of ", stringify!(setup_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_data>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_data),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_data>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_data),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_data>())).len as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_data),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_data>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_data),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct setup_header {
    pub setup_sects: __u8,
    pub root_flags: __u16,
    pub syssize: __u32,
    pub ram_size: __u16,
    pub vid_mode: __u16,
    pub root_dev: __u16,
    pub boot_flag: __u16,
    pub jump: __u16,
    pub header: __u32,
    pub version: __u16,
    pub realmode_swtch: __u32,
    pub start_sys_seg: __u16,
    pub kernel_version: __u16,
    pub type_of_loader: __u8,
    pub loadflags: __u8,
    pub setup_move_size: __u16,
    pub code32_start: __u32,
    pub ramdisk_image: __u32,
    pub ramdisk_size: __u32,
    pub bootsect_kludge: __u32,
    pub heap_end_ptr: __u16,
    pub ext_loader_ver: __u8,
    pub ext_loader_type: __u8,
    pub cmd_line_ptr: __u32,
    pub initrd_addr_max: __u32,
    pub kernel_alignment: __u32,
    pub relocatable_kernel: __u8,
    pub min_alignment: __u8,
    pub xloadflags: __u16,
    pub cmdline_size: __u32,
    pub hardware_subarch: __u32,
    pub hardware_subarch_data: __u64,
    pub payload_offset: __u32,
    pub payload_length: __u32,
    pub setup_data: __u64,
    pub pref_address: __u64,
    pub init_size: __u32,
    pub handover_offset: __u32,
}
#[test]
fn bindgen_test_layout_setup_header() {
    assert_eq!(
        ::std::mem::size_of::<setup_header>(),
        119usize,
        concat!("Size of: ", stringify!(setup_header))
    );
    assert_eq!(
        ::std::mem::align_of::<setup_header>(),
        1usize,
        concat!("Alignment of ", stringify!(setup_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).setup_sects as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(setup_sects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).root_flags as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(root_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).syssize as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(syssize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).ram_size as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(ram_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).vid_mode as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(vid_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).root_dev as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(root_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).boot_flag as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(boot_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).jump as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(jump)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).header as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).version as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).realmode_swtch as *const _ as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(realmode_swtch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).start_sys_seg as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(start_sys_seg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).kernel_version as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(kernel_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).type_of_loader as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(type_of_loader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).loadflags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(loadflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).setup_move_size as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(setup_move_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).code32_start as *const _ as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(code32_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).ramdisk_image as *const _ as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(ramdisk_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).ramdisk_size as *const _ as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(ramdisk_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).bootsect_kludge as *const _ as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(bootsect_kludge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).heap_end_ptr as *const _ as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(heap_end_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).ext_loader_ver as *const _ as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(ext_loader_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).ext_loader_type as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(ext_loader_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).cmd_line_ptr as *const _ as usize },
        55usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(cmd_line_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).initrd_addr_max as *const _ as usize },
        59usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(initrd_addr_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).kernel_alignment as *const _ as usize },
        63usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(kernel_alignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).relocatable_kernel as *const _ as usize },
        67usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(relocatable_kernel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).min_alignment as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(min_alignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).xloadflags as *const _ as usize },
        69usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(xloadflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).cmdline_size as *const _ as usize },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(cmdline_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).hardware_subarch as *const _ as usize },
        75usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(hardware_subarch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<setup_header>())).hardware_subarch_data as *const _ as usize
        },
        79usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(hardware_subarch_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).payload_offset as *const _ as usize },
        87usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(payload_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).payload_length as *const _ as usize },
        91usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(payload_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).setup_data as *const _ as usize },
        95usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(setup_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).pref_address as *const _ as usize },
        103usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(pref_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).init_size as *const _ as usize },
        111usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(init_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).handover_offset as *const _ as usize },
        115usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(handover_offset)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sys_desc_table {
    pub length: __u16,
    pub table: [__u8; 14usize],
}
#[test]
fn bindgen_test_layout_sys_desc_table() {
    assert_eq!(
        ::std::mem::size_of::<sys_desc_table>(),
        16usize,
        concat!("Size of: ", stringify!(sys_desc_table))
    );
    assert_eq!(
        ::std::mem::align_of::<sys_desc_table>(),
        2usize,
        concat!("Alignment of ", stringify!(sys_desc_table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sys_desc_table>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_desc_table),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sys_desc_table>())).table as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_desc_table),
            "::",
            stringify!(table)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct olpc_ofw_header {
    pub ofw_magic: __u32,
    pub ofw_version: __u32,
    pub cif_handler: __u32,
    pub irq_desc_table: __u32,
}
#[test]
fn bindgen_test_layout_olpc_ofw_header() {
    assert_eq!(
        ::std::mem::size_of::<olpc_ofw_header>(),
        16usize,
        concat!("Size of: ", stringify!(olpc_ofw_header))
    );
    assert_eq!(
        ::std::mem::align_of::<olpc_ofw_header>(),
        1usize,
        concat!("Alignment of ", stringify!(olpc_ofw_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<olpc_ofw_header>())).ofw_magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(olpc_ofw_header),
            "::",
            stringify!(ofw_magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<olpc_ofw_header>())).ofw_version as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(olpc_ofw_header),
            "::",
            stringify!(ofw_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<olpc_ofw_header>())).cif_handler as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(olpc_ofw_header),
            "::",
            stringify!(cif_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<olpc_ofw_header>())).irq_desc_table as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(olpc_ofw_header),
            "::",
            stringify!(irq_desc_table)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct efi_info {
    pub efi_loader_signature: __u32,
    pub efi_systab: __u32,
    pub efi_memdesc_size: __u32,
    pub efi_memdesc_version: __u32,
    pub efi_memmap: __u32,
    pub efi_memmap_size: __u32,
    pub efi_systab_hi: __u32,
    pub efi_memmap_hi: __u32,
}
#[test]
fn bindgen_test_layout_efi_info() {
    assert_eq!(
        ::std::mem::size_of::<efi_info>(),
        32usize,
        concat!("Size of: ", stringify!(efi_info))
    );
    assert_eq!(
        ::std::mem::align_of::<efi_info>(),
        4usize,
        concat!("Alignment of ", stringify!(efi_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<efi_info>())).efi_loader_signature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(efi_info),
            "::",
            stringify!(efi_loader_signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<efi_info>())).efi_systab as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(efi_info),
            "::",
            stringify!(efi_systab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<efi_info>())).efi_memdesc_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(efi_info),
            "::",
            stringify!(efi_memdesc_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<efi_info>())).efi_memdesc_version as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(efi_info),
            "::",
            stringify!(efi_memdesc_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<efi_info>())).efi_memmap as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(efi_info),
            "::",
            stringify!(efi_memmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<efi_info>())).efi_memmap_size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(efi_info),
            "::",
            stringify!(efi_memmap_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<efi_info>())).efi_systab_hi as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(efi_info),
            "::",
            stringify!(efi_systab_hi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<efi_info>())).efi_memmap_hi as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(efi_info),
            "::",
            stringify!(efi_memmap_hi)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct boot_e820_entry {
    pub addr: __u64,
    pub size: __u64,
    pub type_: __u32,
}
#[test]
fn bindgen_test_layout_boot_e820_entry() {
    assert_eq!(
        ::std::mem::size_of::<boot_e820_entry>(),
        20usize,
        concat!("Size of: ", stringify!(boot_e820_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<boot_e820_entry>(),
        1usize,
        concat!("Alignment of ", stringify!(boot_e820_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_e820_entry>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_e820_entry),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_e820_entry>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_e820_entry),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_e820_entry>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_e820_entry),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct boot_params {
    pub screen_info: screen_info,
    pub apm_bios_info: apm_bios_info,
    pub _pad2: [__u8; 4usize],
    pub tboot_addr: __u64,
    pub ist_info: ist_info,
    pub _pad3: [__u8; 16usize],
    pub hd0_info: [__u8; 16usize],
    pub hd1_info: [__u8; 16usize],
    pub sys_desc_table: sys_desc_table,
    pub olpc_ofw_header: olpc_ofw_header,
    pub ext_ramdisk_image: __u32,
    pub ext_ramdisk_size: __u32,
    pub ext_cmd_line_ptr: __u32,
    pub _pad4: [__u8; 116usize],
    pub edid_info: edid_info,
    pub efi_info: efi_info,
    pub alt_mem_k: __u32,
    pub scratch: __u32,
    pub e820_entries: __u8,
    pub eddbuf_entries: __u8,
    pub edd_mbr_sig_buf_entries: __u8,
    pub kbd_status: __u8,
    pub secure_boot: __u8,
    pub _pad5: [__u8; 2usize],
    pub sentinel: __u8,
    pub _pad6: [__u8; 1usize],
    pub hdr: setup_header,
    pub _pad7: [__u8; 40usize],
    pub edd_mbr_sig_buffer: [__u32; 16usize],
    pub e820_table: [boot_e820_entry; 128usize],
    pub _pad8: [__u8; 48usize],
    pub eddbuf: [edd_info; 6usize],
    pub _pad9: [__u8; 276usize],
}
#[test]
fn bindgen_test_layout_boot_params() {
    assert_eq!(
        ::std::mem::size_of::<boot_params>(),
        4096usize,
        concat!("Size of: ", stringify!(boot_params))
    );
    assert_eq!(
        ::std::mem::align_of::<boot_params>(),
        1usize,
        concat!("Alignment of ", stringify!(boot_params))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).screen_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(screen_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).apm_bios_info as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(apm_bios_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>()))._pad2 as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(_pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).tboot_addr as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(tboot_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).ist_info as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(ist_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>()))._pad3 as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(_pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).hd0_info as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(hd0_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).hd1_info as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(hd1_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).sys_desc_table as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(sys_desc_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).olpc_ofw_header as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(olpc_ofw_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).ext_ramdisk_image as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(ext_ramdisk_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).ext_ramdisk_size as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(ext_ramdisk_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).ext_cmd_line_ptr as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(ext_cmd_line_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>()))._pad4 as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(_pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).edid_info as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(edid_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).efi_info as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(efi_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).alt_mem_k as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(alt_mem_k)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).scratch as *const _ as usize },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(scratch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).e820_entries as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(e820_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).eddbuf_entries as *const _ as usize },
        489usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(eddbuf_entries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<boot_params>())).edd_mbr_sig_buf_entries as *const _ as usize
        },
        490usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(edd_mbr_sig_buf_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).kbd_status as *const _ as usize },
        491usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(kbd_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).secure_boot as *const _ as usize },
        492usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(secure_boot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>()))._pad5 as *const _ as usize },
        493usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(_pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).sentinel as *const _ as usize },
        495usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(sentinel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>()))._pad6 as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(_pad6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).hdr as *const _ as usize },
        497usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>()))._pad7 as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(_pad7)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).edd_mbr_sig_buffer as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(edd_mbr_sig_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).e820_table as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(e820_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>()))._pad8 as *const _ as usize },
        3280usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(_pad8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).eddbuf as *const _ as usize },
        3328usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(eddbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>()))._pad9 as *const _ as usize },
        3820usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(_pad9)
        )
    );
}
pub const x86_hardware_subarch_X86_SUBARCH_PC: x86_hardware_subarch = 0;
pub const x86_hardware_subarch_X86_SUBARCH_LGUEST: x86_hardware_subarch = 1;
pub const x86_hardware_subarch_X86_SUBARCH_XEN: x86_hardware_subarch = 2;
pub const x86_hardware_subarch_X86_SUBARCH_INTEL_MID: x86_hardware_subarch = 3;
pub const x86_hardware_subarch_X86_SUBARCH_CE4100: x86_hardware_subarch = 4;
pub const x86_hardware_subarch_X86_NR_SUBARCHS: x86_hardware_subarch = 5;
#[doc = " enum x86_hardware_subarch - x86 hardware subarchitecture"]
#[doc = ""]
#[doc = " The x86 hardware_subarch and hardware_subarch_data were added as of the x86"]
#[doc = " boot protocol 2.07 to help distinguish and support custom x86 boot"]
#[doc = " sequences. This enum represents accepted values for the x86"]
#[doc = " hardware_subarch.  Custom x86 boot sequences (not X86_SUBARCH_PC) do not"]
#[doc = " have or simply *cannot* make use of natural stubs like BIOS or EFI, the"]
#[doc = " hardware_subarch can be used on the Linux entry path to revector to a"]
#[doc = " subarchitecture stub when needed. This subarchitecture stub can be used to"]
#[doc = " set up Linux boot parameters or for special care to account for nonstandard"]
#[doc = " handling of page tables."]
#[doc = ""]
#[doc = " These enums should only ever be used by x86 code, and the code that uses"]
#[doc = " it should be well contained and compartamentalized."]
#[doc = ""]
#[doc = " KVM and Xen HVM do not have a subarch as these are expected to follow"]
#[doc = " standard x86 boot entries. If there is a genuine need for \"hypervisor\" type"]
#[doc = " that should be considered separately in the future. Future guest types"]
#[doc = " should seriously consider working with standard x86 boot stubs such as"]
#[doc = " the BIOS or EFI boot stubs."]
#[doc = ""]
#[doc = " WARNING: this enum is only used for legacy hacks, for platform features that"]
#[doc = "\t    are not easily enumerated or discoverable. You should not ever use"]
#[doc = "\t    this for new features."]
#[doc = ""]
#[doc = " @X86_SUBARCH_PC: Should be used if the hardware is enumerable using standard"]
#[doc = "\tPC mechanisms (PCI, ACPI) and doesn't need a special boot flow."]
#[doc = " @X86_SUBARCH_LGUEST: Used for x86 hypervisor demo, lguest, deprecated"]
#[doc = " @X86_SUBARCH_XEN: Used for Xen guest types which follow the PV boot path,"]
#[doc = " \twhich start at asm startup_xen() entry point and later jump to the C"]
#[doc = " \txen_start_kernel() entry point. Both domU and dom0 type of guests are"]
#[doc = " \tcurrently supportd through this PV boot path."]
#[doc = " @X86_SUBARCH_INTEL_MID: Used for Intel MID (Mobile Internet Device) platform"]
#[doc = "\tsystems which do not have the PCI legacy interfaces."]
#[doc = " @X86_SUBARCH_CE4100: Used for Intel CE media processor (CE4100) SoC for"]
#[doc = " \tfor settop boxes and media devices, the use of a subarch for CE4100"]
#[doc = " \tis more of a hack..."]
pub type x86_hardware_subarch = u32;
extern "C" {
    #[link_name = "\u{1}sme_me_mask"]
    pub static mut sme_me_mask: __u64;
}
extern "C" {
    pub fn sme_encrypt_execute(
        encrypted_kernel_vaddr: ::std::os::raw::c_ulong,
        decrypted_kernel_vaddr: ::std::os::raw::c_ulong,
        kernel_len: ::std::os::raw::c_ulong,
        encryption_wa: ::std::os::raw::c_ulong,
        encryption_pgd: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn sme_early_encrypt(paddr: resource_size_t, size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn sme_early_decrypt(paddr: resource_size_t, size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn sme_map_bootdata(real_mode_data: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn sme_unmap_bootdata(real_mode_data: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn sme_early_init();
}
extern "C" {
    pub fn sme_encrypt_kernel(bp: *mut boot_params);
}
extern "C" {
    pub fn sme_enable(bp: *mut boot_params);
}
extern "C" {
    pub fn early_set_memory_decrypted(
        vaddr: ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn early_set_memory_encrypted(
        vaddr: ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mem_encrypt_init();
}
extern "C" {
    pub fn swiotlb_set_mem_attributes(
        vaddr: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn sme_active() -> bool_;
}
extern "C" {
    pub fn sev_active() -> bool_;
}
extern "C" {
    pub fn kaslr_get_random_long(purpose: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}page_offset_base"]
    pub static mut page_offset_base: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}vmalloc_base"]
    pub static mut vmalloc_base: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}vmemmap_base"]
    pub static mut vmemmap_base: ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn kernel_randomize_memory();
}
extern "C" {
    pub fn devmem_is_allowed(pagenr: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}max_low_pfn_mapped"]
    pub static mut max_low_pfn_mapped: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}max_pfn_mapped"]
    pub static mut max_pfn_mapped: ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn pfn_range_is_mapped(
        start_pfn: ::std::os::raw::c_ulong,
        end_pfn: ::std::os::raw::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn init_memory_mapping(
        start: ::std::os::raw::c_ulong,
        end: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn initmem_init();
}
extern "C" {
    #[link_name = "\u{1}max_pfn"]
    pub static mut max_pfn: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}phys_base"]
    pub static mut phys_base: ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn clear_page_orig(page: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn clear_page_rep(page: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn clear_page_erms(page: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn copy_page(to: *mut ::std::os::raw::c_void, from: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct range {
    pub start: __u64,
    pub end: __u64,
}
#[test]
fn bindgen_test_layout_range() {
    assert_eq!(
        ::std::mem::size_of::<range>(),
        16usize,
        concat!("Size of: ", stringify!(range))
    );
    assert_eq!(
        ::std::mem::align_of::<range>(),
        8usize,
        concat!("Alignment of ", stringify!(range))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<range>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(range),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<range>())).end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(range),
            "::",
            stringify!(end)
        )
    );
}
extern "C" {
    pub fn add_range(
        range: *mut range,
        az: ::std::os::raw::c_int,
        nr_range: ::std::os::raw::c_int,
        start: __u64,
        end: __u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn add_range_with_merge(
        range: *mut range,
        az: ::std::os::raw::c_int,
        nr_range: ::std::os::raw::c_int,
        start: __u64,
        end: __u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn subtract_range(range: *mut range, az: ::std::os::raw::c_int, start: __u64, end: __u64);
}
extern "C" {
    pub fn clean_sort_range(range: *mut range, az: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sort_range(range: *mut range, nr_range: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}pfn_mapped"]
    pub static mut pfn_mapped: [range; 0usize];
}
extern "C" {
    #[link_name = "\u{1}nr_pfn_mapped"]
    pub static mut nr_pfn_mapped: ::std::os::raw::c_int;
}
extern "C" {
    pub fn __virt_addr_valid(kaddr: ::std::os::raw::c_ulong) -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pfn_t {
    pub val: __u64,
}
#[test]
fn bindgen_test_layout_pfn_t() {
    assert_eq!(
        ::std::mem::size_of::<pfn_t>(),
        8usize,
        concat!("Size of: ", stringify!(pfn_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pfn_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pfn_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfn_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pfn_t),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm86 {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}early_idt_handler_array"]
    pub static mut early_idt_handler_array: [[::std::os::raw::c_char; 9usize]; 32usize];
}
extern "C" {
    pub fn early_ignore_irq();
}
extern "C" {
    #[link_name = "\u{1}xen_early_idt_handler_array"]
    pub static mut xen_early_idt_handler_array: [[::std::os::raw::c_char; 8usize]; 32usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pt_regs {
    pub r15: ::std::os::raw::c_ulong,
    pub r14: ::std::os::raw::c_ulong,
    pub r13: ::std::os::raw::c_ulong,
    pub r12: ::std::os::raw::c_ulong,
    pub bp: ::std::os::raw::c_ulong,
    pub bx: ::std::os::raw::c_ulong,
    pub r11: ::std::os::raw::c_ulong,
    pub r10: ::std::os::raw::c_ulong,
    pub r9: ::std::os::raw::c_ulong,
    pub r8: ::std::os::raw::c_ulong,
    pub ax: ::std::os::raw::c_ulong,
    pub cx: ::std::os::raw::c_ulong,
    pub dx: ::std::os::raw::c_ulong,
    pub si: ::std::os::raw::c_ulong,
    pub di: ::std::os::raw::c_ulong,
    pub orig_ax: ::std::os::raw::c_ulong,
    pub ip: ::std::os::raw::c_ulong,
    pub cs: ::std::os::raw::c_ulong,
    pub flags: ::std::os::raw::c_ulong,
    pub sp: ::std::os::raw::c_ulong,
    pub ss: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_pt_regs() {
    assert_eq!(
        ::std::mem::size_of::<pt_regs>(),
        168usize,
        concat!("Size of: ", stringify!(pt_regs))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_regs>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_regs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r15 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r14 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r13 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r12 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).bp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(bp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).bx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(bx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r11 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r10 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r9 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r8 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).ax as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(ax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).cx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).dx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).si as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(si)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).di as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(di)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).orig_ax as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(orig_ax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).ip as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).cs as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).flags as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).sp as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).ss as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(ss)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct desc_struct {
    pub limit0: u16,
    pub base0: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_desc_struct() {
    assert_eq!(
        ::std::mem::size_of::<desc_struct>(),
        8usize,
        concat!("Size of: ", stringify!(desc_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<desc_struct>(),
        1usize,
        concat!("Alignment of ", stringify!(desc_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<desc_struct>())).limit0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(desc_struct),
            "::",
            stringify!(limit0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<desc_struct>())).base0 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(desc_struct),
            "::",
            stringify!(base0)
        )
    );
}
impl desc_struct {
    #[inline]
    pub fn base1(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_base1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn s(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_s(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dpl(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_dpl(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn p(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn limit1(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_limit1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn avl(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_avl(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_l(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn d(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_d(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn g(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_g(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn base2(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_base2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        base1: u16,
        type_: u16,
        s: u16,
        dpl: u16,
        p: u16,
        limit1: u16,
        avl: u16,
        l: u16,
        d: u16,
        g: u16,
        base2: u16,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let base1: u16 = unsafe { ::std::mem::transmute(base1) };
            base1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let type_: u16 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let s: u16 = unsafe { ::std::mem::transmute(s) };
            s as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let dpl: u16 = unsafe { ::std::mem::transmute(dpl) };
            dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let p: u16 = unsafe { ::std::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let limit1: u16 = unsafe { ::std::mem::transmute(limit1) };
            limit1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let avl: u16 = unsafe { ::std::mem::transmute(avl) };
            avl as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let l: u16 = unsafe { ::std::mem::transmute(l) };
            l as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let d: u16 = unsafe { ::std::mem::transmute(d) };
            d as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let g: u16 = unsafe { ::std::mem::transmute(g) };
            g as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let base2: u16 = unsafe { ::std::mem::transmute(base2) };
            base2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const GATE_INTERRUPT: _bindgen_ty_4 = 14;
pub const GATE_TRAP: _bindgen_ty_4 = 15;
pub const GATE_CALL: _bindgen_ty_4 = 12;
pub const GATE_TASK: _bindgen_ty_4 = 5;
pub type _bindgen_ty_4 = u32;
pub const DESC_TSS: _bindgen_ty_5 = 9;
pub const DESC_LDT: _bindgen_ty_5 = 2;
pub const DESCTYPE_S: _bindgen_ty_5 = 16;
pub type _bindgen_ty_5 = u32;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ldttss_desc {
    pub limit0: u16,
    pub base0: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub base3: u32,
    pub zero1: u32,
}
#[test]
fn bindgen_test_layout_ldttss_desc() {
    assert_eq!(
        ::std::mem::size_of::<ldttss_desc>(),
        16usize,
        concat!("Size of: ", stringify!(ldttss_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<ldttss_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(ldttss_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldttss_desc>())).limit0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldttss_desc),
            "::",
            stringify!(limit0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldttss_desc>())).base0 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ldttss_desc),
            "::",
            stringify!(base0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldttss_desc>())).base3 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldttss_desc),
            "::",
            stringify!(base3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldttss_desc>())).zero1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ldttss_desc),
            "::",
            stringify!(zero1)
        )
    );
}
impl ldttss_desc {
    #[inline]
    pub fn base1(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_base1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn dpl(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_dpl(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn p(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn limit1(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_limit1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn zero0(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_zero0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn g(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_g(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn base2(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_base2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        base1: u16,
        type_: u16,
        dpl: u16,
        p: u16,
        limit1: u16,
        zero0: u16,
        g: u16,
        base2: u16,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let base1: u16 = unsafe { ::std::mem::transmute(base1) };
            base1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let type_: u16 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let dpl: u16 = unsafe { ::std::mem::transmute(dpl) };
            dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let p: u16 = unsafe { ::std::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let limit1: u16 = unsafe { ::std::mem::transmute(limit1) };
            limit1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 3u8, {
            let zero0: u16 = unsafe { ::std::mem::transmute(zero0) };
            zero0 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let g: u16 = unsafe { ::std::mem::transmute(g) };
            g as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let base2: u16 = unsafe { ::std::mem::transmute(base2) };
            base2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ldt_desc = ldttss_desc;
pub type tss_desc = ldttss_desc;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct idt_bits {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_idt_bits() {
    assert_eq!(
        ::std::mem::size_of::<idt_bits>(),
        2usize,
        concat!("Size of: ", stringify!(idt_bits))
    );
    assert_eq!(
        ::std::mem::align_of::<idt_bits>(),
        1usize,
        concat!("Alignment of ", stringify!(idt_bits))
    );
}
impl idt_bits {
    #[inline]
    pub fn ist(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_ist(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn zero(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_zero(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn dpl(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_dpl(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn p(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ist: u16,
        zero: u16,
        type_: u16,
        dpl: u16,
        p: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let ist: u16 = unsafe { ::std::mem::transmute(ist) };
            ist as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let zero: u16 = unsafe { ::std::mem::transmute(zero) };
            zero as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let type_: u16 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let dpl: u16 = unsafe { ::std::mem::transmute(dpl) };
            dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let p: u16 = unsafe { ::std::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct gate_struct {
    pub offset_low: u16,
    pub segment: u16,
    pub bits: idt_bits,
    pub offset_middle: u16,
    pub offset_high: u32,
    pub reserved: u32,
}
#[test]
fn bindgen_test_layout_gate_struct() {
    assert_eq!(
        ::std::mem::size_of::<gate_struct>(),
        16usize,
        concat!("Size of: ", stringify!(gate_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<gate_struct>(),
        1usize,
        concat!("Alignment of ", stringify!(gate_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gate_struct>())).offset_low as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_struct),
            "::",
            stringify!(offset_low)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gate_struct>())).segment as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_struct),
            "::",
            stringify!(segment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gate_struct>())).bits as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_struct),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gate_struct>())).offset_middle as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_struct),
            "::",
            stringify!(offset_middle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gate_struct>())).offset_high as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_struct),
            "::",
            stringify!(offset_high)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gate_struct>())).reserved as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_struct),
            "::",
            stringify!(reserved)
        )
    );
}
pub type gate_desc = gate_struct;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct desc_ptr {
    pub size: ::std::os::raw::c_ushort,
    pub address: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_desc_ptr() {
    assert_eq!(
        ::std::mem::size_of::<desc_ptr>(),
        10usize,
        concat!("Size of: ", stringify!(desc_ptr))
    );
    assert_eq!(
        ::std::mem::align_of::<desc_ptr>(),
        1usize,
        concat!("Alignment of ", stringify!(desc_ptr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<desc_ptr>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(desc_ptr),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<desc_ptr>())).address as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(desc_ptr),
            "::",
            stringify!(address)
        )
    );
}
pub const page_cache_mode__PAGE_CACHE_MODE_WB: page_cache_mode = 0;
pub const page_cache_mode__PAGE_CACHE_MODE_WC: page_cache_mode = 1;
pub const page_cache_mode__PAGE_CACHE_MODE_UC_MINUS: page_cache_mode = 2;
pub const page_cache_mode__PAGE_CACHE_MODE_UC: page_cache_mode = 3;
pub const page_cache_mode__PAGE_CACHE_MODE_WT: page_cache_mode = 4;
pub const page_cache_mode__PAGE_CACHE_MODE_WP: page_cache_mode = 5;
pub const page_cache_mode__PAGE_CACHE_MODE_NUM: page_cache_mode = 8;
pub type page_cache_mode = u32;
pub type pteval_t = ::std::os::raw::c_ulong;
pub type pmdval_t = ::std::os::raw::c_ulong;
pub type pudval_t = ::std::os::raw::c_ulong;
pub type p4dval_t = ::std::os::raw::c_ulong;
pub type pgdval_t = ::std::os::raw::c_ulong;
pub type pgprotval_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pte_t {
    pub pte: pteval_t,
}
#[test]
fn bindgen_test_layout_pte_t() {
    assert_eq!(
        ::std::mem::size_of::<pte_t>(),
        8usize,
        concat!("Size of: ", stringify!(pte_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pte_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pte_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pte_t>())).pte as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pte_t),
            "::",
            stringify!(pte)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pgprot {
    pub pgprot: pgprotval_t,
}
#[test]
fn bindgen_test_layout_pgprot() {
    assert_eq!(
        ::std::mem::size_of::<pgprot>(),
        8usize,
        concat!("Size of: ", stringify!(pgprot))
    );
    assert_eq!(
        ::std::mem::align_of::<pgprot>(),
        8usize,
        concat!("Alignment of ", stringify!(pgprot))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pgprot>())).pgprot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pgprot),
            "::",
            stringify!(pgprot)
        )
    );
}
pub type pgprot_t = pgprot;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pgd_t {
    pub pgd: pgdval_t,
}
#[test]
fn bindgen_test_layout_pgd_t() {
    assert_eq!(
        ::std::mem::size_of::<pgd_t>(),
        8usize,
        concat!("Size of: ", stringify!(pgd_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pgd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pgd_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pgd_t>())).pgd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pgd_t),
            "::",
            stringify!(pgd)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct p4d_t {
    pub pgd: pgd_t,
}
#[test]
fn bindgen_test_layout_p4d_t() {
    assert_eq!(
        ::std::mem::size_of::<p4d_t>(),
        8usize,
        concat!("Size of: ", stringify!(p4d_t))
    );
    assert_eq!(
        ::std::mem::align_of::<p4d_t>(),
        8usize,
        concat!("Alignment of ", stringify!(p4d_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<p4d_t>())).pgd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(p4d_t),
            "::",
            stringify!(pgd)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pud_t {
    pub pud: pudval_t,
}
#[test]
fn bindgen_test_layout_pud_t() {
    assert_eq!(
        ::std::mem::size_of::<pud_t>(),
        8usize,
        concat!("Size of: ", stringify!(pud_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pud_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pud_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pud_t>())).pud as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pud_t),
            "::",
            stringify!(pud)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmd_t {
    pub pmd: pmdval_t,
}
#[test]
fn bindgen_test_layout_pmd_t() {
    assert_eq!(
        ::std::mem::size_of::<pmd_t>(),
        8usize,
        concat!("Size of: ", stringify!(pmd_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pmd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pmd_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pmd_t>())).pmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pmd_t),
            "::",
            stringify!(pmd)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__cachemode2pte_tbl"]
    pub static mut __cachemode2pte_tbl: [u16; 8usize];
}
extern "C" {
    #[link_name = "\u{1}__pte2cachemode_tbl"]
    pub static mut __pte2cachemode_tbl: [u8; 8usize];
}
pub type pgtable_t = *mut page;
extern "C" {
    #[link_name = "\u{1}__supported_pte_mask"]
    pub static mut __supported_pte_mask: pteval_t;
}
extern "C" {
    #[link_name = "\u{1}__default_kernel_pte_mask"]
    pub static mut __default_kernel_pte_mask: pteval_t;
}
extern "C" {
    pub fn set_nx();
}
extern "C" {
    #[link_name = "\u{1}nx_enabled"]
    pub static mut nx_enabled: ::std::os::raw::c_int;
}
extern "C" {
    pub fn pgprot_writecombine(prot: pgprot_t) -> pgprot_t;
}
extern "C" {
    pub fn pgprot_writethrough(prot: pgprot_t) -> pgprot_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file {
    _unused: [u8; 0],
}
extern "C" {
    pub fn phys_mem_access_prot(
        file: *mut file,
        pfn: ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
        vma_prot: pgprot_t,
    ) -> pgprot_t;
}
extern "C" {
    pub fn set_pte_vaddr(vaddr: ::std::os::raw::c_ulong, pte: pte_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seq_file {
    _unused: [u8; 0],
}
extern "C" {
    pub fn arch_report_meminfo(m: *mut seq_file);
}
pub const pg_level_PG_LEVEL_NONE: pg_level = 0;
pub const pg_level_PG_LEVEL_4K: pg_level = 1;
pub const pg_level_PG_LEVEL_2M: pg_level = 2;
pub const pg_level_PG_LEVEL_1G: pg_level = 3;
pub const pg_level_PG_LEVEL_512G: pg_level = 4;
pub const pg_level_PG_LEVEL_NUM: pg_level = 5;
pub type pg_level = u32;
extern "C" {
    pub fn update_page_count(level: ::std::os::raw::c_int, pages: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn lookup_address(
        address: ::std::os::raw::c_ulong,
        level: *mut ::std::os::raw::c_uint,
    ) -> *mut pte_t;
}
extern "C" {
    pub fn lookup_address_in_pgd(
        pgd: *mut pgd_t,
        address: ::std::os::raw::c_ulong,
        level: *mut ::std::os::raw::c_uint,
    ) -> *mut pte_t;
}
extern "C" {
    pub fn lookup_pmd_address(address: ::std::os::raw::c_ulong) -> *mut pmd_t;
}
extern "C" {
    pub fn slow_virt_to_phys(__address: *mut ::std::os::raw::c_void) -> phys_addr_t;
}
extern "C" {
    pub fn kernel_map_pages_in_pgd(
        pgd: *mut pgd_t,
        pfn: __u64,
        address: ::std::os::raw::c_ulong,
        numpages: ::std::os::raw::c_uint,
        page_flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}static_key_initialized"]
    pub static mut static_key_initialized: bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key {
    pub enabled: atomic_t,
}
#[test]
fn bindgen_test_layout_static_key() {
    assert_eq!(
        ::std::mem::size_of::<static_key>(),
        4usize,
        concat!("Size of: ", stringify!(static_key))
    );
    assert_eq!(
        ::std::mem::align_of::<static_key>(),
        4usize,
        concat!("Alignment of ", stringify!(static_key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<static_key>())).enabled as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_key),
            "::",
            stringify!(enabled)
        )
    );
}
pub const jump_label_type_JUMP_LABEL_NOP: jump_label_type = 0;
pub const jump_label_type_JUMP_LABEL_JMP: jump_label_type = 1;
pub type jump_label_type = u32;
extern "C" {
    pub fn __xchg_wrong_size();
}
extern "C" {
    pub fn __cmpxchg_wrong_size();
}
extern "C" {
    pub fn __xadd_wrong_size();
}
extern "C" {
    pub fn __add_wrong_size();
}
pub type atomic_long_t = atomic64_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key_true {
    pub key: static_key,
}
#[test]
fn bindgen_test_layout_static_key_true() {
    assert_eq!(
        ::std::mem::size_of::<static_key_true>(),
        4usize,
        concat!("Size of: ", stringify!(static_key_true))
    );
    assert_eq!(
        ::std::mem::align_of::<static_key_true>(),
        4usize,
        concat!("Alignment of ", stringify!(static_key_true))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<static_key_true>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_key_true),
            "::",
            stringify!(key)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key_false {
    pub key: static_key,
}
#[test]
fn bindgen_test_layout_static_key_false() {
    assert_eq!(
        ::std::mem::size_of::<static_key_false>(),
        4usize,
        concat!("Size of: ", stringify!(static_key_false))
    );
    assert_eq!(
        ::std::mem::align_of::<static_key_false>(),
        4usize,
        concat!("Alignment of ", stringify!(static_key_false))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<static_key_false>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_key_false),
            "::",
            stringify!(key)
        )
    );
}
extern "C" {
    pub fn ____wrong_branch_error() -> bool_;
}
pub const spectre_v2_mitigation_SPECTRE_V2_NONE: spectre_v2_mitigation = 0;
pub const spectre_v2_mitigation_SPECTRE_V2_RETPOLINE_GENERIC: spectre_v2_mitigation = 1;
pub const spectre_v2_mitigation_SPECTRE_V2_RETPOLINE_AMD: spectre_v2_mitigation = 2;
pub const spectre_v2_mitigation_SPECTRE_V2_IBRS_ENHANCED: spectre_v2_mitigation = 3;
pub type spectre_v2_mitigation = u32;
pub const spectre_v2_user_mitigation_SPECTRE_V2_USER_NONE: spectre_v2_user_mitigation = 0;
pub const spectre_v2_user_mitigation_SPECTRE_V2_USER_STRICT: spectre_v2_user_mitigation = 1;
pub const spectre_v2_user_mitigation_SPECTRE_V2_USER_STRICT_PREFERRED: spectre_v2_user_mitigation =
    2;
pub const spectre_v2_user_mitigation_SPECTRE_V2_USER_PRCTL: spectre_v2_user_mitigation = 3;
pub const spectre_v2_user_mitigation_SPECTRE_V2_USER_SECCOMP: spectre_v2_user_mitigation = 4;
pub type spectre_v2_user_mitigation = u32;
pub const ssb_mitigation_SPEC_STORE_BYPASS_NONE: ssb_mitigation = 0;
pub const ssb_mitigation_SPEC_STORE_BYPASS_DISABLE: ssb_mitigation = 1;
pub const ssb_mitigation_SPEC_STORE_BYPASS_PRCTL: ssb_mitigation = 2;
pub const ssb_mitigation_SPEC_STORE_BYPASS_SECCOMP: ssb_mitigation = 3;
pub type ssb_mitigation = u32;
extern "C" {
    #[link_name = "\u{1}__indirect_thunk_start"]
    pub static mut __indirect_thunk_start: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}__indirect_thunk_end"]
    pub static mut __indirect_thunk_end: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}x86_spec_ctrl_base"]
    pub static mut x86_spec_ctrl_base: __u64;
}
extern "C" {
    #[link_name = "\u{1}switch_to_cond_stibp"]
    pub static mut switch_to_cond_stibp: static_key_false;
}
extern "C" {
    #[link_name = "\u{1}switch_mm_cond_ibpb"]
    pub static mut switch_mm_cond_ibpb: static_key_false;
}
extern "C" {
    #[link_name = "\u{1}switch_mm_always_ibpb"]
    pub static mut switch_mm_always_ibpb: static_key_false;
}
extern "C" {
    #[link_name = "\u{1}mds_user_clear"]
    pub static mut mds_user_clear: static_key_false;
}
extern "C" {
    #[link_name = "\u{1}mds_idle_clear"]
    pub static mut mds_idle_clear: static_key_false;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flush_tlb_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct paravirt_callee_save {
    pub func: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_paravirt_callee_save() {
    assert_eq!(
        ::std::mem::size_of::<paravirt_callee_save>(),
        8usize,
        concat!("Size of: ", stringify!(paravirt_callee_save))
    );
    assert_eq!(
        ::std::mem::align_of::<paravirt_callee_save>(),
        8usize,
        concat!("Alignment of ", stringify!(paravirt_callee_save))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paravirt_callee_save>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_callee_save),
            "::",
            stringify!(func)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pv_info {
    pub kernel_rpl: ::std::os::raw::c_uint,
    pub shared_kernel_pmd: ::std::os::raw::c_int,
    pub extra_user_64bit_cs: u16,
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_pv_info() {
    assert_eq!(
        ::std::mem::size_of::<pv_info>(),
        24usize,
        concat!("Size of: ", stringify!(pv_info))
    );
    assert_eq!(
        ::std::mem::align_of::<pv_info>(),
        8usize,
        concat!("Alignment of ", stringify!(pv_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_info>())).kernel_rpl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_info),
            "::",
            stringify!(kernel_rpl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_info>())).shared_kernel_pmd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_info),
            "::",
            stringify!(shared_kernel_pmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_info>())).extra_user_64bit_cs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_info),
            "::",
            stringify!(extra_user_64bit_cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_info>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_info),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pv_init_ops {
    pub patch: ::std::option::Option<
        unsafe extern "C" fn(
            type_: u8,
            clobber: u16,
            insnbuf: *mut ::std::os::raw::c_void,
            addr: ::std::os::raw::c_ulong,
            len: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_uint,
    >,
}
#[test]
fn bindgen_test_layout_pv_init_ops() {
    assert_eq!(
        ::std::mem::size_of::<pv_init_ops>(),
        8usize,
        concat!("Size of: ", stringify!(pv_init_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<pv_init_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(pv_init_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_init_ops>())).patch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_init_ops),
            "::",
            stringify!(patch)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pv_lazy_ops {
    pub enter: ::std::option::Option<unsafe extern "C" fn()>,
    pub leave: ::std::option::Option<unsafe extern "C" fn()>,
    pub flush: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_pv_lazy_ops() {
    assert_eq!(
        ::std::mem::size_of::<pv_lazy_ops>(),
        24usize,
        concat!("Size of: ", stringify!(pv_lazy_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<pv_lazy_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(pv_lazy_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_lazy_ops>())).enter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_lazy_ops),
            "::",
            stringify!(enter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_lazy_ops>())).leave as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_lazy_ops),
            "::",
            stringify!(leave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_lazy_ops>())).flush as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_lazy_ops),
            "::",
            stringify!(flush)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pv_time_ops {
    pub sched_clock: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_ulonglong>,
    pub steal_clock: ::std::option::Option<
        unsafe extern "C" fn(cpu: ::std::os::raw::c_int) -> ::std::os::raw::c_ulonglong,
    >,
}
#[test]
fn bindgen_test_layout_pv_time_ops() {
    assert_eq!(
        ::std::mem::size_of::<pv_time_ops>(),
        16usize,
        concat!("Size of: ", stringify!(pv_time_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<pv_time_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(pv_time_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_time_ops>())).sched_clock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_time_ops),
            "::",
            stringify!(sched_clock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_time_ops>())).steal_clock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_time_ops),
            "::",
            stringify!(steal_clock)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pv_cpu_ops {
    pub get_debugreg: ::std::option::Option<
        unsafe extern "C" fn(regno: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong,
    >,
    pub set_debugreg: ::std::option::Option<
        unsafe extern "C" fn(regno: ::std::os::raw::c_int, value: ::std::os::raw::c_ulong),
    >,
    pub read_cr0: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_ulong>,
    pub write_cr0: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_ulong)>,
    pub write_cr4: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_ulong)>,
    pub read_cr8: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_ulong>,
    pub write_cr8: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_ulong)>,
    pub load_tr_desc: ::std::option::Option<unsafe extern "C" fn()>,
    pub load_gdt: ::std::option::Option<unsafe extern "C" fn(arg1: *const desc_ptr)>,
    pub load_idt: ::std::option::Option<unsafe extern "C" fn(arg1: *const desc_ptr)>,
    pub set_ldt: ::std::option::Option<
        unsafe extern "C" fn(desc: *const ::std::os::raw::c_void, entries: ::std::os::raw::c_uint),
    >,
    pub store_tr: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_ulong>,
    pub load_tls: ::std::option::Option<
        unsafe extern "C" fn(t: *mut thread_struct, cpu: ::std::os::raw::c_uint),
    >,
    pub load_gs_index: ::std::option::Option<unsafe extern "C" fn(idx: ::std::os::raw::c_uint)>,
    pub write_ldt_entry: ::std::option::Option<
        unsafe extern "C" fn(
            ldt: *mut desc_struct,
            entrynum: ::std::os::raw::c_int,
            desc: *const ::std::os::raw::c_void,
        ),
    >,
    pub write_gdt_entry: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut desc_struct,
            entrynum: ::std::os::raw::c_int,
            desc: *const ::std::os::raw::c_void,
            size: ::std::os::raw::c_int,
        ),
    >,
    pub write_idt_entry: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gate_desc,
            entrynum: ::std::os::raw::c_int,
            gate: *const gate_desc,
        ),
    >,
    pub alloc_ldt: ::std::option::Option<
        unsafe extern "C" fn(ldt: *mut desc_struct, entries: ::std::os::raw::c_uint),
    >,
    pub free_ldt: ::std::option::Option<
        unsafe extern "C" fn(ldt: *mut desc_struct, entries: ::std::os::raw::c_uint),
    >,
    pub load_sp0: ::std::option::Option<unsafe extern "C" fn(sp0: ::std::os::raw::c_ulong)>,
    pub set_iopl_mask: ::std::option::Option<unsafe extern "C" fn(mask: ::std::os::raw::c_uint)>,
    pub wbinvd: ::std::option::Option<unsafe extern "C" fn()>,
    pub io_delay: ::std::option::Option<unsafe extern "C" fn()>,
    pub cpuid: ::std::option::Option<
        unsafe extern "C" fn(
            eax: *mut ::std::os::raw::c_uint,
            ebx: *mut ::std::os::raw::c_uint,
            ecx: *mut ::std::os::raw::c_uint,
            edx: *mut ::std::os::raw::c_uint,
        ),
    >,
    pub read_msr: ::std::option::Option<unsafe extern "C" fn(msr: ::std::os::raw::c_uint) -> __u64>,
    pub write_msr: ::std::option::Option<
        unsafe extern "C" fn(
            msr: ::std::os::raw::c_uint,
            low: ::std::os::raw::c_uint,
            high: ::std::os::raw::c_uint,
        ),
    >,
    pub read_msr_safe: ::std::option::Option<
        unsafe extern "C" fn(msr: ::std::os::raw::c_uint, err: *mut ::std::os::raw::c_int) -> __u64,
    >,
    pub write_msr_safe: ::std::option::Option<
        unsafe extern "C" fn(
            msr: ::std::os::raw::c_uint,
            low: ::std::os::raw::c_uint,
            high: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub read_pmc:
        ::std::option::Option<unsafe extern "C" fn(counter: ::std::os::raw::c_int) -> __u64>,
    pub usergs_sysret64: ::std::option::Option<unsafe extern "C" fn()>,
    pub iret: ::std::option::Option<unsafe extern "C" fn()>,
    pub swapgs: ::std::option::Option<unsafe extern "C" fn()>,
    pub start_context_switch: ::std::option::Option<unsafe extern "C" fn(prev: *mut task_struct)>,
    pub end_context_switch: ::std::option::Option<unsafe extern "C" fn(next: *mut task_struct)>,
}
#[test]
fn bindgen_test_layout_pv_cpu_ops() {
    assert_eq!(
        ::std::mem::size_of::<pv_cpu_ops>(),
        272usize,
        concat!("Size of: ", stringify!(pv_cpu_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<pv_cpu_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(pv_cpu_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).get_debugreg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(get_debugreg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).set_debugreg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(set_debugreg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).read_cr0 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(read_cr0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).write_cr0 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(write_cr0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).write_cr4 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(write_cr4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).read_cr8 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(read_cr8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).write_cr8 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(write_cr8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).load_tr_desc as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(load_tr_desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).load_gdt as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(load_gdt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).load_idt as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(load_idt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).set_ldt as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(set_ldt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).store_tr as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(store_tr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).load_tls as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(load_tls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).load_gs_index as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(load_gs_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).write_ldt_entry as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(write_ldt_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).write_gdt_entry as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(write_gdt_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).write_idt_entry as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(write_idt_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).alloc_ldt as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(alloc_ldt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).free_ldt as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(free_ldt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).load_sp0 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(load_sp0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).set_iopl_mask as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(set_iopl_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).wbinvd as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(wbinvd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).io_delay as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(io_delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).cpuid as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(cpuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).read_msr as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(read_msr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).write_msr as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(write_msr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).read_msr_safe as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(read_msr_safe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).write_msr_safe as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(write_msr_safe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).read_pmc as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(read_pmc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).usergs_sysret64 as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(usergs_sysret64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).iret as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(iret)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).swapgs as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(swapgs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).start_context_switch as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(start_context_switch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).end_context_switch as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(end_context_switch)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pv_irq_ops {
    pub save_fl: paravirt_callee_save,
    pub restore_fl: paravirt_callee_save,
    pub irq_disable: paravirt_callee_save,
    pub irq_enable: paravirt_callee_save,
    pub safe_halt: ::std::option::Option<unsafe extern "C" fn()>,
    pub halt: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_pv_irq_ops() {
    assert_eq!(
        ::std::mem::size_of::<pv_irq_ops>(),
        48usize,
        concat!("Size of: ", stringify!(pv_irq_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<pv_irq_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(pv_irq_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_irq_ops>())).save_fl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_irq_ops),
            "::",
            stringify!(save_fl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_irq_ops>())).restore_fl as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_irq_ops),
            "::",
            stringify!(restore_fl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_irq_ops>())).irq_disable as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_irq_ops),
            "::",
            stringify!(irq_disable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_irq_ops>())).irq_enable as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_irq_ops),
            "::",
            stringify!(irq_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_irq_ops>())).safe_halt as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_irq_ops),
            "::",
            stringify!(safe_halt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_irq_ops>())).halt as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_irq_ops),
            "::",
            stringify!(halt)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pv_mmu_ops {
    pub read_cr2: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_ulong>,
    pub write_cr2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_ulong)>,
    pub read_cr3: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_ulong>,
    pub write_cr3: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_ulong)>,
    pub activate_mm:
        ::std::option::Option<unsafe extern "C" fn(prev: *mut mm_struct, next: *mut mm_struct)>,
    pub dup_mmap:
        ::std::option::Option<unsafe extern "C" fn(oldmm: *mut mm_struct, mm: *mut mm_struct)>,
    pub exit_mmap: ::std::option::Option<unsafe extern "C" fn(mm: *mut mm_struct)>,
    pub flush_tlb_user: ::std::option::Option<unsafe extern "C" fn()>,
    pub flush_tlb_kernel: ::std::option::Option<unsafe extern "C" fn()>,
    pub flush_tlb_one_user:
        ::std::option::Option<unsafe extern "C" fn(addr: ::std::os::raw::c_ulong)>,
    pub flush_tlb_others: ::std::option::Option<
        unsafe extern "C" fn(cpus: *const cpumask, info: *const flush_tlb_info),
    >,
    pub pgd_alloc:
        ::std::option::Option<unsafe extern "C" fn(mm: *mut mm_struct) -> ::std::os::raw::c_int>,
    pub pgd_free: ::std::option::Option<unsafe extern "C" fn(mm: *mut mm_struct, pgd: *mut pgd_t)>,
    pub alloc_pte: ::std::option::Option<
        unsafe extern "C" fn(mm: *mut mm_struct, pfn: ::std::os::raw::c_ulong),
    >,
    pub alloc_pmd: ::std::option::Option<
        unsafe extern "C" fn(mm: *mut mm_struct, pfn: ::std::os::raw::c_ulong),
    >,
    pub alloc_pud: ::std::option::Option<
        unsafe extern "C" fn(mm: *mut mm_struct, pfn: ::std::os::raw::c_ulong),
    >,
    pub alloc_p4d: ::std::option::Option<
        unsafe extern "C" fn(mm: *mut mm_struct, pfn: ::std::os::raw::c_ulong),
    >,
    pub release_pte: ::std::option::Option<unsafe extern "C" fn(pfn: ::std::os::raw::c_ulong)>,
    pub release_pmd: ::std::option::Option<unsafe extern "C" fn(pfn: ::std::os::raw::c_ulong)>,
    pub release_pud: ::std::option::Option<unsafe extern "C" fn(pfn: ::std::os::raw::c_ulong)>,
    pub release_p4d: ::std::option::Option<unsafe extern "C" fn(pfn: ::std::os::raw::c_ulong)>,
    pub set_pte: ::std::option::Option<unsafe extern "C" fn(ptep: *mut pte_t, pteval: pte_t)>,
    pub set_pte_at: ::std::option::Option<
        unsafe extern "C" fn(
            mm: *mut mm_struct,
            addr: ::std::os::raw::c_ulong,
            ptep: *mut pte_t,
            pteval: pte_t,
        ),
    >,
    pub set_pmd: ::std::option::Option<unsafe extern "C" fn(pmdp: *mut pmd_t, pmdval: pmd_t)>,
    pub ptep_modify_prot_start: ::std::option::Option<
        unsafe extern "C" fn(
            mm: *mut mm_struct,
            addr: ::std::os::raw::c_ulong,
            ptep: *mut pte_t,
        ) -> pte_t,
    >,
    pub ptep_modify_prot_commit: ::std::option::Option<
        unsafe extern "C" fn(
            mm: *mut mm_struct,
            addr: ::std::os::raw::c_ulong,
            ptep: *mut pte_t,
            pte: pte_t,
        ),
    >,
    pub pte_val: paravirt_callee_save,
    pub make_pte: paravirt_callee_save,
    pub pgd_val: paravirt_callee_save,
    pub make_pgd: paravirt_callee_save,
    pub set_pud: ::std::option::Option<unsafe extern "C" fn(pudp: *mut pud_t, pudval: pud_t)>,
    pub pmd_val: paravirt_callee_save,
    pub make_pmd: paravirt_callee_save,
    pub pud_val: paravirt_callee_save,
    pub make_pud: paravirt_callee_save,
    pub set_p4d: ::std::option::Option<unsafe extern "C" fn(p4dp: *mut p4d_t, p4dval: p4d_t)>,
    pub lazy_mode: pv_lazy_ops,
    pub set_fixmap: ::std::option::Option<
        unsafe extern "C" fn(idx: ::std::os::raw::c_uint, phys: phys_addr_t, flags: pgprot_t),
    >,
}
#[test]
fn bindgen_test_layout_pv_mmu_ops() {
    assert_eq!(
        ::std::mem::size_of::<pv_mmu_ops>(),
        320usize,
        concat!("Size of: ", stringify!(pv_mmu_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<pv_mmu_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(pv_mmu_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).read_cr2 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(read_cr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).write_cr2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(write_cr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).read_cr3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(read_cr3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).write_cr3 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(write_cr3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).activate_mm as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(activate_mm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).dup_mmap as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(dup_mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).exit_mmap as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(exit_mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).flush_tlb_user as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(flush_tlb_user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).flush_tlb_kernel as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(flush_tlb_kernel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).flush_tlb_one_user as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(flush_tlb_one_user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).flush_tlb_others as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(flush_tlb_others)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).pgd_alloc as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(pgd_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).pgd_free as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(pgd_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).alloc_pte as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(alloc_pte)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).alloc_pmd as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(alloc_pmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).alloc_pud as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(alloc_pud)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).alloc_p4d as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(alloc_p4d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).release_pte as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(release_pte)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).release_pmd as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(release_pmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).release_pud as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(release_pud)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).release_p4d as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(release_p4d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).set_pte as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(set_pte)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).set_pte_at as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(set_pte_at)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).set_pmd as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(set_pmd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pv_mmu_ops>())).ptep_modify_prot_start as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(ptep_modify_prot_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pv_mmu_ops>())).ptep_modify_prot_commit as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(ptep_modify_prot_commit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).pte_val as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(pte_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).make_pte as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(make_pte)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).pgd_val as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(pgd_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).make_pgd as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(make_pgd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).set_pud as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(set_pud)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).pmd_val as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(pmd_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).make_pmd as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(make_pmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).pud_val as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(pud_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).make_pud as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(make_pud)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).set_p4d as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(set_p4d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).lazy_mode as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(lazy_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).set_fixmap as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(set_fixmap)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct arch_spinlock {
    _unused: [u8; 0],
}
pub type __ticket_t = u16;
pub type __ticketpair_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qspinlock {
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qspinlock__bindgen_ty_1 {
    pub val: atomic_t,
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: qspinlock__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_1 {
    pub locked: u8,
    pub pending: u8,
}
#[test]
fn bindgen_test_layout_qspinlock__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<qspinlock__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<qspinlock__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_1>())).locked as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(locked)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_1>())).pending as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pending)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_2 {
    pub locked_pending: u16,
    pub tail: u16,
}
#[test]
fn bindgen_test_layout_qspinlock__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<qspinlock__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<qspinlock__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_2>())).locked_pending
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(locked_pending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_2>())).tail as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(tail)
        )
    );
}
#[test]
fn bindgen_test_layout_qspinlock__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<qspinlock__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(qspinlock__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<qspinlock__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(qspinlock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qspinlock__bindgen_ty_1>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
}
#[test]
fn bindgen_test_layout_qspinlock() {
    assert_eq!(
        ::std::mem::size_of::<qspinlock>(),
        4usize,
        concat!("Size of: ", stringify!(qspinlock))
    );
    assert_eq!(
        ::std::mem::align_of::<qspinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(qspinlock))
    );
}
pub type arch_spinlock_t = qspinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qrwlock {
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1,
    pub wait_lock: arch_spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qrwlock__bindgen_ty_1 {
    pub cnts: atomic_t,
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qrwlock__bindgen_ty_1__bindgen_ty_1 {
    pub wlocked: u8,
    pub __lstate: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_qrwlock__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<qrwlock__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<qrwlock__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qrwlock__bindgen_ty_1__bindgen_ty_1>())).wlocked as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(wlocked)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qrwlock__bindgen_ty_1__bindgen_ty_1>())).__lstate as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__lstate)
        )
    );
}
#[test]
fn bindgen_test_layout_qrwlock__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<qrwlock__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(qrwlock__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<qrwlock__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(qrwlock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qrwlock__bindgen_ty_1>())).cnts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qrwlock__bindgen_ty_1),
            "::",
            stringify!(cnts)
        )
    );
}
#[test]
fn bindgen_test_layout_qrwlock() {
    assert_eq!(
        ::std::mem::size_of::<qrwlock>(),
        8usize,
        concat!("Size of: ", stringify!(qrwlock))
    );
    assert_eq!(
        ::std::mem::align_of::<qrwlock>(),
        4usize,
        concat!("Alignment of ", stringify!(qrwlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qrwlock>())).wait_lock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(qrwlock),
            "::",
            stringify!(wait_lock)
        )
    );
}
pub type arch_rwlock_t = qrwlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pv_lock_ops {
    pub queued_spin_lock_slowpath:
        ::std::option::Option<unsafe extern "C" fn(lock: *mut qspinlock, val: u32)>,
    pub queued_spin_unlock: paravirt_callee_save,
    pub wait: ::std::option::Option<unsafe extern "C" fn(ptr: *mut u8, val: u8)>,
    pub kick: ::std::option::Option<unsafe extern "C" fn(cpu: ::std::os::raw::c_int)>,
    pub vcpu_is_preempted: paravirt_callee_save,
}
#[test]
fn bindgen_test_layout_pv_lock_ops() {
    assert_eq!(
        ::std::mem::size_of::<pv_lock_ops>(),
        40usize,
        concat!("Size of: ", stringify!(pv_lock_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<pv_lock_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(pv_lock_ops))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pv_lock_ops>())).queued_spin_lock_slowpath as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_lock_ops),
            "::",
            stringify!(queued_spin_lock_slowpath)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_lock_ops>())).queued_spin_unlock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_lock_ops),
            "::",
            stringify!(queued_spin_unlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_lock_ops>())).wait as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_lock_ops),
            "::",
            stringify!(wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_lock_ops>())).kick as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_lock_ops),
            "::",
            stringify!(kick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_lock_ops>())).vcpu_is_preempted as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_lock_ops),
            "::",
            stringify!(vcpu_is_preempted)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct paravirt_patch_template {
    pub pv_init_ops: pv_init_ops,
    pub pv_time_ops: pv_time_ops,
    pub pv_cpu_ops: pv_cpu_ops,
    pub pv_irq_ops: pv_irq_ops,
    pub pv_mmu_ops: pv_mmu_ops,
    pub pv_lock_ops: pv_lock_ops,
}
#[test]
fn bindgen_test_layout_paravirt_patch_template() {
    assert_eq!(
        ::std::mem::size_of::<paravirt_patch_template>(),
        704usize,
        concat!("Size of: ", stringify!(paravirt_patch_template))
    );
    assert_eq!(
        ::std::mem::align_of::<paravirt_patch_template>(),
        8usize,
        concat!("Alignment of ", stringify!(paravirt_patch_template))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<paravirt_patch_template>())).pv_init_ops as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_patch_template),
            "::",
            stringify!(pv_init_ops)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<paravirt_patch_template>())).pv_time_ops as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_patch_template),
            "::",
            stringify!(pv_time_ops)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<paravirt_patch_template>())).pv_cpu_ops as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_patch_template),
            "::",
            stringify!(pv_cpu_ops)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<paravirt_patch_template>())).pv_irq_ops as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_patch_template),
            "::",
            stringify!(pv_irq_ops)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<paravirt_patch_template>())).pv_mmu_ops as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_patch_template),
            "::",
            stringify!(pv_mmu_ops)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<paravirt_patch_template>())).pv_lock_ops as *const _ as usize
        },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_patch_template),
            "::",
            stringify!(pv_lock_ops)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}pv_info"]
    pub static mut pv_info: pv_info;
}
extern "C" {
    #[link_name = "\u{1}pv_init_ops"]
    pub static mut pv_init_ops: pv_init_ops;
}
extern "C" {
    #[link_name = "\u{1}pv_time_ops"]
    pub static mut pv_time_ops: pv_time_ops;
}
extern "C" {
    #[link_name = "\u{1}pv_cpu_ops"]
    pub static mut pv_cpu_ops: pv_cpu_ops;
}
extern "C" {
    #[link_name = "\u{1}pv_irq_ops"]
    pub static mut pv_irq_ops: pv_irq_ops;
}
extern "C" {
    #[link_name = "\u{1}pv_mmu_ops"]
    pub static mut pv_mmu_ops: pv_mmu_ops;
}
extern "C" {
    #[link_name = "\u{1}pv_lock_ops"]
    pub static mut pv_lock_ops: pv_lock_ops;
}
extern "C" {
    pub fn paravirt_patch_ident_32(
        insnbuf: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn paravirt_patch_ident_64(
        insnbuf: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn paravirt_patch_call(
        insnbuf: *mut ::std::os::raw::c_void,
        target: *const ::std::os::raw::c_void,
        tgt_clobbers: u16,
        addr: ::std::os::raw::c_ulong,
        site_clobbers: u16,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn paravirt_patch_jmp(
        insnbuf: *mut ::std::os::raw::c_void,
        target: *const ::std::os::raw::c_void,
        addr: ::std::os::raw::c_ulong,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn paravirt_patch_default(
        type_: u8,
        clobbers: u16,
        insnbuf: *mut ::std::os::raw::c_void,
        addr: ::std::os::raw::c_ulong,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn paravirt_patch_insns(
        insnbuf: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_uint,
        start: *const ::std::os::raw::c_char,
        end: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn native_patch(
        type_: u8,
        clobbers: u16,
        ibuf: *mut ::std::os::raw::c_void,
        addr: ::std::os::raw::c_ulong,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn paravirt_disable_iospace() -> ::std::os::raw::c_int;
}
pub const paravirt_lazy_mode_PARAVIRT_LAZY_NONE: paravirt_lazy_mode = 0;
pub const paravirt_lazy_mode_PARAVIRT_LAZY_MMU: paravirt_lazy_mode = 1;
pub const paravirt_lazy_mode_PARAVIRT_LAZY_CPU: paravirt_lazy_mode = 2;
pub type paravirt_lazy_mode = u32;
extern "C" {
    pub fn paravirt_get_lazy_mode() -> paravirt_lazy_mode;
}
extern "C" {
    pub fn paravirt_start_context_switch(prev: *mut task_struct);
}
extern "C" {
    pub fn paravirt_end_context_switch(next: *mut task_struct);
}
extern "C" {
    pub fn paravirt_enter_lazy_mmu();
}
extern "C" {
    pub fn paravirt_leave_lazy_mmu();
}
extern "C" {
    pub fn paravirt_flush_lazy_mmu();
}
extern "C" {
    pub fn _paravirt_nop();
}
extern "C" {
    pub fn _paravirt_ident_32(arg1: u32) -> u32;
}
extern "C" {
    pub fn _paravirt_ident_64(arg1: __u64) -> __u64;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct paravirt_patch_site {
    pub instr: *mut u8,
    pub instrtype: u8,
    pub len: u8,
    pub clobbers: u16,
}
#[test]
fn bindgen_test_layout_paravirt_patch_site() {
    assert_eq!(
        ::std::mem::size_of::<paravirt_patch_site>(),
        16usize,
        concat!("Size of: ", stringify!(paravirt_patch_site))
    );
    assert_eq!(
        ::std::mem::align_of::<paravirt_patch_site>(),
        8usize,
        concat!("Alignment of ", stringify!(paravirt_patch_site))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paravirt_patch_site>())).instr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_patch_site),
            "::",
            stringify!(instr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paravirt_patch_site>())).instrtype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_patch_site),
            "::",
            stringify!(instrtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paravirt_patch_site>())).len as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_patch_site),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paravirt_patch_site>())).clobbers as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_patch_site),
            "::",
            stringify!(clobbers)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__parainstructions"]
    pub static mut __parainstructions: [paravirt_patch_site; 0usize];
}
extern "C" {
    #[link_name = "\u{1}__parainstructions_end"]
    pub static mut __parainstructions_end: [paravirt_patch_site; 0usize];
}
extern "C" {
    pub fn profile_pc(regs: *mut pt_regs) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn convert_ip_to_linear(
        child: *mut task_struct,
        regs: *mut pt_regs,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn send_sigtrap(
        tsk: *mut task_struct,
        regs: *mut pt_regs,
        error_code: ::std::os::raw::c_int,
        si_code: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn regs_query_register_offset(name: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn regs_query_register_name(
        offset: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn probe_kernel_read(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        size: usize,
    ) -> ::std::os::raw::c_long;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_desc {
    _unused: [u8; 0],
}
extern "C" {
    pub fn do_get_thread_area(
        p: *mut task_struct,
        idx: ::std::os::raw::c_int,
        info: *mut user_desc,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_set_thread_area(
        p: *mut task_struct,
        idx: ::std::os::raw::c_int,
        info: *mut user_desc,
        can_allocate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct math_emu_info {
    pub ___orig_eip: ::std::os::raw::c_long,
    pub regs: *mut pt_regs,
}
#[test]
fn bindgen_test_layout_math_emu_info() {
    assert_eq!(
        ::std::mem::size_of::<math_emu_info>(),
        16usize,
        concat!("Size of: ", stringify!(math_emu_info))
    );
    assert_eq!(
        ::std::mem::align_of::<math_emu_info>(),
        8usize,
        concat!("Alignment of ", stringify!(math_emu_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<math_emu_info>())).___orig_eip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(math_emu_info),
            "::",
            stringify!(___orig_eip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<math_emu_info>())).regs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(math_emu_info),
            "::",
            stringify!(regs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _fpx_sw_bytes {
    pub magic1: __u32,
    pub extended_size: __u32,
    pub xfeatures: __u64,
    pub xstate_size: __u32,
    pub padding: [__u32; 7usize],
}
#[test]
fn bindgen_test_layout__fpx_sw_bytes() {
    assert_eq!(
        ::std::mem::size_of::<_fpx_sw_bytes>(),
        48usize,
        concat!("Size of: ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpx_sw_bytes>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).magic1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(magic1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).extended_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(extended_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).xfeatures as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xfeatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).xstate_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xstate_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).padding as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _fpreg {
    pub significand: [__u16; 4usize],
    pub exponent: __u16,
}
#[test]
fn bindgen_test_layout__fpreg() {
    assert_eq!(
        ::std::mem::size_of::<_fpreg>(),
        10usize,
        concat!("Size of: ", stringify!(_fpreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(exponent)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _fpxreg {
    pub significand: [__u16; 4usize],
    pub exponent: __u16,
    pub padding: [__u16; 3usize],
}
#[test]
fn bindgen_test_layout__fpxreg() {
    assert_eq!(
        ::std::mem::size_of::<_fpxreg>(),
        16usize,
        concat!("Size of: ", stringify!(_fpxreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpxreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpxreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).padding as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _xmmreg {
    pub element: [__u32; 4usize],
}
#[test]
fn bindgen_test_layout__xmmreg() {
    assert_eq!(
        ::std::mem::size_of::<_xmmreg>(),
        16usize,
        concat!("Size of: ", stringify!(_xmmreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmmreg>(),
        4usize,
        concat!("Alignment of ", stringify!(_xmmreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xmmreg>())).element as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xmmreg),
            "::",
            stringify!(element)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _fpstate_32 {
    pub cw: __u32,
    pub sw: __u32,
    pub tag: __u32,
    pub ipoff: __u32,
    pub cssel: __u32,
    pub dataoff: __u32,
    pub datasel: __u32,
    pub _st: [_fpreg; 8usize],
    pub status: __u16,
    pub magic: __u16,
    pub _fxsr_env: [__u32; 6usize],
    pub mxcsr: __u32,
    pub reserved: __u32,
    pub _fxsr_st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 8usize],
    pub __bindgen_anon_1: _fpstate_32__bindgen_ty_1,
    pub __bindgen_anon_2: _fpstate_32__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _fpstate_32__bindgen_ty_1 {
    pub padding1: [__u32; 44usize],
    pub padding: [__u32; 44usize],
    _bindgen_union_align: [u32; 44usize],
}
#[test]
fn bindgen_test_layout__fpstate_32__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate_32__bindgen_ty_1>(),
        176usize,
        concat!("Size of: ", stringify!(_fpstate_32__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate_32__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_fpstate_32__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_fpstate_32__bindgen_ty_1>())).padding1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32__bindgen_ty_1),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_fpstate_32__bindgen_ty_1>())).padding as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32__bindgen_ty_1),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _fpstate_32__bindgen_ty_2 {
    pub padding2: [__u32; 12usize],
    pub sw_reserved: _fpx_sw_bytes,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout__fpstate_32__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate_32__bindgen_ty_2>(),
        48usize,
        concat!("Size of: ", stringify!(_fpstate_32__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate_32__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpstate_32__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_fpstate_32__bindgen_ty_2>())).padding2 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32__bindgen_ty_2),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_fpstate_32__bindgen_ty_2>())).sw_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32__bindgen_ty_2),
            "::",
            stringify!(sw_reserved)
        )
    );
}
#[test]
fn bindgen_test_layout__fpstate_32() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate_32>(),
        624usize,
        concat!("Size of: ", stringify!(_fpstate_32))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate_32>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpstate_32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).cw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(cw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).sw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(sw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).tag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).ipoff as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(ipoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).cssel as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(cssel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).dataoff as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(dataoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).datasel as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(datasel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>()))._st as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).status as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).magic as *const _ as usize },
        110usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>()))._fxsr_env as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(_fxsr_env)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).mxcsr as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).reserved as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>()))._fxsr_st as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(_fxsr_st)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>()))._xmm as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(_xmm)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _fpstate_64 {
    pub cwd: __u16,
    pub swd: __u16,
    pub twd: __u16,
    pub fop: __u16,
    pub rip: __u64,
    pub rdp: __u64,
    pub mxcsr: __u32,
    pub mxcsr_mask: __u32,
    pub st_space: [__u32; 32usize],
    pub xmm_space: [__u32; 64usize],
    pub reserved2: [__u32; 12usize],
    pub __bindgen_anon_1: _fpstate_64__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _fpstate_64__bindgen_ty_1 {
    pub reserved3: [__u32; 12usize],
    pub sw_reserved: _fpx_sw_bytes,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout__fpstate_64__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate_64__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(_fpstate_64__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate_64__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpstate_64__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_fpstate_64__bindgen_ty_1>())).reserved3 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64__bindgen_ty_1),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_fpstate_64__bindgen_ty_1>())).sw_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64__bindgen_ty_1),
            "::",
            stringify!(sw_reserved)
        )
    );
}
#[test]
fn bindgen_test_layout__fpstate_64() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate_64>(),
        512usize,
        concat!("Size of: ", stringify!(_fpstate_64))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate_64>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpstate_64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).twd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(twd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).rip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).rdp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).mxcsr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(mxcsr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).st_space as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(st_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).xmm_space as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(xmm_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).reserved2 as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _header {
    pub xfeatures: __u64,
    pub reserved1: [__u64; 2usize],
    pub reserved2: [__u64; 5usize],
}
#[test]
fn bindgen_test_layout__header() {
    assert_eq!(
        ::std::mem::size_of::<_header>(),
        64usize,
        concat!("Size of: ", stringify!(_header))
    );
    assert_eq!(
        ::std::mem::align_of::<_header>(),
        8usize,
        concat!("Alignment of ", stringify!(_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header>())).xfeatures as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_header),
            "::",
            stringify!(xfeatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header>())).reserved1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_header),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header>())).reserved2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_header),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ymmh_state {
    pub ymmh_space: [__u32; 64usize],
}
#[test]
fn bindgen_test_layout__ymmh_state() {
    assert_eq!(
        ::std::mem::size_of::<_ymmh_state>(),
        256usize,
        concat!("Size of: ", stringify!(_ymmh_state))
    );
    assert_eq!(
        ::std::mem::align_of::<_ymmh_state>(),
        4usize,
        concat!("Alignment of ", stringify!(_ymmh_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ymmh_state>())).ymmh_space as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ymmh_state),
            "::",
            stringify!(ymmh_space)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _xstate {
    pub fpstate: _fpstate_64,
    pub xstate_hdr: _header,
    pub ymmh: _ymmh_state,
}
#[test]
fn bindgen_test_layout__xstate() {
    assert_eq!(
        ::std::mem::size_of::<_xstate>(),
        832usize,
        concat!("Size of: ", stringify!(_xstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_xstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_xstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).fpstate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).xstate_hdr as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(xstate_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).ymmh as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(ymmh)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigcontext_32 {
    pub gs: __u16,
    pub __gsh: __u16,
    pub fs: __u16,
    pub __fsh: __u16,
    pub es: __u16,
    pub __esh: __u16,
    pub ds: __u16,
    pub __dsh: __u16,
    pub di: __u32,
    pub si: __u32,
    pub bp: __u32,
    pub sp: __u32,
    pub bx: __u32,
    pub dx: __u32,
    pub cx: __u32,
    pub ax: __u32,
    pub trapno: __u32,
    pub err: __u32,
    pub ip: __u32,
    pub cs: __u16,
    pub __csh: __u16,
    pub flags: __u32,
    pub sp_at_signal: __u32,
    pub ss: __u16,
    pub __ssh: __u16,
    pub fpstate: __u32,
    pub oldmask: __u32,
    pub cr2: __u32,
}
#[test]
fn bindgen_test_layout_sigcontext_32() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext_32>(),
        88usize,
        concat!("Size of: ", stringify!(sigcontext_32))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext_32>(),
        4usize,
        concat!("Alignment of ", stringify!(sigcontext_32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).gs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(gs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).__gsh as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(__gsh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).fs as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).__fsh as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(__fsh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).es as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).__esh as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(__esh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).ds as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).__dsh as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(__dsh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).di as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(di)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).si as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(si)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).bp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(bp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).sp as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).bx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(bx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).dx as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).cx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).ax as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(ax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).trapno as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(trapno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).err as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).ip as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).cs as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).__csh as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(__csh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).flags as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).sp_at_signal as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(sp_at_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).ss as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).__ssh as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(__ssh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).fpstate as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).oldmask as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(oldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).cr2 as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(cr2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigcontext_64 {
    pub r8: __u64,
    pub r9: __u64,
    pub r10: __u64,
    pub r11: __u64,
    pub r12: __u64,
    pub r13: __u64,
    pub r14: __u64,
    pub r15: __u64,
    pub di: __u64,
    pub si: __u64,
    pub bp: __u64,
    pub bx: __u64,
    pub dx: __u64,
    pub ax: __u64,
    pub cx: __u64,
    pub sp: __u64,
    pub ip: __u64,
    pub flags: __u64,
    pub cs: __u16,
    pub gs: __u16,
    pub fs: __u16,
    pub ss: __u16,
    pub err: __u64,
    pub trapno: __u64,
    pub oldmask: __u64,
    pub cr2: __u64,
    pub fpstate: __u64,
    pub reserved1: [__u64; 8usize],
}
#[test]
fn bindgen_test_layout_sigcontext_64() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext_64>(),
        256usize,
        concat!("Size of: ", stringify!(sigcontext_64))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext_64>(),
        8usize,
        concat!("Alignment of ", stringify!(sigcontext_64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r9 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r10 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r11 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r12 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r13 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r14 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r15 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).di as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(di)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).si as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(si)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).bp as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(bp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).bx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(bx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).dx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).ax as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(ax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).cx as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).sp as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).ip as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).flags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).cs as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).gs as *const _ as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(gs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).fs as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).ss as *const _ as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).err as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).trapno as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(trapno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).oldmask as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(oldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).cr2 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(cr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).fpstate as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).reserved1 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(reserved1)
        )
    );
}
extern "C" {
    pub fn strndup_user(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memdup_user(
        arg1: *const ::std::os::raw::c_void,
        arg2: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memdup_user_nul(
        arg1: *const ::std::os::raw::c_void,
        arg2: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcpy(
        to: *mut ::std::os::raw::c_void,
        from: *const ::std::os::raw::c_void,
        len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __memcpy(
        to: *mut ::std::os::raw::c_void,
        from: *const ::std::os::raw::c_void,
        len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        s: *mut ::std::os::raw::c_void,
        c: ::std::os::raw::c_int,
        n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __memset(
        s: *mut ::std::os::raw::c_void,
        c: ::std::os::raw::c_int,
        n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        dest: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __memmove(
        dest: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        cs: *const ::std::os::raw::c_void,
        ct: *const ::std::os::raw::c_void,
        count: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlen(s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcpy(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        cs: *const ::std::os::raw::c_char,
        ct: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy_mcsafe_unrolled(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        cnt: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}mcsafe_key"]
    pub static mut mcsafe_key: static_key_false;
}
extern "C" {
    pub fn memcpy_flushcache(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        cnt: usize,
    );
}
extern "C" {
    pub fn strncpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __kernel_size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> usize;
}
extern "C" {
    pub fn strscpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> isize;
}
extern "C" {
    pub fn strscpy_pad(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        count: usize,
    ) -> isize;
}
extern "C" {
    pub fn strncat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __kernel_size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __kernel_size_t,
    ) -> usize;
}
extern "C" {
    pub fn strncmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __kernel_size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
        n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchrnul(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn skip_spaces(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strim(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(arg1: *const ::std::os::raw::c_char, arg2: __kernel_size_t) -> __kernel_size_t;
}
extern "C" {
    pub fn strpbrk(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn memscan(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: __kernel_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: __kernel_size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: __kernel_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memchr_inv(
        s: *const ::std::os::raw::c_void,
        c: ::std::os::raw::c_int,
        n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strreplace(
        s: *mut ::std::os::raw::c_char,
        old: ::std::os::raw::c_char,
        new: ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn kfree_const(x: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn kstrdup(s: *const ::std::os::raw::c_char, gfp: gfp_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn kstrdup_const(
        s: *const ::std::os::raw::c_char,
        gfp: gfp_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn kstrndup(
        s: *const ::std::os::raw::c_char,
        len: usize,
        gfp: gfp_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn kmemdup(
        src: *const ::std::os::raw::c_void,
        len: usize,
        gfp: gfp_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmemdup_nul(
        s: *const ::std::os::raw::c_char,
        len: usize,
        gfp: gfp_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn argv_split(
        gfp: gfp_t,
        str: *const ::std::os::raw::c_char,
        argcp: *mut ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn argv_free(argv: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn sysfs_streq(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
    ) -> bool_;
}
extern "C" {
    pub fn match_string(
        array: *const *const ::std::os::raw::c_char,
        n: usize,
        string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sysfs_match_string(
        array: *const *const ::std::os::raw::c_char,
        n: usize,
        s: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vbin_printf(
        bin_buf: *mut u32,
        size: usize,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bstr_printf(
        buf: *mut ::std::os::raw::c_char,
        size: usize,
        fmt: *const ::std::os::raw::c_char,
        bin_buf: *const u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bprintf(
        bin_buf: *mut u32,
        size: usize,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memory_read_from_buffer(
        to: *mut ::std::os::raw::c_void,
        count: usize,
        ppos: *mut loff_t,
        from: *const ::std::os::raw::c_void,
        available: usize,
    ) -> isize;
}
extern "C" {
    pub fn memory_read_from_io_buffer(
        to: *mut ::std::os::raw::c_void,
        count: usize,
        ppos: *mut loff_t,
        from: *const ::std::os::raw::c_void,
        available: usize,
    ) -> isize;
}
extern "C" {
    pub fn memweight(ptr: *const ::std::os::raw::c_void, bytes: usize) -> usize;
}
extern "C" {
    pub fn memzero_explicit(s: *mut ::std::os::raw::c_void, count: usize);
}
extern "C" {
    pub fn fortify_panic(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __read_overflow();
}
extern "C" {
    pub fn __read_overflow2();
}
extern "C" {
    pub fn __read_overflow3();
}
extern "C" {
    pub fn __write_overflow();
}
extern "C" {
    #[doc = " DOC: declare bitmap"]
    #[doc = " The DECLARE_BITMAP(name,bits) macro, in linux/types.h, can be used"]
    #[doc = " to declare an array named 'name' of just enough unsigned longs to"]
    #[doc = " contain all bit positions from 0 to 'bits' - 1."]
    pub fn bitmap_alloc(
        nbits: ::std::os::raw::c_uint,
        flags: gfp_t,
    ) -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn bitmap_zalloc(
        nbits: ::std::os::raw::c_uint,
        flags: gfp_t,
    ) -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn bitmap_free(bitmap: *const ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __bitmap_empty(
        bitmap: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __bitmap_full(
        bitmap: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __bitmap_equal(
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __bitmap_complement(
        dst: *mut ::std::os::raw::c_ulong,
        src: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_shift_right(
        dst: *mut ::std::os::raw::c_ulong,
        src: *const ::std::os::raw::c_ulong,
        shift: ::std::os::raw::c_uint,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_shift_left(
        dst: *mut ::std::os::raw::c_ulong,
        src: *const ::std::os::raw::c_ulong,
        shift: ::std::os::raw::c_uint,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_and(
        dst: *mut ::std::os::raw::c_ulong,
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __bitmap_or(
        dst: *mut ::std::os::raw::c_ulong,
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_xor(
        dst: *mut ::std::os::raw::c_ulong,
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_andnot(
        dst: *mut ::std::os::raw::c_ulong,
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __bitmap_intersects(
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __bitmap_subset(
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __bitmap_weight(
        bitmap: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __bitmap_set(
        map: *mut ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn __bitmap_clear(
        map: *mut ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn bitmap_find_next_zero_area_off(
        map: *mut ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_ulong,
        nr: ::std::os::raw::c_uint,
        align_mask: ::std::os::raw::c_ulong,
        align_offset: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __bitmap_parse(
        buf: *const ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_uint,
        is_user: ::std::os::raw::c_int,
        dst: *mut ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_parse_user(
        ubuf: *const ::std::os::raw::c_char,
        ulen: ::std::os::raw::c_uint,
        dst: *mut ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_parselist(
        buf: *const ::std::os::raw::c_char,
        maskp: *mut ::std::os::raw::c_ulong,
        nmaskbits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_parselist_user(
        ubuf: *const ::std::os::raw::c_char,
        ulen: ::std::os::raw::c_uint,
        dst: *mut ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_remap(
        dst: *mut ::std::os::raw::c_ulong,
        src: *const ::std::os::raw::c_ulong,
        old: *const ::std::os::raw::c_ulong,
        new: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn bitmap_bitremap(
        oldbit: ::std::os::raw::c_int,
        old: *const ::std::os::raw::c_ulong,
        new: *const ::std::os::raw::c_ulong,
        bits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_onto(
        dst: *mut ::std::os::raw::c_ulong,
        orig: *const ::std::os::raw::c_ulong,
        relmap: *const ::std::os::raw::c_ulong,
        bits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn bitmap_fold(
        dst: *mut ::std::os::raw::c_ulong,
        orig: *const ::std::os::raw::c_ulong,
        sz: ::std::os::raw::c_uint,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn bitmap_find_free_region(
        bitmap: *mut ::std::os::raw::c_ulong,
        bits: ::std::os::raw::c_uint,
        order: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_release_region(
        bitmap: *mut ::std::os::raw::c_ulong,
        pos: ::std::os::raw::c_uint,
        order: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn bitmap_allocate_region(
        bitmap: *mut ::std::os::raw::c_ulong,
        pos: ::std::os::raw::c_uint,
        order: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_from_u32array(
        bitmap: *mut ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
        buf: *const u32,
        nwords: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn bitmap_to_u32array(
        buf: *mut u32,
        nwords: ::std::os::raw::c_uint,
        bitmap: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn bitmap_ord_to_pos(
        bitmap: *const ::std::os::raw::c_ulong,
        ord: ::std::os::raw::c_uint,
        nbits: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn bitmap_print_to_pagebuf(
        list: bool_,
        buf: *mut ::std::os::raw::c_char,
        maskp: *const ::std::os::raw::c_ulong,
        nmaskbits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpumask {
    pub bits: [::std::os::raw::c_ulong; 128usize],
}
#[test]
fn bindgen_test_layout_cpumask() {
    assert_eq!(
        ::std::mem::size_of::<cpumask>(),
        1024usize,
        concat!("Size of: ", stringify!(cpumask))
    );
    assert_eq!(
        ::std::mem::align_of::<cpumask>(),
        8usize,
        concat!("Alignment of ", stringify!(cpumask))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpumask>())).bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpumask),
            "::",
            stringify!(bits)
        )
    );
}
pub type cpumask_t = cpumask;
extern "C" {
    #[link_name = "\u{1}nr_cpu_ids"]
    pub static mut nr_cpu_ids: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}__cpu_possible_mask"]
    pub static mut __cpu_possible_mask: cpumask;
}
extern "C" {
    #[link_name = "\u{1}__cpu_online_mask"]
    pub static mut __cpu_online_mask: cpumask;
}
extern "C" {
    #[link_name = "\u{1}__cpu_present_mask"]
    pub static mut __cpu_present_mask: cpumask;
}
extern "C" {
    #[link_name = "\u{1}__cpu_active_mask"]
    pub static mut __cpu_active_mask: cpumask;
}
extern "C" {
    pub fn cpumask_next(n: ::std::os::raw::c_int, srcp: *const cpumask) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn cpumask_next_and(
        n: ::std::os::raw::c_int,
        arg1: *const cpumask,
        arg2: *const cpumask,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cpumask_any_but(
        mask: *const cpumask,
        cpu: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cpumask_local_spread(
        i: ::std::os::raw::c_uint,
        node: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn cpumask_next_wrap(
        n: ::std::os::raw::c_int,
        mask: *const cpumask,
        start: ::std::os::raw::c_int,
        wrap: bool_,
    ) -> ::std::os::raw::c_int;
}
pub type cpumask_var_t = *mut cpumask;
extern "C" {
    pub fn alloc_cpumask_var_node(
        mask: *mut cpumask_var_t,
        flags: gfp_t,
        node: ::std::os::raw::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn alloc_cpumask_var(mask: *mut cpumask_var_t, flags: gfp_t) -> bool_;
}
extern "C" {
    pub fn zalloc_cpumask_var_node(
        mask: *mut cpumask_var_t,
        flags: gfp_t,
        node: ::std::os::raw::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn zalloc_cpumask_var(mask: *mut cpumask_var_t, flags: gfp_t) -> bool_;
}
extern "C" {
    pub fn alloc_bootmem_cpumask_var(mask: *mut cpumask_var_t);
}
extern "C" {
    pub fn free_cpumask_var(mask: cpumask_var_t);
}
extern "C" {
    pub fn free_bootmem_cpumask_var(mask: cpumask_var_t);
}
extern "C" {
    #[link_name = "\u{1}cpu_all_bits"]
    pub static mut cpu_all_bits: [::std::os::raw::c_ulong; 128usize];
}
extern "C" {
    pub fn init_cpu_present(src: *const cpumask);
}
extern "C" {
    pub fn init_cpu_possible(src: *const cpumask);
}
extern "C" {
    pub fn init_cpu_online(src: *const cpumask);
}
extern "C" {
    #[link_name = "\u{1}cpu_bit_bitmap"]
    pub static mut cpu_bit_bitmap: [[::std::os::raw::c_ulong; 128usize]; 65usize];
}
extern "C" {
    #[link_name = "\u{1}cpu_callin_mask"]
    pub static mut cpu_callin_mask: cpumask_var_t;
}
extern "C" {
    #[link_name = "\u{1}cpu_callout_mask"]
    pub static mut cpu_callout_mask: cpumask_var_t;
}
extern "C" {
    #[link_name = "\u{1}cpu_initialized_mask"]
    pub static mut cpu_initialized_mask: cpumask_var_t;
}
extern "C" {
    #[link_name = "\u{1}cpu_sibling_setup_mask"]
    pub static mut cpu_sibling_setup_mask: cpumask_var_t;
}
extern "C" {
    pub fn setup_cpu_local_masks();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msr {
    pub __bindgen_anon_1: msr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union msr__bindgen_ty_1 {
    pub __bindgen_anon_1: msr__bindgen_ty_1__bindgen_ty_1,
    pub q: __u64,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msr__bindgen_ty_1__bindgen_ty_1 {
    pub l: u32,
    pub h: u32,
}
#[test]
fn bindgen_test_layout_msr__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<msr__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(msr__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<msr__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(msr__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<msr__bindgen_ty_1__bindgen_ty_1>())).l as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<msr__bindgen_ty_1__bindgen_ty_1>())).h as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(msr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(h)
        )
    );
}
#[test]
fn bindgen_test_layout_msr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<msr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(msr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<msr__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(msr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msr__bindgen_ty_1>())).q as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msr__bindgen_ty_1),
            "::",
            stringify!(q)
        )
    );
}
#[test]
fn bindgen_test_layout_msr() {
    assert_eq!(
        ::std::mem::size_of::<msr>(),
        8usize,
        concat!("Size of: ", stringify!(msr))
    );
    assert_eq!(
        ::std::mem::align_of::<msr>(),
        8usize,
        concat!("Alignment of ", stringify!(msr))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msr_info {
    pub msr_no: u32,
    pub reg: msr,
    pub msrs: *mut msr,
    pub err: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msr_info() {
    assert_eq!(
        ::std::mem::size_of::<msr_info>(),
        32usize,
        concat!("Size of: ", stringify!(msr_info))
    );
    assert_eq!(
        ::std::mem::align_of::<msr_info>(),
        8usize,
        concat!("Alignment of ", stringify!(msr_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msr_info>())).msr_no as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msr_info),
            "::",
            stringify!(msr_no)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msr_info>())).reg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msr_info),
            "::",
            stringify!(reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msr_info>())).msrs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msr_info),
            "::",
            stringify!(msrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msr_info>())).err as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msr_info),
            "::",
            stringify!(err)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msr_regs_info {
    pub regs: *mut u32,
    pub err: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msr_regs_info() {
    assert_eq!(
        ::std::mem::size_of::<msr_regs_info>(),
        16usize,
        concat!("Size of: ", stringify!(msr_regs_info))
    );
    assert_eq!(
        ::std::mem::align_of::<msr_regs_info>(),
        8usize,
        concat!("Alignment of ", stringify!(msr_regs_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msr_regs_info>())).regs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msr_regs_info),
            "::",
            stringify!(regs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msr_regs_info>())).err as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msr_regs_info),
            "::",
            stringify!(err)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct saved_msr {
    pub valid: bool_,
    pub info: msr_info,
}
#[test]
fn bindgen_test_layout_saved_msr() {
    assert_eq!(
        ::std::mem::size_of::<saved_msr>(),
        40usize,
        concat!("Size of: ", stringify!(saved_msr))
    );
    assert_eq!(
        ::std::mem::align_of::<saved_msr>(),
        8usize,
        concat!("Alignment of ", stringify!(saved_msr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<saved_msr>())).valid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(saved_msr),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<saved_msr>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(saved_msr),
            "::",
            stringify!(info)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct saved_msrs {
    pub num: ::std::os::raw::c_uint,
    pub array: *mut saved_msr,
}
#[test]
fn bindgen_test_layout_saved_msrs() {
    assert_eq!(
        ::std::mem::size_of::<saved_msrs>(),
        16usize,
        concat!("Size of: ", stringify!(saved_msrs))
    );
    assert_eq!(
        ::std::mem::align_of::<saved_msrs>(),
        8usize,
        concat!("Alignment of ", stringify!(saved_msrs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<saved_msrs>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(saved_msrs),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<saved_msrs>())).array as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(saved_msrs),
            "::",
            stringify!(array)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct trace_print_flags {
    pub mask: ::std::os::raw::c_ulong,
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_trace_print_flags() {
    assert_eq!(
        ::std::mem::size_of::<trace_print_flags>(),
        16usize,
        concat!("Size of: ", stringify!(trace_print_flags))
    );
    assert_eq!(
        ::std::mem::align_of::<trace_print_flags>(),
        8usize,
        concat!("Alignment of ", stringify!(trace_print_flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trace_print_flags>())).mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(trace_print_flags),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trace_print_flags>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(trace_print_flags),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct trace_print_flags_u64 {
    pub mask: ::std::os::raw::c_ulonglong,
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_trace_print_flags_u64() {
    assert_eq!(
        ::std::mem::size_of::<trace_print_flags_u64>(),
        16usize,
        concat!("Size of: ", stringify!(trace_print_flags_u64))
    );
    assert_eq!(
        ::std::mem::align_of::<trace_print_flags_u64>(),
        8usize,
        concat!("Alignment of ", stringify!(trace_print_flags_u64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trace_print_flags_u64>())).mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(trace_print_flags_u64),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trace_print_flags_u64>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(trace_print_flags_u64),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tracepoint_func {
    pub func: *mut ::std::os::raw::c_void,
    pub data: *mut ::std::os::raw::c_void,
    pub prio: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tracepoint_func() {
    assert_eq!(
        ::std::mem::size_of::<tracepoint_func>(),
        24usize,
        concat!("Size of: ", stringify!(tracepoint_func))
    );
    assert_eq!(
        ::std::mem::align_of::<tracepoint_func>(),
        8usize,
        concat!("Alignment of ", stringify!(tracepoint_func))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint_func>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint_func),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint_func>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint_func),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint_func>())).prio as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint_func),
            "::",
            stringify!(prio)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tracepoint {
    pub name: *const ::std::os::raw::c_char,
    pub key: static_key,
    pub regfunc: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub unregfunc: ::std::option::Option<unsafe extern "C" fn()>,
    pub funcs: *mut tracepoint_func,
}
#[test]
fn bindgen_test_layout_tracepoint() {
    assert_eq!(
        ::std::mem::size_of::<tracepoint>(),
        40usize,
        concat!("Size of: ", stringify!(tracepoint))
    );
    assert_eq!(
        ::std::mem::align_of::<tracepoint>(),
        8usize,
        concat!("Alignment of ", stringify!(tracepoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint>())).regfunc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(regfunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint>())).unregfunc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(unregfunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint>())).funcs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(funcs)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__tracepoint_read_msr"]
    pub static mut __tracepoint_read_msr: tracepoint;
}
extern "C" {
    #[link_name = "\u{1}__tracepoint_write_msr"]
    pub static mut __tracepoint_write_msr: tracepoint;
}
extern "C" {
    #[link_name = "\u{1}__tracepoint_rdpmc"]
    pub static mut __tracepoint_rdpmc: tracepoint;
}
extern "C" {
    pub fn do_trace_write_msr(
        msr: ::std::os::raw::c_uint,
        val: __u64,
        failed: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn do_trace_read_msr(
        msr: ::std::os::raw::c_uint,
        val: __u64,
        failed: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn do_trace_rdpmc(msr: ::std::os::raw::c_uint, val: __u64, failed: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rdmsr_safe_regs(regs: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsr_safe_regs(regs: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}paravirt_steal_enabled"]
    pub static mut paravirt_steal_enabled: static_key;
}
extern "C" {
    #[link_name = "\u{1}paravirt_steal_rq_enabled"]
    pub static mut paravirt_steal_rq_enabled: static_key;
}
extern "C" {
    pub fn default_banner();
}
extern "C" {
    pub fn msrs_alloc() -> *mut msr;
}
extern "C" {
    pub fn msrs_free(msrs: *mut msr);
}
extern "C" {
    pub fn msr_set_bit(msr: u32, bit: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msr_clear_bit(msr: u32, bit: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdmsr_on_cpu(
        cpu: ::std::os::raw::c_uint,
        msr_no: u32,
        l: *mut u32,
        h: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsr_on_cpu(
        cpu: ::std::os::raw::c_uint,
        msr_no: u32,
        l: u32,
        h: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdmsrl_on_cpu(
        cpu: ::std::os::raw::c_uint,
        msr_no: u32,
        q: *mut __u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsrl_on_cpu(
        cpu: ::std::os::raw::c_uint,
        msr_no: u32,
        q: __u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdmsr_on_cpus(mask: *const cpumask, msr_no: u32, msrs: *mut msr);
}
extern "C" {
    pub fn wrmsr_on_cpus(mask: *const cpumask, msr_no: u32, msrs: *mut msr);
}
extern "C" {
    pub fn rdmsr_safe_on_cpu(
        cpu: ::std::os::raw::c_uint,
        msr_no: u32,
        l: *mut u32,
        h: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsr_safe_on_cpu(
        cpu: ::std::os::raw::c_uint,
        msr_no: u32,
        l: u32,
        h: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdmsrl_safe_on_cpu(
        cpu: ::std::os::raw::c_uint,
        msr_no: u32,
        q: *mut __u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsrl_safe_on_cpu(
        cpu: ::std::os::raw::c_uint,
        msr_no: u32,
        q: __u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdmsr_safe_regs_on_cpu(
        cpu: ::std::os::raw::c_uint,
        regs: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsr_safe_regs_on_cpu(
        cpu: ::std::os::raw::c_uint,
        regs: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__force_order"]
    pub static mut __force_order: ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn native_load_gs_index(arg1: ::std::os::raw::c_uint);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fregs_state {
    pub cwd: u32,
    pub swd: u32,
    pub twd: u32,
    pub fip: u32,
    pub fcs: u32,
    pub foo: u32,
    pub fos: u32,
    pub st_space: [u32; 20usize],
    pub status: u32,
}
#[test]
fn bindgen_test_layout_fregs_state() {
    assert_eq!(
        ::std::mem::size_of::<fregs_state>(),
        112usize,
        concat!("Size of: ", stringify!(fregs_state))
    );
    assert_eq!(
        ::std::mem::align_of::<fregs_state>(),
        4usize,
        concat!("Alignment of ", stringify!(fregs_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).swd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).twd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(twd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).fip as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(fip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).fcs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(fcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).foo as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(foo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).fos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(fos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).st_space as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(st_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).status as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fxregs_state {
    pub cwd: u16,
    pub swd: u16,
    pub twd: u16,
    pub fop: u16,
    pub __bindgen_anon_1: fxregs_state__bindgen_ty_1,
    pub mxcsr: u32,
    pub mxcsr_mask: u32,
    pub st_space: [u32; 32usize],
    pub xmm_space: [u32; 64usize],
    pub padding: [u32; 12usize],
    pub __bindgen_anon_2: fxregs_state__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fxregs_state__bindgen_ty_1 {
    pub __bindgen_anon_1: fxregs_state__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: fxregs_state__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fxregs_state__bindgen_ty_1__bindgen_ty_1 {
    pub rip: __u64,
    pub rdp: __u64,
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<fxregs_state__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<fxregs_state__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_1>())).rip as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_1>())).rdp as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rdp)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fxregs_state__bindgen_ty_1__bindgen_ty_2 {
    pub fip: u32,
    pub fcs: u32,
    pub foo: u32,
    pub fos: u32,
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<fxregs_state__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<fxregs_state__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).fip as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).fcs as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fcs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).foo as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(foo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).fos as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fos)
        )
    );
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<fxregs_state__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(fxregs_state__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<fxregs_state__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(fxregs_state__bindgen_ty_1))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fxregs_state__bindgen_ty_2 {
    pub padding1: [u32; 12usize],
    pub sw_reserved: [u32; 12usize],
    _bindgen_union_align: [u32; 12usize],
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<fxregs_state__bindgen_ty_2>(),
        48usize,
        concat!("Size of: ", stringify!(fxregs_state__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<fxregs_state__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(fxregs_state__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fxregs_state__bindgen_ty_2>())).padding1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_2),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fxregs_state__bindgen_ty_2>())).sw_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_2),
            "::",
            stringify!(sw_reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_fxregs_state() {
    assert_eq!(
        ::std::mem::size_of::<fxregs_state>(),
        512usize,
        concat!("Size of: ", stringify!(fxregs_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).twd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(twd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).mxcsr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(mxcsr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).st_space as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(st_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).xmm_space as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(xmm_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).padding as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swregs_state {
    pub cwd: u32,
    pub swd: u32,
    pub twd: u32,
    pub fip: u32,
    pub fcs: u32,
    pub foo: u32,
    pub fos: u32,
    pub st_space: [u32; 20usize],
    pub ftop: u8,
    pub changed: u8,
    pub lookahead: u8,
    pub no_update: u8,
    pub rm: u8,
    pub alimit: u8,
    pub info: *mut math_emu_info,
    pub entry_eip: u32,
}
#[test]
fn bindgen_test_layout_swregs_state() {
    assert_eq!(
        ::std::mem::size_of::<swregs_state>(),
        136usize,
        concat!("Size of: ", stringify!(swregs_state))
    );
    assert_eq!(
        ::std::mem::align_of::<swregs_state>(),
        8usize,
        concat!("Alignment of ", stringify!(swregs_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).swd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).twd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(twd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).fip as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(fip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).fcs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(fcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).foo as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(foo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).fos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(fos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).st_space as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(st_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).ftop as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(ftop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).changed as *const _ as usize },
        109usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).lookahead as *const _ as usize },
        110usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(lookahead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).no_update as *const _ as usize },
        111usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(no_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).rm as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(rm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).alimit as *const _ as usize },
        113usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(alimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).info as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).entry_eip as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(entry_eip)
        )
    );
}
pub const xfeature_XFEATURE_FP: xfeature = 0;
pub const xfeature_XFEATURE_SSE: xfeature = 1;
pub const xfeature_XFEATURE_YMM: xfeature = 2;
pub const xfeature_XFEATURE_BNDREGS: xfeature = 3;
pub const xfeature_XFEATURE_BNDCSR: xfeature = 4;
pub const xfeature_XFEATURE_OPMASK: xfeature = 5;
pub const xfeature_XFEATURE_ZMM_Hi256: xfeature = 6;
pub const xfeature_XFEATURE_Hi16_ZMM: xfeature = 7;
pub const xfeature_XFEATURE_PT_UNIMPLEMENTED_SO_FAR: xfeature = 8;
pub const xfeature_XFEATURE_PKRU: xfeature = 9;
pub const xfeature_XFEATURE_MAX: xfeature = 10;
pub type xfeature = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct reg_128_bit {
    pub regbytes: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_reg_128_bit() {
    assert_eq!(
        ::std::mem::size_of::<reg_128_bit>(),
        16usize,
        concat!("Size of: ", stringify!(reg_128_bit))
    );
    assert_eq!(
        ::std::mem::align_of::<reg_128_bit>(),
        1usize,
        concat!("Alignment of ", stringify!(reg_128_bit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<reg_128_bit>())).regbytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(reg_128_bit),
            "::",
            stringify!(regbytes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct reg_256_bit {
    pub regbytes: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_reg_256_bit() {
    assert_eq!(
        ::std::mem::size_of::<reg_256_bit>(),
        32usize,
        concat!("Size of: ", stringify!(reg_256_bit))
    );
    assert_eq!(
        ::std::mem::align_of::<reg_256_bit>(),
        1usize,
        concat!("Alignment of ", stringify!(reg_256_bit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<reg_256_bit>())).regbytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(reg_256_bit),
            "::",
            stringify!(regbytes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct reg_512_bit {
    pub regbytes: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_reg_512_bit() {
    assert_eq!(
        ::std::mem::size_of::<reg_512_bit>(),
        64usize,
        concat!("Size of: ", stringify!(reg_512_bit))
    );
    assert_eq!(
        ::std::mem::align_of::<reg_512_bit>(),
        1usize,
        concat!("Alignment of ", stringify!(reg_512_bit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<reg_512_bit>())).regbytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(reg_512_bit),
            "::",
            stringify!(regbytes)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ymmh_struct {
    pub hi_ymm: [reg_128_bit; 16usize],
}
#[test]
fn bindgen_test_layout_ymmh_struct() {
    assert_eq!(
        ::std::mem::size_of::<ymmh_struct>(),
        256usize,
        concat!("Size of: ", stringify!(ymmh_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<ymmh_struct>(),
        1usize,
        concat!("Alignment of ", stringify!(ymmh_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ymmh_struct>())).hi_ymm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ymmh_struct),
            "::",
            stringify!(hi_ymm)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mpx_bndreg {
    pub lower_bound: __u64,
    pub upper_bound: __u64,
}
#[test]
fn bindgen_test_layout_mpx_bndreg() {
    assert_eq!(
        ::std::mem::size_of::<mpx_bndreg>(),
        16usize,
        concat!("Size of: ", stringify!(mpx_bndreg))
    );
    assert_eq!(
        ::std::mem::align_of::<mpx_bndreg>(),
        1usize,
        concat!("Alignment of ", stringify!(mpx_bndreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpx_bndreg>())).lower_bound as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpx_bndreg),
            "::",
            stringify!(lower_bound)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpx_bndreg>())).upper_bound as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpx_bndreg),
            "::",
            stringify!(upper_bound)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mpx_bndreg_state {
    pub bndreg: [mpx_bndreg; 4usize],
}
#[test]
fn bindgen_test_layout_mpx_bndreg_state() {
    assert_eq!(
        ::std::mem::size_of::<mpx_bndreg_state>(),
        64usize,
        concat!("Size of: ", stringify!(mpx_bndreg_state))
    );
    assert_eq!(
        ::std::mem::align_of::<mpx_bndreg_state>(),
        1usize,
        concat!("Alignment of ", stringify!(mpx_bndreg_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpx_bndreg_state>())).bndreg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpx_bndreg_state),
            "::",
            stringify!(bndreg)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mpx_bndcsr {
    pub bndcfgu: __u64,
    pub bndstatus: __u64,
}
#[test]
fn bindgen_test_layout_mpx_bndcsr() {
    assert_eq!(
        ::std::mem::size_of::<mpx_bndcsr>(),
        16usize,
        concat!("Size of: ", stringify!(mpx_bndcsr))
    );
    assert_eq!(
        ::std::mem::align_of::<mpx_bndcsr>(),
        1usize,
        concat!("Alignment of ", stringify!(mpx_bndcsr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpx_bndcsr>())).bndcfgu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpx_bndcsr),
            "::",
            stringify!(bndcfgu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpx_bndcsr>())).bndstatus as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpx_bndcsr),
            "::",
            stringify!(bndstatus)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mpx_bndcsr_state {
    pub __bindgen_anon_1: mpx_bndcsr_state__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mpx_bndcsr_state__bindgen_ty_1 {
    pub bndcsr: mpx_bndcsr,
    pub pad_to_64_bytes: [u8; 64usize],
    _bindgen_union_align: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_mpx_bndcsr_state__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<mpx_bndcsr_state__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(mpx_bndcsr_state__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<mpx_bndcsr_state__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(mpx_bndcsr_state__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mpx_bndcsr_state__bindgen_ty_1>())).bndcsr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpx_bndcsr_state__bindgen_ty_1),
            "::",
            stringify!(bndcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mpx_bndcsr_state__bindgen_ty_1>())).pad_to_64_bytes as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpx_bndcsr_state__bindgen_ty_1),
            "::",
            stringify!(pad_to_64_bytes)
        )
    );
}
#[test]
fn bindgen_test_layout_mpx_bndcsr_state() {
    assert_eq!(
        ::std::mem::size_of::<mpx_bndcsr_state>(),
        64usize,
        concat!("Size of: ", stringify!(mpx_bndcsr_state))
    );
    assert_eq!(
        ::std::mem::align_of::<mpx_bndcsr_state>(),
        1usize,
        concat!("Alignment of ", stringify!(mpx_bndcsr_state))
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct avx_512_opmask_state {
    pub opmask_reg: [__u64; 8usize],
}
#[test]
fn bindgen_test_layout_avx_512_opmask_state() {
    assert_eq!(
        ::std::mem::size_of::<avx_512_opmask_state>(),
        64usize,
        concat!("Size of: ", stringify!(avx_512_opmask_state))
    );
    assert_eq!(
        ::std::mem::align_of::<avx_512_opmask_state>(),
        1usize,
        concat!("Alignment of ", stringify!(avx_512_opmask_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avx_512_opmask_state>())).opmask_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avx_512_opmask_state),
            "::",
            stringify!(opmask_reg)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct avx_512_zmm_uppers_state {
    pub zmm_upper: [reg_256_bit; 16usize],
}
#[test]
fn bindgen_test_layout_avx_512_zmm_uppers_state() {
    assert_eq!(
        ::std::mem::size_of::<avx_512_zmm_uppers_state>(),
        512usize,
        concat!("Size of: ", stringify!(avx_512_zmm_uppers_state))
    );
    assert_eq!(
        ::std::mem::align_of::<avx_512_zmm_uppers_state>(),
        1usize,
        concat!("Alignment of ", stringify!(avx_512_zmm_uppers_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<avx_512_zmm_uppers_state>())).zmm_upper as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avx_512_zmm_uppers_state),
            "::",
            stringify!(zmm_upper)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct avx_512_hi16_state {
    pub hi16_zmm: [reg_512_bit; 16usize],
}
#[test]
fn bindgen_test_layout_avx_512_hi16_state() {
    assert_eq!(
        ::std::mem::size_of::<avx_512_hi16_state>(),
        1024usize,
        concat!("Size of: ", stringify!(avx_512_hi16_state))
    );
    assert_eq!(
        ::std::mem::align_of::<avx_512_hi16_state>(),
        1usize,
        concat!("Alignment of ", stringify!(avx_512_hi16_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avx_512_hi16_state>())).hi16_zmm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avx_512_hi16_state),
            "::",
            stringify!(hi16_zmm)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct pkru_state {
    pub pkru: u32,
    pub pad: u32,
}
#[test]
fn bindgen_test_layout_pkru_state() {
    assert_eq!(
        ::std::mem::size_of::<pkru_state>(),
        8usize,
        concat!("Size of: ", stringify!(pkru_state))
    );
    assert_eq!(
        ::std::mem::align_of::<pkru_state>(),
        1usize,
        concat!("Alignment of ", stringify!(pkru_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkru_state>())).pkru as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkru_state),
            "::",
            stringify!(pkru)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkru_state>())).pad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pkru_state),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct xstate_header {
    pub xfeatures: __u64,
    pub xcomp_bv: __u64,
    pub reserved: [__u64; 6usize],
}
#[test]
fn bindgen_test_layout_xstate_header() {
    assert_eq!(
        ::std::mem::size_of::<xstate_header>(),
        64usize,
        concat!("Size of: ", stringify!(xstate_header))
    );
    assert_eq!(
        ::std::mem::align_of::<xstate_header>(),
        1usize,
        concat!("Alignment of ", stringify!(xstate_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xstate_header>())).xfeatures as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xstate_header),
            "::",
            stringify!(xfeatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xstate_header>())).xcomp_bv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xstate_header),
            "::",
            stringify!(xcomp_bv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xstate_header>())).reserved as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xstate_header),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
pub struct xregs_state {
    pub _bindgen_opaque_blob: [u8; 576usize],
}
#[test]
fn bindgen_test_layout_xregs_state() {
    assert_eq!(
        ::std::mem::size_of::<xregs_state>(),
        576usize,
        concat!("Size of: ", stringify!(xregs_state))
    );
}
#[repr(C)]
pub struct fpregs_state {
    pub fsave: __BindgenUnionField<fregs_state>,
    pub fxsave: __BindgenUnionField<fxregs_state>,
    pub soft: __BindgenUnionField<swregs_state>,
    pub xsave: __BindgenUnionField<xregs_state>,
    pub __padding: __BindgenUnionField<[u8; 4096usize]>,
    pub bindgen_union_field: [u8; 4096usize],
}
#[test]
fn bindgen_test_layout_fpregs_state() {
    assert_eq!(
        ::std::mem::size_of::<fpregs_state>(),
        4096usize,
        concat!("Size of: ", stringify!(fpregs_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpregs_state>())).fsave as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(fsave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpregs_state>())).fxsave as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(fxsave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpregs_state>())).soft as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(soft)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpregs_state>())).xsave as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(xsave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpregs_state>())).__padding as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(__padding)
        )
    );
}
#[repr(C)]
pub struct fpu {
    pub last_cpu: ::std::os::raw::c_uint,
    pub initialized: ::std::os::raw::c_uchar,
    pub __bindgen_padding_0: [u64; 7usize],
    pub state: fpregs_state,
}
#[test]
fn bindgen_test_layout_fpu() {
    assert_eq!(
        ::std::mem::size_of::<fpu>(),
        4160usize,
        concat!("Size of: ", stringify!(fpu))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu>())).last_cpu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu),
            "::",
            stringify!(last_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu>())).initialized as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu),
            "::",
            stringify!(initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu>())).state as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu),
            "::",
            stringify!(state)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct orc_entry {
    pub sp_offset: s16,
    pub bp_offset: s16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_orc_entry() {
    assert_eq!(
        ::std::mem::size_of::<orc_entry>(),
        6usize,
        concat!("Size of: ", stringify!(orc_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<orc_entry>(),
        1usize,
        concat!("Alignment of ", stringify!(orc_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<orc_entry>())).sp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(orc_entry),
            "::",
            stringify!(sp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<orc_entry>())).bp_offset as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(orc_entry),
            "::",
            stringify!(bp_offset)
        )
    );
}
impl orc_entry {
    #[inline]
    pub fn sp_reg(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_sp_reg(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn bp_reg(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_bp_reg(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sp_reg: ::std::os::raw::c_uint,
        bp_reg: ::std::os::raw::c_uint,
        type_: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let sp_reg: u32 = unsafe { ::std::mem::transmute(sp_reg) };
            sp_reg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let bp_reg: u32 = unsafe { ::std::mem::transmute(bp_reg) };
            bp_reg as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct unwind_hint {
    pub ip: u32,
    pub sp_offset: s16,
    pub sp_reg: u8,
    pub type_: u8,
}
#[test]
fn bindgen_test_layout_unwind_hint() {
    assert_eq!(
        ::std::mem::size_of::<unwind_hint>(),
        8usize,
        concat!("Size of: ", stringify!(unwind_hint))
    );
    assert_eq!(
        ::std::mem::align_of::<unwind_hint>(),
        4usize,
        concat!("Alignment of ", stringify!(unwind_hint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unwind_hint>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unwind_hint),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unwind_hint>())).sp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(unwind_hint),
            "::",
            stringify!(sp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unwind_hint>())).sp_reg as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(unwind_hint),
            "::",
            stringify!(sp_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unwind_hint>())).type_ as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(unwind_hint),
            "::",
            stringify!(type_)
        )
    );
}
pub const UNAME26: _bindgen_ty_6 = 131072;
pub const ADDR_NO_RANDOMIZE: _bindgen_ty_6 = 262144;
pub const FDPIC_FUNCPTRS: _bindgen_ty_6 = 524288;
pub const MMAP_PAGE_ZERO: _bindgen_ty_6 = 1048576;
pub const ADDR_COMPAT_LAYOUT: _bindgen_ty_6 = 2097152;
pub const READ_IMPLIES_EXEC: _bindgen_ty_6 = 4194304;
pub const ADDR_LIMIT_32BIT: _bindgen_ty_6 = 8388608;
pub const SHORT_INODE: _bindgen_ty_6 = 16777216;
pub const WHOLE_SECONDS: _bindgen_ty_6 = 33554432;
pub const STICKY_TIMEOUTS: _bindgen_ty_6 = 67108864;
pub const ADDR_LIMIT_3GB: _bindgen_ty_6 = 134217728;
pub type _bindgen_ty_6 = u32;
pub const PER_LINUX: _bindgen_ty_7 = 0;
pub const PER_LINUX_32BIT: _bindgen_ty_7 = 8388608;
pub const PER_LINUX_FDPIC: _bindgen_ty_7 = 524288;
pub const PER_SVR4: _bindgen_ty_7 = 68157441;
pub const PER_SVR3: _bindgen_ty_7 = 83886082;
pub const PER_SCOSVR3: _bindgen_ty_7 = 117440515;
pub const PER_OSR5: _bindgen_ty_7 = 100663299;
pub const PER_WYSEV386: _bindgen_ty_7 = 83886084;
pub const PER_ISCR4: _bindgen_ty_7 = 67108869;
pub const PER_BSD: _bindgen_ty_7 = 6;
pub const PER_SUNOS: _bindgen_ty_7 = 67108870;
pub const PER_XENIX: _bindgen_ty_7 = 83886087;
pub const PER_LINUX32: _bindgen_ty_7 = 8;
pub const PER_LINUX32_3GB: _bindgen_ty_7 = 134217736;
pub const PER_IRIX32: _bindgen_ty_7 = 67108873;
pub const PER_IRIXN32: _bindgen_ty_7 = 67108874;
pub const PER_IRIX64: _bindgen_ty_7 = 67108875;
pub const PER_RISCOS: _bindgen_ty_7 = 12;
pub const PER_SOLARIS: _bindgen_ty_7 = 67108877;
pub const PER_UW7: _bindgen_ty_7 = 68157454;
pub const PER_OSF4: _bindgen_ty_7 = 15;
pub const PER_HPUX: _bindgen_ty_7 = 16;
pub const PER_MASK: _bindgen_ty_7 = 255;
pub type _bindgen_ty_7 = u32;
extern "C" {
    pub fn iter_div_u64_rem(dividend: __u64, divisor: u32, remainder: *mut __u64) -> u32;
}
pub const tlb_infos_ENTRIES: tlb_infos = 0;
pub const tlb_infos_NR_INFO: tlb_infos = 1;
pub type tlb_infos = u32;
extern "C" {
    #[link_name = "\u{1}tlb_lli_4k"]
    pub static mut tlb_lli_4k: [u16; 1usize];
}
extern "C" {
    #[link_name = "\u{1}tlb_lli_2m"]
    pub static mut tlb_lli_2m: [u16; 1usize];
}
extern "C" {
    #[link_name = "\u{1}tlb_lli_4m"]
    pub static mut tlb_lli_4m: [u16; 1usize];
}
extern "C" {
    #[link_name = "\u{1}tlb_lld_4k"]
    pub static mut tlb_lld_4k: [u16; 1usize];
}
extern "C" {
    #[link_name = "\u{1}tlb_lld_2m"]
    pub static mut tlb_lld_2m: [u16; 1usize];
}
extern "C" {
    #[link_name = "\u{1}tlb_lld_4m"]
    pub static mut tlb_lld_4m: [u16; 1usize];
}
extern "C" {
    #[link_name = "\u{1}tlb_lld_1g"]
    pub static mut tlb_lld_1g: [u16; 1usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpuinfo_x86 {
    pub x86: __u8,
    pub x86_vendor: __u8,
    pub x86_model: __u8,
    pub x86_stepping: __u8,
    pub x86_tlbsize: ::std::os::raw::c_int,
    pub x86_virt_bits: __u8,
    pub x86_phys_bits: __u8,
    pub x86_coreid_bits: __u8,
    pub cu_id: __u8,
    pub extended_cpuid_level: __u32,
    pub cpuid_level: ::std::os::raw::c_int,
    pub x86_capability: [__u32; 20usize],
    pub x86_vendor_id: [::std::os::raw::c_char; 16usize],
    pub x86_model_id: [::std::os::raw::c_char; 64usize],
    pub x86_cache_size: ::std::os::raw::c_uint,
    pub x86_cache_alignment: ::std::os::raw::c_int,
    pub x86_cache_max_rmid: ::std::os::raw::c_int,
    pub x86_cache_occ_scale: ::std::os::raw::c_int,
    pub x86_power: ::std::os::raw::c_int,
    pub loops_per_jiffy: ::std::os::raw::c_ulong,
    pub x86_max_cores: u16,
    pub apicid: u16,
    pub initial_apicid: u16,
    pub x86_clflush_size: u16,
    pub booted_cores: u16,
    pub phys_proc_id: u16,
    pub logical_proc_id: u16,
    pub cpu_core_id: u16,
    pub cpu_index: u16,
    pub microcode: u32,
    pub x86_cache_bits: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u16; 3usize],
}
#[test]
fn bindgen_test_layout_cpuinfo_x86() {
    assert_eq!(
        ::std::mem::size_of::<cpuinfo_x86>(),
        240usize,
        concat!("Size of: ", stringify!(cpuinfo_x86))
    );
    assert_eq!(
        ::std::mem::align_of::<cpuinfo_x86>(),
        8usize,
        concat!("Alignment of ", stringify!(cpuinfo_x86))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_vendor as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_vendor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_model as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_model)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_stepping as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_stepping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_tlbsize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_tlbsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_virt_bits as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_virt_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_phys_bits as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_phys_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_coreid_bits as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_coreid_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).cu_id as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(cu_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cpuinfo_x86>())).extended_cpuid_level as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(extended_cpuid_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).cpuid_level as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(cpuid_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_capability as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_capability)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_vendor_id as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_vendor_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_model_id as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_model_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_cache_size as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_cache_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_cache_alignment as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_cache_alignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_cache_max_rmid as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_cache_max_rmid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_cache_occ_scale as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_cache_occ_scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_power as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_power)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).loops_per_jiffy as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(loops_per_jiffy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_max_cores as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_max_cores)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).apicid as *const _ as usize },
        210usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(apicid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).initial_apicid as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(initial_apicid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_clflush_size as *const _ as usize },
        214usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_clflush_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).booted_cores as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(booted_cores)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).phys_proc_id as *const _ as usize },
        218usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(phys_proc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).logical_proc_id as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(logical_proc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).cpu_core_id as *const _ as usize },
        222usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(cpu_core_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).cpu_index as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(cpu_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).microcode as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(microcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_cache_bits as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_cache_bits)
        )
    );
}
impl cpuinfo_x86 {
    #[inline]
    pub fn initialized(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_initialized(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        initialized: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let initialized: u32 = unsafe { ::std::mem::transmute(initialized) };
            initialized as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpuid_regs {
    pub eax: u32,
    pub ebx: u32,
    pub ecx: u32,
    pub edx: u32,
}
#[test]
fn bindgen_test_layout_cpuid_regs() {
    assert_eq!(
        ::std::mem::size_of::<cpuid_regs>(),
        16usize,
        concat!("Size of: ", stringify!(cpuid_regs))
    );
    assert_eq!(
        ::std::mem::align_of::<cpuid_regs>(),
        4usize,
        concat!("Alignment of ", stringify!(cpuid_regs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuid_regs>())).eax as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_regs),
            "::",
            stringify!(eax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuid_regs>())).ebx as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_regs),
            "::",
            stringify!(ebx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuid_regs>())).ecx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_regs),
            "::",
            stringify!(ecx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuid_regs>())).edx as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_regs),
            "::",
            stringify!(edx)
        )
    );
}
pub const cpuid_regs_idx_CPUID_EAX: cpuid_regs_idx = 0;
pub const cpuid_regs_idx_CPUID_EBX: cpuid_regs_idx = 1;
pub const cpuid_regs_idx_CPUID_ECX: cpuid_regs_idx = 2;
pub const cpuid_regs_idx_CPUID_EDX: cpuid_regs_idx = 3;
pub type cpuid_regs_idx = u32;
extern "C" {
    #[link_name = "\u{1}boot_cpu_data"]
    pub static mut boot_cpu_data: cpuinfo_x86;
}
extern "C" {
    #[link_name = "\u{1}new_cpu_data"]
    pub static mut new_cpu_data: cpuinfo_x86;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct x86_hw_tss {
    pub reserved1: u32,
    pub sp0: __u64,
    pub sp1: __u64,
    pub sp2: __u64,
    pub reserved2: __u64,
    pub ist: [__u64; 7usize],
    pub reserved3: u32,
    pub reserved4: u32,
    pub reserved5: u16,
    pub io_bitmap_base: u16,
}
#[test]
fn bindgen_test_layout_x86_hw_tss() {
    assert_eq!(
        ::std::mem::size_of::<x86_hw_tss>(),
        104usize,
        concat!("Size of: ", stringify!(x86_hw_tss))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_hw_tss>(),
        1usize,
        concat!("Alignment of ", stringify!(x86_hw_tss))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).reserved1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).sp0 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(sp0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).sp1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(sp1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).sp2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(sp2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).reserved2 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).ist as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(ist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).reserved3 as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).reserved4 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).reserved5 as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).io_bitmap_base as *const _ as usize },
        102usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(io_bitmap_base)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}doublefault_tss"]
    pub static mut doublefault_tss: x86_hw_tss;
}
extern "C" {
    #[link_name = "\u{1}cpu_caps_cleared"]
    pub static mut cpu_caps_cleared: [__u32; 20usize];
}
extern "C" {
    #[link_name = "\u{1}cpu_caps_set"]
    pub static mut cpu_caps_set: [__u32; 20usize];
}
extern "C" {
    #[link_name = "\u{1}cpu_info"]
    pub static mut cpu_info: cpuinfo_x86;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seq_operations {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}cpuinfo_op"]
    pub static cpuinfo_op: seq_operations;
}
extern "C" {
    pub fn cpu_detect(c: *mut cpuinfo_x86);
}
extern "C" {
    pub fn early_cpu_init();
}
extern "C" {
    pub fn identify_boot_cpu();
}
extern "C" {
    pub fn identify_secondary_cpu(arg1: *mut cpuinfo_x86);
}
extern "C" {
    pub fn print_cpu_info(arg1: *mut cpuinfo_x86);
}
extern "C" {
    pub fn print_cpu_msr(arg1: *mut cpuinfo_x86);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct entry_stack {
    pub stack: [::std::os::raw::c_char; 4096usize],
}
#[test]
fn bindgen_test_layout_entry_stack() {
    assert_eq!(
        ::std::mem::size_of::<entry_stack>(),
        4096usize,
        concat!("Size of: ", stringify!(entry_stack))
    );
    assert_eq!(
        ::std::mem::align_of::<entry_stack>(),
        1usize,
        concat!("Alignment of ", stringify!(entry_stack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<entry_stack>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(entry_stack),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct entry_stack_page {
    pub stack: entry_stack,
}
#[test]
fn bindgen_test_layout_entry_stack_page() {
    assert_eq!(
        ::std::mem::size_of::<entry_stack_page>(),
        4096usize,
        concat!("Size of: ", stringify!(entry_stack_page))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<entry_stack_page>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(entry_stack_page),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tss_struct {
    pub x86_tss: x86_hw_tss,
    pub io_bitmap: [::std::os::raw::c_ulong; 1025usize],
    pub __bindgen_padding_0: [u64; 498usize],
}
#[test]
fn bindgen_test_layout_tss_struct() {
    assert_eq!(
        ::std::mem::size_of::<tss_struct>(),
        12288usize,
        concat!("Size of: ", stringify!(tss_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tss_struct>())).x86_tss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tss_struct),
            "::",
            stringify!(x86_tss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tss_struct>())).io_bitmap as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(tss_struct),
            "::",
            stringify!(io_bitmap)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}cpu_tss_rw"]
    pub static mut cpu_tss_rw: tss_struct;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct orig_ist {
    pub ist: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout_orig_ist() {
    assert_eq!(
        ::std::mem::size_of::<orig_ist>(),
        56usize,
        concat!("Size of: ", stringify!(orig_ist))
    );
    assert_eq!(
        ::std::mem::align_of::<orig_ist>(),
        8usize,
        concat!("Alignment of ", stringify!(orig_ist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<orig_ist>())).ist as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(orig_ist),
            "::",
            stringify!(ist)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}orig_ist"]
    pub static mut orig_ist: orig_ist;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union irq_stack_union {
    pub irq_stack: [::std::os::raw::c_char; 16384usize],
    pub __bindgen_anon_1: irq_stack_union__bindgen_ty_1,
    _bindgen_union_align: [u64; 2048usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_stack_union__bindgen_ty_1 {
    pub gs_base: [::std::os::raw::c_char; 40usize],
    pub stack_canary: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_irq_stack_union__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<irq_stack_union__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(irq_stack_union__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<irq_stack_union__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(irq_stack_union__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<irq_stack_union__bindgen_ty_1>())).gs_base as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_stack_union__bindgen_ty_1),
            "::",
            stringify!(gs_base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<irq_stack_union__bindgen_ty_1>())).stack_canary as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_stack_union__bindgen_ty_1),
            "::",
            stringify!(stack_canary)
        )
    );
}
#[test]
fn bindgen_test_layout_irq_stack_union() {
    assert_eq!(
        ::std::mem::size_of::<irq_stack_union>(),
        16384usize,
        concat!("Size of: ", stringify!(irq_stack_union))
    );
    assert_eq!(
        ::std::mem::align_of::<irq_stack_union>(),
        8usize,
        concat!("Alignment of ", stringify!(irq_stack_union))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<irq_stack_union>())).irq_stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_stack_union),
            "::",
            stringify!(irq_stack)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}irq_stack_union"]
    pub static mut irq_stack_union: irq_stack_union;
}
extern "C" {
    #[link_name = "\u{1}init_per_cpu__irq_stack_union"]
    pub static mut init_per_cpu__irq_stack_union: irq_stack_union;
}
extern "C" {
    #[link_name = "\u{1}irq_stack_ptr"]
    pub static mut irq_stack_ptr: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}irq_count"]
    pub static mut irq_count: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ignore_sysret();
}
extern "C" {
    #[link_name = "\u{1}fpu_kernel_xstate_size"]
    pub static mut fpu_kernel_xstate_size: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}fpu_user_xstate_size"]
    pub static mut fpu_user_xstate_size: ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_event {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mm_segment_t {
    pub seg: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_mm_segment_t() {
    assert_eq!(
        ::std::mem::size_of::<mm_segment_t>(),
        8usize,
        concat!("Size of: ", stringify!(mm_segment_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mm_segment_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mm_segment_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_segment_t>())).seg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_segment_t),
            "::",
            stringify!(seg)
        )
    );
}
#[repr(C)]
pub struct thread_struct {
    pub tls_array: [desc_struct; 3usize],
    pub sp: ::std::os::raw::c_ulong,
    pub es: ::std::os::raw::c_ushort,
    pub ds: ::std::os::raw::c_ushort,
    pub fsindex: ::std::os::raw::c_ushort,
    pub gsindex: ::std::os::raw::c_ushort,
    pub fsbase: ::std::os::raw::c_ulong,
    pub gsbase: ::std::os::raw::c_ulong,
    pub ptrace_bps: [*mut perf_event; 4usize],
    pub debugreg6: ::std::os::raw::c_ulong,
    pub ptrace_dr7: ::std::os::raw::c_ulong,
    pub cr2: ::std::os::raw::c_ulong,
    pub trap_nr: ::std::os::raw::c_ulong,
    pub error_code: ::std::os::raw::c_ulong,
    pub io_bitmap_ptr: *mut ::std::os::raw::c_ulong,
    pub iopl: ::std::os::raw::c_ulong,
    pub io_bitmap_max: ::std::os::raw::c_uint,
    pub addr_limit: mm_segment_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u64; 3usize],
    pub fpu: fpu,
}
#[test]
fn bindgen_test_layout_thread_struct() {
    assert_eq!(
        ::std::mem::size_of::<thread_struct>(),
        4352usize,
        concat!("Size of: ", stringify!(thread_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).tls_array as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(tls_array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).sp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).es as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).ds as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).fsindex as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(fsindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).gsindex as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(gsindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).fsbase as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(fsbase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).gsbase as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(gsbase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).ptrace_bps as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(ptrace_bps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).debugreg6 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(debugreg6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).ptrace_dr7 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(ptrace_dr7)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).cr2 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(cr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).trap_nr as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(trap_nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).error_code as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).io_bitmap_ptr as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(io_bitmap_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).iopl as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(iopl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).io_bitmap_max as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(io_bitmap_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).addr_limit as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(addr_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).fpu as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(fpu)
        )
    );
}
impl thread_struct {
    #[inline]
    pub fn sig_on_uaccess_err(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sig_on_uaccess_err(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uaccess_err(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uaccess_err(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sig_on_uaccess_err: ::std::os::raw::c_uint,
        uaccess_err: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sig_on_uaccess_err: u32 = unsafe { ::std::mem::transmute(sig_on_uaccess_err) };
            sig_on_uaccess_err as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let uaccess_err: u32 = unsafe { ::std::mem::transmute(uaccess_err) };
            uaccess_err as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn release_thread(arg1: *mut task_struct);
}
extern "C" {
    pub fn get_wchan(p: *mut task_struct) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn select_idle_routine(c: *const cpuinfo_x86);
}
extern "C" {
    pub fn amd_e400_c1e_apic_setup();
}
extern "C" {
    #[link_name = "\u{1}boot_option_idle_override"]
    pub static mut boot_option_idle_override: ::std::os::raw::c_ulong;
}
pub const idle_boot_override_IDLE_NO_OVERRIDE: idle_boot_override = 0;
pub const idle_boot_override_IDLE_HALT: idle_boot_override = 1;
pub const idle_boot_override_IDLE_NOMWAIT: idle_boot_override = 2;
pub const idle_boot_override_IDLE_POLL: idle_boot_override = 3;
pub type idle_boot_override = u32;
extern "C" {
    pub fn enable_sep_cpu();
}
extern "C" {
    pub fn sysenter_setup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn early_trap_init();
}
extern "C" {
    pub fn early_trap_pf_init();
}
extern "C" {
    #[link_name = "\u{1}early_gdt_descr"]
    pub static mut early_gdt_descr: desc_ptr;
}
extern "C" {
    pub fn cpu_set_gdt(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn switch_to_new_gdt(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn load_direct_gdt(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn load_fixmap_gdt(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn load_percpu_segment(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn cpu_init();
}
extern "C" {
    pub fn set_task_blockstep(task: *mut task_struct, on: bool_);
}
extern "C" {
    #[link_name = "\u{1}bootloader_type"]
    pub static mut bootloader_type: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}bootloader_version"]
    pub static mut bootloader_version: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}ignore_fpu_irq"]
    pub static mut ignore_fpu_irq: ::std::os::raw::c_char;
}
extern "C" {
    pub fn KSTK_ESP(task: *mut task_struct) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn start_thread(
        regs: *mut pt_regs,
        new_ip: ::std::os::raw::c_ulong,
        new_sp: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn get_tsc_mode(adr: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_tsc_mode(val: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}msr_misc_features_shadow"]
    pub static mut msr_misc_features_shadow: ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn mpx_enable_management() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mpx_disable_management() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn amd_get_nb_id(cpu: ::std::os::raw::c_int) -> u16;
}
extern "C" {
    pub fn amd_get_nodes_per_socket() -> u32;
}
extern "C" {
    pub fn arch_align_stack(sp: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn free_init_pages(
        what: *mut ::std::os::raw::c_char,
        begin: ::std::os::raw::c_ulong,
        end: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn free_kernel_image_pages(
        begin: *mut ::std::os::raw::c_void,
        end: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn default_idle();
}
extern "C" {
    pub fn xen_set_default_idle() -> bool_;
}
extern "C" {
    pub fn stop_this_cpu(dummy: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn df_debug(regs: *mut pt_regs, error_code: ::std::os::raw::c_long);
}
extern "C" {
    pub fn microcode_check();
}
pub const l1tf_mitigations_L1TF_MITIGATION_OFF: l1tf_mitigations = 0;
pub const l1tf_mitigations_L1TF_MITIGATION_FLUSH_NOWARN: l1tf_mitigations = 1;
pub const l1tf_mitigations_L1TF_MITIGATION_FLUSH: l1tf_mitigations = 2;
pub const l1tf_mitigations_L1TF_MITIGATION_FLUSH_NOSMT: l1tf_mitigations = 3;
pub const l1tf_mitigations_L1TF_MITIGATION_FULL: l1tf_mitigations = 4;
pub const l1tf_mitigations_L1TF_MITIGATION_FULL_FORCE: l1tf_mitigations = 5;
pub type l1tf_mitigations = u32;
extern "C" {
    #[link_name = "\u{1}l1tf_mitigation"]
    pub static mut l1tf_mitigation: l1tf_mitigations;
}
pub const mds_mitigations_MDS_MITIGATION_OFF: mds_mitigations = 0;
pub const mds_mitigations_MDS_MITIGATION_FULL: mds_mitigations = 1;
pub const mds_mitigations_MDS_MITIGATION_VMWERV: mds_mitigations = 2;
pub type mds_mitigations = u32;
pub const taa_mitigations_TAA_MITIGATION_OFF: taa_mitigations = 0;
pub const taa_mitigations_TAA_MITIGATION_UCODE_NEEDED: taa_mitigations = 1;
pub const taa_mitigations_TAA_MITIGATION_VERW: taa_mitigations = 2;
pub const taa_mitigations_TAA_MITIGATION_TSX_DISABLED: taa_mitigations = 3;
pub type taa_mitigations = u32;
pub const cpuid_leafs_CPUID_1_EDX: cpuid_leafs = 0;
pub const cpuid_leafs_CPUID_8000_0001_EDX: cpuid_leafs = 1;
pub const cpuid_leafs_CPUID_8086_0001_EDX: cpuid_leafs = 2;
pub const cpuid_leafs_CPUID_LNX_1: cpuid_leafs = 3;
pub const cpuid_leafs_CPUID_1_ECX: cpuid_leafs = 4;
pub const cpuid_leafs_CPUID_C000_0001_EDX: cpuid_leafs = 5;
pub const cpuid_leafs_CPUID_8000_0001_ECX: cpuid_leafs = 6;
pub const cpuid_leafs_CPUID_LNX_2: cpuid_leafs = 7;
pub const cpuid_leafs_CPUID_LNX_3: cpuid_leafs = 8;
pub const cpuid_leafs_CPUID_7_0_EBX: cpuid_leafs = 9;
pub const cpuid_leafs_CPUID_D_1_EAX: cpuid_leafs = 10;
pub const cpuid_leafs_CPUID_LNX_4: cpuid_leafs = 11;
pub const cpuid_leafs_CPUID_DUMMY: cpuid_leafs = 12;
pub const cpuid_leafs_CPUID_8000_0008_EBX: cpuid_leafs = 13;
pub const cpuid_leafs_CPUID_6_EAX: cpuid_leafs = 14;
pub const cpuid_leafs_CPUID_8000_000A_EDX: cpuid_leafs = 15;
pub const cpuid_leafs_CPUID_7_ECX: cpuid_leafs = 16;
pub const cpuid_leafs_CPUID_8000_0007_EBX: cpuid_leafs = 17;
pub const cpuid_leafs_CPUID_7_EDX: cpuid_leafs = 18;
pub type cpuid_leafs = u32;
extern "C" {
    #[link_name = "\u{1}x86_cap_flags"]
    pub static mut x86_cap_flags: [*const ::std::os::raw::c_char; 608usize];
}
extern "C" {
    #[link_name = "\u{1}x86_power_flags"]
    pub static mut x86_power_flags: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    #[link_name = "\u{1}x86_bug_flags"]
    pub static mut x86_bug_flags: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    pub fn setup_clear_cpu_cap(bit: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn clear_cpu_cap(c: *mut cpuinfo_x86, bit: ::std::os::raw::c_uint);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct thread_info {
    pub flags: ::std::os::raw::c_ulong,
    pub status: u32,
}
#[test]
fn bindgen_test_layout_thread_info() {
    assert_eq!(
        ::std::mem::size_of::<thread_info>(),
        16usize,
        concat!("Size of: ", stringify!(thread_info))
    );
    assert_eq!(
        ::std::mem::align_of::<thread_info>(),
        8usize,
        concat!("Alignment of ", stringify!(thread_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_info>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_info>())).status as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_info),
            "::",
            stringify!(status)
        )
    );
}
extern "C" {
    pub fn arch_task_cache_init();
}
extern "C" {
    pub fn arch_dup_task_struct(
        dst: *mut task_struct,
        src: *mut task_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arch_release_task_struct(tsk: *mut task_struct);
}
extern "C" {
    pub fn arch_setup_new_exec();
}
extern "C" {
    pub fn __check_object_size(
        ptr: *const ::std::os::raw::c_void,
        n: ::std::os::raw::c_ulong,
        to_user: bool_,
    );
}
extern "C" {
    pub fn __bad_copy_from();
}
extern "C" {
    pub fn __bad_copy_to();
}
extern "C" {
    #[link_name = "\u{1}__preempt_count"]
    pub static mut __preempt_count: ::std::os::raw::c_int;
}
#[doc = " preempt_ops - notifiers called when a task is preempted and rescheduled"]
#[doc = " @sched_in: we're about to be rescheduled:"]
#[doc = "    notifier: struct preempt_notifier for the task being scheduled"]
#[doc = "    cpu:  cpu we're scheduled on"]
#[doc = " @sched_out: we've just been preempted"]
#[doc = "    notifier: struct preempt_notifier for the task being preempted"]
#[doc = "    next: the task that's kicking us out"]
#[doc = ""]
#[doc = " Please note that sched_in and out are called under different"]
#[doc = " contexts.  sched_out is called with rq lock held and irq disabled"]
#[doc = " while sched_in is called without rq lock and irq enabled.  This"]
#[doc = " difference is intentional and depended upon by its users."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct preempt_ops {
    pub sched_in: ::std::option::Option<
        unsafe extern "C" fn(notifier: *mut preempt_notifier, cpu: ::std::os::raw::c_int),
    >,
    pub sched_out: ::std::option::Option<
        unsafe extern "C" fn(notifier: *mut preempt_notifier, next: *mut task_struct),
    >,
}
#[test]
fn bindgen_test_layout_preempt_ops() {
    assert_eq!(
        ::std::mem::size_of::<preempt_ops>(),
        16usize,
        concat!("Size of: ", stringify!(preempt_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<preempt_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(preempt_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<preempt_ops>())).sched_in as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(preempt_ops),
            "::",
            stringify!(sched_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<preempt_ops>())).sched_out as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(preempt_ops),
            "::",
            stringify!(sched_out)
        )
    );
}
#[doc = " preempt_notifier - key for installing preemption notifiers"]
#[doc = " @link: internal use"]
#[doc = " @ops: defines the notifier functions to be called"]
#[doc = ""]
#[doc = " Usually used in conjunction with container_of()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct preempt_notifier {
    pub link: hlist_node,
    pub ops: *mut preempt_ops,
}
#[test]
fn bindgen_test_layout_preempt_notifier() {
    assert_eq!(
        ::std::mem::size_of::<preempt_notifier>(),
        24usize,
        concat!("Size of: ", stringify!(preempt_notifier))
    );
    assert_eq!(
        ::std::mem::align_of::<preempt_notifier>(),
        8usize,
        concat!("Alignment of ", stringify!(preempt_notifier))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<preempt_notifier>())).link as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(preempt_notifier),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<preempt_notifier>())).ops as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(preempt_notifier),
            "::",
            stringify!(ops)
        )
    );
}
extern "C" {
    pub fn preempt_notifier_inc();
}
extern "C" {
    pub fn preempt_notifier_dec();
}
extern "C" {
    pub fn preempt_notifier_register(notifier: *mut preempt_notifier);
}
extern "C" {
    pub fn preempt_notifier_unregister(notifier: *mut preempt_notifier);
}
extern "C" {
    pub fn _local_bh_enable();
}
extern "C" {
    pub fn __local_bh_enable_ip(ip: ::std::os::raw::c_ulong, cnt: ::std::os::raw::c_uint);
}
extern "C" {
    #[link_name = "\u{1}prove_locking"]
    pub static mut prove_locking: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}lock_stat"]
    pub static mut lock_stat: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lock_class_key {}
#[test]
fn bindgen_test_layout_lock_class_key() {
    assert_eq!(
        ::std::mem::size_of::<lock_class_key>(),
        0usize,
        concat!("Size of: ", stringify!(lock_class_key))
    );
    assert_eq!(
        ::std::mem::align_of::<lock_class_key>(),
        1usize,
        concat!("Alignment of ", stringify!(lock_class_key))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lockdep_map {}
#[test]
fn bindgen_test_layout_lockdep_map() {
    assert_eq!(
        ::std::mem::size_of::<lockdep_map>(),
        0usize,
        concat!("Size of: ", stringify!(lockdep_map))
    );
    assert_eq!(
        ::std::mem::align_of::<lockdep_map>(),
        1usize,
        concat!("Alignment of ", stringify!(lockdep_map))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pin_cookie {}
#[test]
fn bindgen_test_layout_pin_cookie() {
    assert_eq!(
        ::std::mem::size_of::<pin_cookie>(),
        0usize,
        concat!("Size of: ", stringify!(pin_cookie))
    );
    assert_eq!(
        ::std::mem::align_of::<pin_cookie>(),
        1usize,
        concat!("Alignment of ", stringify!(pin_cookie))
    );
}
pub const xhlock_context_t_XHLOCK_HARD: xhlock_context_t = 0;
pub const xhlock_context_t_XHLOCK_SOFT: xhlock_context_t = 1;
pub const xhlock_context_t_XHLOCK_CTX_NR: xhlock_context_t = 2;
pub type xhlock_context_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raw_spinlock {
    pub raw_lock: arch_spinlock_t,
}
#[test]
fn bindgen_test_layout_raw_spinlock() {
    assert_eq!(
        ::std::mem::size_of::<raw_spinlock>(),
        4usize,
        concat!("Size of: ", stringify!(raw_spinlock))
    );
    assert_eq!(
        ::std::mem::align_of::<raw_spinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(raw_spinlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raw_spinlock>())).raw_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raw_spinlock),
            "::",
            stringify!(raw_lock)
        )
    );
}
pub type raw_spinlock_t = raw_spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spinlock {
    pub __bindgen_anon_1: spinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spinlock__bindgen_ty_1 {
    pub rlock: raw_spinlock,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_spinlock__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spinlock__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(spinlock__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spinlock__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(spinlock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spinlock__bindgen_ty_1>())).rlock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spinlock__bindgen_ty_1),
            "::",
            stringify!(rlock)
        )
    );
}
#[test]
fn bindgen_test_layout_spinlock() {
    assert_eq!(
        ::std::mem::size_of::<spinlock>(),
        4usize,
        concat!("Size of: ", stringify!(spinlock))
    );
    assert_eq!(
        ::std::mem::align_of::<spinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(spinlock))
    );
}
pub type spinlock_t = spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rwlock_t {
    pub raw_lock: arch_rwlock_t,
}
#[test]
fn bindgen_test_layout_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<rwlock_t>(),
        8usize,
        concat!("Size of: ", stringify!(rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rwlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rwlock_t>())).raw_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rwlock_t),
            "::",
            stringify!(raw_lock)
        )
    );
}
extern "C" {
    pub fn native_queued_spin_lock_slowpath(lock: *mut qspinlock, val: u32);
}
extern "C" {
    pub fn __pv_init_lock_hash();
}
extern "C" {
    pub fn __pv_queued_spin_lock_slowpath(lock: *mut qspinlock, val: u32);
}
extern "C" {
    pub fn __raw_callee_save___pv_queued_spin_unlock(lock: *mut qspinlock);
}
extern "C" {
    #[link_name = "\u{1}virt_spin_lock_key"]
    pub static mut virt_spin_lock_key: static_key_true;
}
extern "C" {
    pub fn native_pv_lock_init();
}
extern "C" {
    pub fn queued_read_lock_slowpath(lock: *mut qrwlock);
}
extern "C" {
    pub fn queued_write_lock_slowpath(lock: *mut qrwlock);
}
extern "C" {
    pub fn in_lock_functions(addr: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _raw_spin_lock(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_lock_nested(lock: *mut raw_spinlock_t, subclass: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _raw_spin_lock_nest_lock(lock: *mut raw_spinlock_t, map: *mut lockdep_map);
}
extern "C" {
    pub fn _raw_spin_lock_bh(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_lock_irq(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_lock_irqsave(lock: *mut raw_spinlock_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _raw_spin_lock_irqsave_nested(
        lock: *mut raw_spinlock_t,
        subclass: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _raw_spin_trylock(lock: *mut raw_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _raw_spin_trylock_bh(lock: *mut raw_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _raw_spin_unlock(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_unlock_bh(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_unlock_irq(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_unlock_irqrestore(lock: *mut raw_spinlock_t, flags: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn _raw_read_lock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_lock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_lock_bh(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_lock_bh(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_lock_irq(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_lock_irq(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_lock_irqsave(lock: *mut rwlock_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _raw_write_lock_irqsave(lock: *mut rwlock_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _raw_read_trylock(lock: *mut rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _raw_write_trylock(lock: *mut rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _raw_read_unlock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_unlock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_unlock_bh(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_unlock_bh(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_unlock_irq(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_unlock_irq(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_unlock_irqrestore(lock: *mut rwlock_t, flags: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn _raw_write_unlock_irqrestore(lock: *mut rwlock_t, flags: ::std::os::raw::c_ulong);
}
extern "C" {
    #[doc = " atomic_dec_and_lock - lock on reaching reference count zero"]
    #[doc = " @atomic: the atomic counter"]
    #[doc = " @lock: the spinlock in question"]
    #[doc = ""]
    #[doc = " Decrements @atomic by 1.  If the result is 0, returns true and locks"]
    #[doc = " @lock.  Returns false for all other cases."]
    pub fn _atomic_dec_and_lock(
        atomic: *mut atomic_t,
        lock: *mut spinlock_t,
    ) -> ::std::os::raw::c_int;
}
pub type wait_queue_entry_t = wait_queue_entry;
pub type wait_queue_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        wq_entry: *mut wait_queue_entry,
        mode: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_int,
        key: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn default_wake_function(
        wq_entry: *mut wait_queue_entry,
        mode: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_int,
        key: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_queue_entry {
    pub flags: ::std::os::raw::c_uint,
    pub private: *mut ::std::os::raw::c_void,
    pub func: wait_queue_func_t,
    pub entry: list_head,
}
#[test]
fn bindgen_test_layout_wait_queue_entry() {
    assert_eq!(
        ::std::mem::size_of::<wait_queue_entry>(),
        40usize,
        concat!("Size of: ", stringify!(wait_queue_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<wait_queue_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(wait_queue_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait_queue_entry>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_queue_entry),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait_queue_entry>())).private as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_queue_entry),
            "::",
            stringify!(private)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait_queue_entry>())).func as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_queue_entry),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait_queue_entry>())).entry as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_queue_entry),
            "::",
            stringify!(entry)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_queue_head {
    pub lock: spinlock_t,
    pub head: list_head,
}
#[test]
fn bindgen_test_layout_wait_queue_head() {
    assert_eq!(
        ::std::mem::size_of::<wait_queue_head>(),
        24usize,
        concat!("Size of: ", stringify!(wait_queue_head))
    );
    assert_eq!(
        ::std::mem::align_of::<wait_queue_head>(),
        8usize,
        concat!("Alignment of ", stringify!(wait_queue_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait_queue_head>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_queue_head),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait_queue_head>())).head as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_queue_head),
            "::",
            stringify!(head)
        )
    );
}
pub type wait_queue_head_t = wait_queue_head;
extern "C" {
    pub fn __init_waitqueue_head(
        wq_head: *mut wait_queue_head,
        name: *const ::std::os::raw::c_char,
        arg1: *mut lock_class_key,
    );
}
extern "C" {
    pub fn add_wait_queue(wq_head: *mut wait_queue_head, wq_entry: *mut wait_queue_entry);
}
extern "C" {
    pub fn add_wait_queue_exclusive(wq_head: *mut wait_queue_head, wq_entry: *mut wait_queue_entry);
}
extern "C" {
    pub fn remove_wait_queue(wq_head: *mut wait_queue_head, wq_entry: *mut wait_queue_entry);
}
extern "C" {
    pub fn __wake_up(
        wq_head: *mut wait_queue_head,
        mode: ::std::os::raw::c_uint,
        nr: ::std::os::raw::c_int,
        key: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn __wake_up_locked_key(
        wq_head: *mut wait_queue_head,
        mode: ::std::os::raw::c_uint,
        key: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn __wake_up_locked_key_bookmark(
        wq_head: *mut wait_queue_head,
        mode: ::std::os::raw::c_uint,
        key: *mut ::std::os::raw::c_void,
        bookmark: *mut wait_queue_entry_t,
    );
}
extern "C" {
    pub fn __wake_up_sync_key(
        wq_head: *mut wait_queue_head,
        mode: ::std::os::raw::c_uint,
        nr: ::std::os::raw::c_int,
        key: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn __wake_up_locked(
        wq_head: *mut wait_queue_head,
        mode: ::std::os::raw::c_uint,
        nr: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn __wake_up_sync(
        wq_head: *mut wait_queue_head,
        mode: ::std::os::raw::c_uint,
        nr: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn init_wait_entry(wq_entry: *mut wait_queue_entry, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn do_wait_intr(
        arg1: *mut wait_queue_head_t,
        arg2: *mut wait_queue_entry_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_wait_intr_irq(
        arg1: *mut wait_queue_head_t,
        arg2: *mut wait_queue_entry_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn prepare_to_wait(
        wq_head: *mut wait_queue_head,
        wq_entry: *mut wait_queue_entry,
        state: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn prepare_to_wait_exclusive(
        wq_head: *mut wait_queue_head,
        wq_entry: *mut wait_queue_entry,
        state: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn prepare_to_wait_event(
        wq_head: *mut wait_queue_head,
        wq_entry: *mut wait_queue_entry,
        state: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn finish_wait(wq_head: *mut wait_queue_head, wq_entry: *mut wait_queue_entry);
}
extern "C" {
    pub fn wait_woken(
        wq_entry: *mut wait_queue_entry,
        mode: ::std::os::raw::c_uint,
        timeout: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn woken_wake_function(
        wq_entry: *mut wait_queue_entry,
        mode: ::std::os::raw::c_uint,
        sync: ::std::os::raw::c_int,
        key: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn autoremove_wake_function(
        wq_entry: *mut wait_queue_entry,
        mode: ::std::os::raw::c_uint,
        sync: ::std::os::raw::c_int,
        key: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seqcount {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_seqcount() {
    assert_eq!(
        ::std::mem::size_of::<seqcount>(),
        4usize,
        concat!("Size of: ", stringify!(seqcount))
    );
    assert_eq!(
        ::std::mem::align_of::<seqcount>(),
        4usize,
        concat!("Alignment of ", stringify!(seqcount))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seqcount>())).sequence as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seqcount),
            "::",
            stringify!(sequence)
        )
    );
}
pub type seqcount_t = seqcount;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seqlock_t {
    pub seqcount: seqcount,
    pub lock: spinlock_t,
}
#[test]
fn bindgen_test_layout_seqlock_t() {
    assert_eq!(
        ::std::mem::size_of::<seqlock_t>(),
        8usize,
        concat!("Size of: ", stringify!(seqlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<seqlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(seqlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seqlock_t>())).seqcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seqlock_t),
            "::",
            stringify!(seqcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seqlock_t>())).lock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(seqlock_t),
            "::",
            stringify!(lock)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nodemask_t {
    pub bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout_nodemask_t() {
    assert_eq!(
        ::std::mem::size_of::<nodemask_t>(),
        128usize,
        concat!("Size of: ", stringify!(nodemask_t))
    );
    assert_eq!(
        ::std::mem::align_of::<nodemask_t>(),
        8usize,
        concat!("Alignment of ", stringify!(nodemask_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nodemask_t>())).bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nodemask_t),
            "::",
            stringify!(bits)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_unused_nodemask_arg_"]
    pub static mut _unused_nodemask_arg_: nodemask_t;
}
extern "C" {
    pub fn __next_node_in(
        node: ::std::os::raw::c_int,
        srcp: *const nodemask_t,
    ) -> ::std::os::raw::c_int;
}
pub const node_states_N_POSSIBLE: node_states = 0;
pub const node_states_N_ONLINE: node_states = 1;
pub const node_states_N_NORMAL_MEMORY: node_states = 2;
pub const node_states_N_HIGH_MEMORY: node_states = 2;
pub const node_states_N_MEMORY: node_states = 3;
pub const node_states_N_CPU: node_states = 4;
pub const node_states_NR_NODE_STATES: node_states = 5;
pub type node_states = u32;
extern "C" {
    #[link_name = "\u{1}node_states"]
    pub static mut node_states: [nodemask_t; 5usize];
}
extern "C" {
    #[link_name = "\u{1}nr_node_ids"]
    pub static mut nr_node_ids: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}nr_online_nodes"]
    pub static mut nr_online_nodes: ::std::os::raw::c_int;
}
extern "C" {
    pub fn node_random(maskp: *const nodemask_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nodemask_scratch {
    pub mask1: nodemask_t,
    pub mask2: nodemask_t,
}
#[test]
fn bindgen_test_layout_nodemask_scratch() {
    assert_eq!(
        ::std::mem::size_of::<nodemask_scratch>(),
        256usize,
        concat!("Size of: ", stringify!(nodemask_scratch))
    );
    assert_eq!(
        ::std::mem::align_of::<nodemask_scratch>(),
        8usize,
        concat!("Alignment of ", stringify!(nodemask_scratch))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nodemask_scratch>())).mask1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nodemask_scratch),
            "::",
            stringify!(mask1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nodemask_scratch>())).mask2 as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(nodemask_scratch),
            "::",
            stringify!(mask2)
        )
    );
}
pub const pageblock_bits_PB_migrate: pageblock_bits = 0;
pub const pageblock_bits_PB_migrate_end: pageblock_bits = 2;
pub const pageblock_bits_PB_migrate_skip: pageblock_bits = 3;
pub const pageblock_bits_NR_PAGEBLOCK_BITS: pageblock_bits = 4;
pub type pageblock_bits = u32;
extern "C" {
    pub fn get_pfnblock_flags_mask(
        page: *mut page,
        pfn: ::std::os::raw::c_ulong,
        end_bitidx: ::std::os::raw::c_ulong,
        mask: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn set_pfnblock_flags_mask(
        page: *mut page,
        flags: ::std::os::raw::c_ulong,
        pfn: ::std::os::raw::c_ulong,
        end_bitidx: ::std::os::raw::c_ulong,
        mask: ::std::os::raw::c_ulong,
    );
}
pub const migratetype_MIGRATE_UNMOVABLE: migratetype = 0;
pub const migratetype_MIGRATE_MOVABLE: migratetype = 1;
pub const migratetype_MIGRATE_RECLAIMABLE: migratetype = 2;
pub const migratetype_MIGRATE_PCPTYPES: migratetype = 3;
pub const migratetype_MIGRATE_HIGHATOMIC: migratetype = 3;
pub const migratetype_MIGRATE_CMA: migratetype = 4;
pub const migratetype_MIGRATE_ISOLATE: migratetype = 5;
pub const migratetype_MIGRATE_TYPES: migratetype = 6;
pub type migratetype = u32;
extern "C" {
    #[link_name = "\u{1}migratetype_names"]
    pub static mut migratetype_names: [*mut ::std::os::raw::c_char; 6usize];
}
extern "C" {
    #[link_name = "\u{1}page_group_by_mobility_disabled"]
    pub static mut page_group_by_mobility_disabled: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct free_area {
    pub free_list: [list_head; 6usize],
    pub nr_free: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_free_area() {
    assert_eq!(
        ::std::mem::size_of::<free_area>(),
        104usize,
        concat!("Size of: ", stringify!(free_area))
    );
    assert_eq!(
        ::std::mem::align_of::<free_area>(),
        8usize,
        concat!("Alignment of ", stringify!(free_area))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<free_area>())).free_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(free_area),
            "::",
            stringify!(free_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<free_area>())).nr_free as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(free_area),
            "::",
            stringify!(nr_free)
        )
    );
}
#[repr(C)]
pub struct zone_padding {
    pub x: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_zone_padding() {
    assert_eq!(
        ::std::mem::size_of::<zone_padding>(),
        0usize,
        concat!("Size of: ", stringify!(zone_padding))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone_padding>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zone_padding),
            "::",
            stringify!(x)
        )
    );
}
pub const numa_stat_item_NUMA_HIT: numa_stat_item = 0;
pub const numa_stat_item_NUMA_MISS: numa_stat_item = 1;
pub const numa_stat_item_NUMA_FOREIGN: numa_stat_item = 2;
pub const numa_stat_item_NUMA_INTERLEAVE_HIT: numa_stat_item = 3;
pub const numa_stat_item_NUMA_LOCAL: numa_stat_item = 4;
pub const numa_stat_item_NUMA_OTHER: numa_stat_item = 5;
pub const numa_stat_item_NR_VM_NUMA_STAT_ITEMS: numa_stat_item = 6;
pub type numa_stat_item = u32;
pub const zone_stat_item_NR_FREE_PAGES: zone_stat_item = 0;
pub const zone_stat_item_NR_ZONE_LRU_BASE: zone_stat_item = 1;
pub const zone_stat_item_NR_ZONE_INACTIVE_ANON: zone_stat_item = 1;
pub const zone_stat_item_NR_ZONE_ACTIVE_ANON: zone_stat_item = 2;
pub const zone_stat_item_NR_ZONE_INACTIVE_FILE: zone_stat_item = 3;
pub const zone_stat_item_NR_ZONE_ACTIVE_FILE: zone_stat_item = 4;
pub const zone_stat_item_NR_ZONE_UNEVICTABLE: zone_stat_item = 5;
pub const zone_stat_item_NR_ZONE_WRITE_PENDING: zone_stat_item = 6;
pub const zone_stat_item_NR_MLOCK: zone_stat_item = 7;
pub const zone_stat_item_NR_PAGETABLE: zone_stat_item = 8;
pub const zone_stat_item_NR_KERNEL_STACK_KB: zone_stat_item = 9;
pub const zone_stat_item_NR_BOUNCE: zone_stat_item = 10;
pub const zone_stat_item_NR_ZSPAGES: zone_stat_item = 11;
pub const zone_stat_item_NR_FREE_CMA_PAGES: zone_stat_item = 12;
pub const zone_stat_item_NR_VM_ZONE_STAT_ITEMS: zone_stat_item = 13;
pub type zone_stat_item = u32;
pub const node_stat_item_NR_LRU_BASE: node_stat_item = 0;
pub const node_stat_item_NR_INACTIVE_ANON: node_stat_item = 0;
pub const node_stat_item_NR_ACTIVE_ANON: node_stat_item = 1;
pub const node_stat_item_NR_INACTIVE_FILE: node_stat_item = 2;
pub const node_stat_item_NR_ACTIVE_FILE: node_stat_item = 3;
pub const node_stat_item_NR_UNEVICTABLE: node_stat_item = 4;
pub const node_stat_item_NR_SLAB_RECLAIMABLE: node_stat_item = 5;
pub const node_stat_item_NR_SLAB_UNRECLAIMABLE: node_stat_item = 6;
pub const node_stat_item_NR_ISOLATED_ANON: node_stat_item = 7;
pub const node_stat_item_NR_ISOLATED_FILE: node_stat_item = 8;
pub const node_stat_item_WORKINGSET_REFAULT: node_stat_item = 9;
pub const node_stat_item_WORKINGSET_ACTIVATE: node_stat_item = 10;
pub const node_stat_item_WORKINGSET_NODERECLAIM: node_stat_item = 11;
pub const node_stat_item_NR_ANON_MAPPED: node_stat_item = 12;
pub const node_stat_item_NR_FILE_MAPPED: node_stat_item = 13;
pub const node_stat_item_NR_FILE_PAGES: node_stat_item = 14;
pub const node_stat_item_NR_FILE_DIRTY: node_stat_item = 15;
pub const node_stat_item_NR_WRITEBACK: node_stat_item = 16;
pub const node_stat_item_NR_WRITEBACK_TEMP: node_stat_item = 17;
pub const node_stat_item_NR_SHMEM: node_stat_item = 18;
pub const node_stat_item_NR_SHMEM_THPS: node_stat_item = 19;
pub const node_stat_item_NR_SHMEM_PMDMAPPED: node_stat_item = 20;
pub const node_stat_item_NR_ANON_THPS: node_stat_item = 21;
pub const node_stat_item_NR_UNSTABLE_NFS: node_stat_item = 22;
pub const node_stat_item_NR_VMSCAN_WRITE: node_stat_item = 23;
pub const node_stat_item_NR_VMSCAN_IMMEDIATE: node_stat_item = 24;
pub const node_stat_item_NR_DIRTIED: node_stat_item = 25;
pub const node_stat_item_NR_WRITTEN: node_stat_item = 26;
pub const node_stat_item_NR_INDIRECTLY_RECLAIMABLE_BYTES: node_stat_item = 27;
pub const node_stat_item_NR_VM_NODE_STAT_ITEMS: node_stat_item = 28;
pub type node_stat_item = u32;
pub const lru_list_LRU_INACTIVE_ANON: lru_list = 0;
pub const lru_list_LRU_ACTIVE_ANON: lru_list = 1;
pub const lru_list_LRU_INACTIVE_FILE: lru_list = 2;
pub const lru_list_LRU_ACTIVE_FILE: lru_list = 3;
pub const lru_list_LRU_UNEVICTABLE: lru_list = 4;
pub const lru_list_NR_LRU_LISTS: lru_list = 5;
pub type lru_list = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct zone_reclaim_stat {
    pub recent_rotated: [::std::os::raw::c_ulong; 2usize],
    pub recent_scanned: [::std::os::raw::c_ulong; 2usize],
}
#[test]
fn bindgen_test_layout_zone_reclaim_stat() {
    assert_eq!(
        ::std::mem::size_of::<zone_reclaim_stat>(),
        32usize,
        concat!("Size of: ", stringify!(zone_reclaim_stat))
    );
    assert_eq!(
        ::std::mem::align_of::<zone_reclaim_stat>(),
        8usize,
        concat!("Alignment of ", stringify!(zone_reclaim_stat))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zone_reclaim_stat>())).recent_rotated as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zone_reclaim_stat),
            "::",
            stringify!(recent_rotated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zone_reclaim_stat>())).recent_scanned as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zone_reclaim_stat),
            "::",
            stringify!(recent_scanned)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lruvec {
    pub lists: [list_head; 5usize],
    pub reclaim_stat: zone_reclaim_stat,
    pub inactive_age: atomic_long_t,
    pub refaults: ::std::os::raw::c_ulong,
    pub pgdat: *mut pglist_data,
}
#[test]
fn bindgen_test_layout_lruvec() {
    assert_eq!(
        ::std::mem::size_of::<lruvec>(),
        136usize,
        concat!("Size of: ", stringify!(lruvec))
    );
    assert_eq!(
        ::std::mem::align_of::<lruvec>(),
        8usize,
        concat!("Alignment of ", stringify!(lruvec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lruvec>())).lists as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lruvec),
            "::",
            stringify!(lists)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lruvec>())).reclaim_stat as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lruvec),
            "::",
            stringify!(reclaim_stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lruvec>())).inactive_age as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lruvec),
            "::",
            stringify!(inactive_age)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lruvec>())).refaults as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(lruvec),
            "::",
            stringify!(refaults)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lruvec>())).pgdat as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(lruvec),
            "::",
            stringify!(pgdat)
        )
    );
}
pub type isolate_mode_t = ::std::os::raw::c_uint;
pub const zone_watermarks_WMARK_MIN: zone_watermarks = 0;
pub const zone_watermarks_WMARK_LOW: zone_watermarks = 1;
pub const zone_watermarks_WMARK_HIGH: zone_watermarks = 2;
pub const zone_watermarks_NR_WMARK: zone_watermarks = 3;
pub type zone_watermarks = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct per_cpu_pages {
    pub count: ::std::os::raw::c_int,
    pub high: ::std::os::raw::c_int,
    pub batch: ::std::os::raw::c_int,
    pub lists: [list_head; 3usize],
}
#[test]
fn bindgen_test_layout_per_cpu_pages() {
    assert_eq!(
        ::std::mem::size_of::<per_cpu_pages>(),
        64usize,
        concat!("Size of: ", stringify!(per_cpu_pages))
    );
    assert_eq!(
        ::std::mem::align_of::<per_cpu_pages>(),
        8usize,
        concat!("Alignment of ", stringify!(per_cpu_pages))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<per_cpu_pages>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pages),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<per_cpu_pages>())).high as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pages),
            "::",
            stringify!(high)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<per_cpu_pages>())).batch as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pages),
            "::",
            stringify!(batch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<per_cpu_pages>())).lists as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pages),
            "::",
            stringify!(lists)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct per_cpu_pageset {
    pub pcp: per_cpu_pages,
    pub expire: s8,
    pub vm_numa_stat_diff: [u16; 6usize],
    pub stat_threshold: s8,
    pub vm_stat_diff: [s8; 13usize],
}
#[test]
fn bindgen_test_layout_per_cpu_pageset() {
    assert_eq!(
        ::std::mem::size_of::<per_cpu_pageset>(),
        96usize,
        concat!("Size of: ", stringify!(per_cpu_pageset))
    );
    assert_eq!(
        ::std::mem::align_of::<per_cpu_pageset>(),
        8usize,
        concat!("Alignment of ", stringify!(per_cpu_pageset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<per_cpu_pageset>())).pcp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pageset),
            "::",
            stringify!(pcp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<per_cpu_pageset>())).expire as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pageset),
            "::",
            stringify!(expire)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<per_cpu_pageset>())).vm_numa_stat_diff as *const _ as usize
        },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pageset),
            "::",
            stringify!(vm_numa_stat_diff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<per_cpu_pageset>())).stat_threshold as *const _ as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pageset),
            "::",
            stringify!(stat_threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<per_cpu_pageset>())).vm_stat_diff as *const _ as usize },
        79usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pageset),
            "::",
            stringify!(vm_stat_diff)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct per_cpu_nodestat {
    pub stat_threshold: s8,
    pub vm_node_stat_diff: [s8; 28usize],
}
#[test]
fn bindgen_test_layout_per_cpu_nodestat() {
    assert_eq!(
        ::std::mem::size_of::<per_cpu_nodestat>(),
        29usize,
        concat!("Size of: ", stringify!(per_cpu_nodestat))
    );
    assert_eq!(
        ::std::mem::align_of::<per_cpu_nodestat>(),
        1usize,
        concat!("Alignment of ", stringify!(per_cpu_nodestat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<per_cpu_nodestat>())).stat_threshold as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_nodestat),
            "::",
            stringify!(stat_threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<per_cpu_nodestat>())).vm_node_stat_diff as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_nodestat),
            "::",
            stringify!(vm_node_stat_diff)
        )
    );
}
pub const zone_type_ZONE_DMA: zone_type = 0;
pub const zone_type_ZONE_DMA32: zone_type = 1;
pub const zone_type_ZONE_NORMAL: zone_type = 2;
pub const zone_type_ZONE_MOVABLE: zone_type = 3;
pub const zone_type_ZONE_DEVICE: zone_type = 4;
pub const zone_type___MAX_NR_ZONES: zone_type = 5;
pub type zone_type = u32;
#[repr(C)]
pub struct zone {
    pub watermark: [::std::os::raw::c_ulong; 3usize],
    pub nr_reserved_highatomic: ::std::os::raw::c_ulong,
    pub lowmem_reserve: [::std::os::raw::c_long; 5usize],
    pub node: ::std::os::raw::c_int,
    pub zone_pgdat: *mut pglist_data,
    pub pageset: *mut per_cpu_pageset,
    pub zone_start_pfn: ::std::os::raw::c_ulong,
    pub managed_pages: ::std::os::raw::c_ulong,
    pub spanned_pages: ::std::os::raw::c_ulong,
    pub present_pages: ::std::os::raw::c_ulong,
    pub name: *const ::std::os::raw::c_char,
    pub nr_isolate_pageblock: ::std::os::raw::c_ulong,
    pub span_seqlock: seqlock_t,
    pub initialized: ::std::os::raw::c_int,
    pub __bindgen_padding_0: [u64; 4usize],
    pub _pad1_: zone_padding,
    pub free_area: [free_area; 11usize],
    pub flags: ::std::os::raw::c_ulong,
    pub lock: spinlock_t,
    pub __bindgen_padding_1: [u64; 7usize],
    pub _pad2_: zone_padding,
    pub percpu_drift_mark: ::std::os::raw::c_ulong,
    pub compact_cached_free_pfn: ::std::os::raw::c_ulong,
    pub compact_cached_migrate_pfn: [::std::os::raw::c_ulong; 2usize],
    pub compact_considered: ::std::os::raw::c_uint,
    pub compact_defer_shift: ::std::os::raw::c_uint,
    pub compact_order_failed: ::std::os::raw::c_int,
    pub compact_blockskip_flush: bool_,
    pub contiguous: bool_,
    pub __bindgen_padding_2: [u64; 2usize],
    pub _pad3_: zone_padding,
    pub vm_stat: [atomic_long_t; 13usize],
    pub vm_numa_stat: [atomic_long_t; 6usize],
    pub __bindgen_padding_3: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_zone() {
    assert_eq!(
        ::std::mem::size_of::<zone>(),
        1664usize,
        concat!("Size of: ", stringify!(zone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).watermark as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(watermark)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).nr_reserved_highatomic as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(nr_reserved_highatomic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).lowmem_reserve as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(lowmem_reserve)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).node as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).zone_pgdat as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(zone_pgdat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).pageset as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(pageset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).zone_start_pfn as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(zone_start_pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).managed_pages as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(managed_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).spanned_pages as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(spanned_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).present_pages as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(present_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).name as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).nr_isolate_pageblock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(nr_isolate_pageblock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).span_seqlock as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(span_seqlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).initialized as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>()))._pad1_ as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(_pad1_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).free_area as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(free_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).flags as *const _ as usize },
        1336usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).lock as *const _ as usize },
        1344usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>()))._pad2_ as *const _ as usize },
        1408usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(_pad2_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).percpu_drift_mark as *const _ as usize },
        1408usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(percpu_drift_mark)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).compact_cached_free_pfn as *const _ as usize },
        1416usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(compact_cached_free_pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).compact_cached_migrate_pfn as *const _ as usize },
        1424usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(compact_cached_migrate_pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).compact_considered as *const _ as usize },
        1440usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(compact_considered)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).compact_defer_shift as *const _ as usize },
        1444usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(compact_defer_shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).compact_order_failed as *const _ as usize },
        1448usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(compact_order_failed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).compact_blockskip_flush as *const _ as usize },
        1452usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(compact_blockskip_flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).contiguous as *const _ as usize },
        1453usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(contiguous)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>()))._pad3_ as *const _ as usize },
        1472usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(_pad3_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).vm_stat as *const _ as usize },
        1472usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(vm_stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).vm_numa_stat as *const _ as usize },
        1576usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(vm_numa_stat)
        )
    );
}
pub const pgdat_flags_PGDAT_CONGESTED: pgdat_flags = 0;
pub const pgdat_flags_PGDAT_DIRTY: pgdat_flags = 1;
pub const pgdat_flags_PGDAT_WRITEBACK: pgdat_flags = 2;
pub const pgdat_flags_PGDAT_RECLAIM_LOCKED: pgdat_flags = 3;
pub type pgdat_flags = u32;
pub const ZONELIST_FALLBACK: _bindgen_ty_8 = 0;
pub const ZONELIST_NOFALLBACK: _bindgen_ty_8 = 1;
pub const MAX_ZONELISTS: _bindgen_ty_8 = 2;
pub type _bindgen_ty_8 = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct zoneref {
    pub zone: *mut zone,
    pub zone_idx: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_zoneref() {
    assert_eq!(
        ::std::mem::size_of::<zoneref>(),
        16usize,
        concat!("Size of: ", stringify!(zoneref))
    );
    assert_eq!(
        ::std::mem::align_of::<zoneref>(),
        8usize,
        concat!("Alignment of ", stringify!(zoneref))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zoneref>())).zone as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zoneref),
            "::",
            stringify!(zone)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zoneref>())).zone_idx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zoneref),
            "::",
            stringify!(zone_idx)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct zonelist {
    pub _zonerefs: [zoneref; 5121usize],
}
#[test]
fn bindgen_test_layout_zonelist() {
    assert_eq!(
        ::std::mem::size_of::<zonelist>(),
        81936usize,
        concat!("Size of: ", stringify!(zonelist))
    );
    assert_eq!(
        ::std::mem::align_of::<zonelist>(),
        8usize,
        concat!("Alignment of ", stringify!(zonelist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zonelist>()))._zonerefs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zonelist),
            "::",
            stringify!(_zonerefs)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}mem_map"]
    pub static mut mem_map: *mut page;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bootmem_data {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct pglist_data {
    pub node_zones: [zone; 5usize],
    pub node_zonelists: [zonelist; 2usize],
    pub nr_zones: ::std::os::raw::c_int,
    pub node_size_lock: spinlock_t,
    pub node_start_pfn: ::std::os::raw::c_ulong,
    pub node_present_pages: ::std::os::raw::c_ulong,
    pub node_spanned_pages: ::std::os::raw::c_ulong,
    pub node_id: ::std::os::raw::c_int,
    pub kswapd_wait: wait_queue_head_t,
    pub pfmemalloc_wait: wait_queue_head_t,
    pub kswapd: *mut task_struct,
    pub kswapd_order: ::std::os::raw::c_int,
    pub kswapd_classzone_idx: zone_type,
    pub kswapd_failures: ::std::os::raw::c_int,
    pub kcompactd_max_order: ::std::os::raw::c_int,
    pub kcompactd_classzone_idx: zone_type,
    pub kcompactd_wait: wait_queue_head_t,
    pub kcompactd: *mut task_struct,
    pub numabalancing_migrate_lock: spinlock_t,
    pub numabalancing_migrate_next_window: ::std::os::raw::c_ulong,
    pub numabalancing_migrate_nr_pages: ::std::os::raw::c_ulong,
    pub totalreserve_pages: ::std::os::raw::c_ulong,
    pub min_unmapped_pages: ::std::os::raw::c_ulong,
    pub min_slab_pages: ::std::os::raw::c_ulong,
    pub __bindgen_padding_0: [u64; 3usize],
    pub _pad1_: zone_padding,
    pub lru_lock: spinlock_t,
    pub split_queue_lock: spinlock_t,
    pub split_queue: list_head,
    pub split_queue_len: ::std::os::raw::c_ulong,
    pub lruvec: lruvec,
    pub flags: ::std::os::raw::c_ulong,
    pub __bindgen_padding_1: [u64; 2usize],
    pub _pad2_: zone_padding,
    pub per_cpu_nodestats: *mut per_cpu_nodestat,
    pub vm_stat: [atomic_long_t; 28usize],
    pub __bindgen_padding_2: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_pglist_data() {
    assert_eq!(
        ::std::mem::size_of::<pglist_data>(),
        172864usize,
        concat!("Size of: ", stringify!(pglist_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).node_zones as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(node_zones)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).node_zonelists as *const _ as usize },
        8320usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(node_zonelists)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).nr_zones as *const _ as usize },
        172192usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(nr_zones)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).node_size_lock as *const _ as usize },
        172196usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(node_size_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).node_start_pfn as *const _ as usize },
        172200usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(node_start_pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).node_present_pages as *const _ as usize },
        172208usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(node_present_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).node_spanned_pages as *const _ as usize },
        172216usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(node_spanned_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).node_id as *const _ as usize },
        172224usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(node_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).kswapd_wait as *const _ as usize },
        172232usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kswapd_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).pfmemalloc_wait as *const _ as usize },
        172256usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(pfmemalloc_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).kswapd as *const _ as usize },
        172280usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kswapd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).kswapd_order as *const _ as usize },
        172288usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kswapd_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pglist_data>())).kswapd_classzone_idx as *const _ as usize
        },
        172292usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kswapd_classzone_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).kswapd_failures as *const _ as usize },
        172296usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kswapd_failures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).kcompactd_max_order as *const _ as usize },
        172300usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kcompactd_max_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pglist_data>())).kcompactd_classzone_idx as *const _ as usize
        },
        172304usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kcompactd_classzone_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).kcompactd_wait as *const _ as usize },
        172312usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kcompactd_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).kcompactd as *const _ as usize },
        172336usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kcompactd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pglist_data>())).numabalancing_migrate_lock as *const _ as usize
        },
        172344usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(numabalancing_migrate_lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pglist_data>())).numabalancing_migrate_next_window as *const _
                as usize
        },
        172352usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(numabalancing_migrate_next_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pglist_data>())).numabalancing_migrate_nr_pages as *const _
                as usize
        },
        172360usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(numabalancing_migrate_nr_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).totalreserve_pages as *const _ as usize },
        172368usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(totalreserve_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).min_unmapped_pages as *const _ as usize },
        172376usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(min_unmapped_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).min_slab_pages as *const _ as usize },
        172384usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(min_slab_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>()))._pad1_ as *const _ as usize },
        172416usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(_pad1_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).lru_lock as *const _ as usize },
        172416usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(lru_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).split_queue_lock as *const _ as usize },
        172420usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(split_queue_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).split_queue as *const _ as usize },
        172424usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(split_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).split_queue_len as *const _ as usize },
        172440usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(split_queue_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).lruvec as *const _ as usize },
        172448usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(lruvec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).flags as *const _ as usize },
        172584usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>()))._pad2_ as *const _ as usize },
        172608usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(_pad2_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).per_cpu_nodestats as *const _ as usize },
        172608usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(per_cpu_nodestats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).vm_stat as *const _ as usize },
        172616usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(vm_stat)
        )
    );
}
pub type pg_data_t = pglist_data;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct optimistic_spin_node {
    pub next: *mut optimistic_spin_node,
    pub prev: *mut optimistic_spin_node,
    pub locked: ::std::os::raw::c_int,
    pub cpu: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_optimistic_spin_node() {
    assert_eq!(
        ::std::mem::size_of::<optimistic_spin_node>(),
        24usize,
        concat!("Size of: ", stringify!(optimistic_spin_node))
    );
    assert_eq!(
        ::std::mem::align_of::<optimistic_spin_node>(),
        8usize,
        concat!("Alignment of ", stringify!(optimistic_spin_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<optimistic_spin_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(optimistic_spin_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<optimistic_spin_node>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(optimistic_spin_node),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<optimistic_spin_node>())).locked as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(optimistic_spin_node),
            "::",
            stringify!(locked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<optimistic_spin_node>())).cpu as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(optimistic_spin_node),
            "::",
            stringify!(cpu)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct optimistic_spin_queue {
    pub tail: atomic_t,
}
#[test]
fn bindgen_test_layout_optimistic_spin_queue() {
    assert_eq!(
        ::std::mem::size_of::<optimistic_spin_queue>(),
        4usize,
        concat!("Size of: ", stringify!(optimistic_spin_queue))
    );
    assert_eq!(
        ::std::mem::align_of::<optimistic_spin_queue>(),
        4usize,
        concat!("Alignment of ", stringify!(optimistic_spin_queue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<optimistic_spin_queue>())).tail as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(optimistic_spin_queue),
            "::",
            stringify!(tail)
        )
    );
}
extern "C" {
    pub fn osq_lock(lock: *mut optimistic_spin_queue) -> bool_;
}
extern "C" {
    pub fn osq_unlock(lock: *mut optimistic_spin_queue);
}
extern "C" {
    #[link_name = "\u{1}debug_locks"]
    pub static mut debug_locks: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}debug_locks_silent"]
    pub static mut debug_locks_silent: ::std::os::raw::c_int;
}
extern "C" {
    pub fn debug_locks_off() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ww_acquire_ctx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mutex {
    pub owner: atomic_long_t,
    pub wait_lock: spinlock_t,
    pub osq: optimistic_spin_queue,
    pub wait_list: list_head,
}
#[test]
fn bindgen_test_layout_mutex() {
    assert_eq!(
        ::std::mem::size_of::<mutex>(),
        32usize,
        concat!("Size of: ", stringify!(mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(mutex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mutex>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mutex>())).wait_lock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex),
            "::",
            stringify!(wait_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mutex>())).osq as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex),
            "::",
            stringify!(osq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mutex>())).wait_list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex),
            "::",
            stringify!(wait_list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mutex_waiter {
    pub list: list_head,
    pub task: *mut task_struct,
    pub ww_ctx: *mut ww_acquire_ctx,
}
#[test]
fn bindgen_test_layout_mutex_waiter() {
    assert_eq!(
        ::std::mem::size_of::<mutex_waiter>(),
        32usize,
        concat!("Size of: ", stringify!(mutex_waiter))
    );
    assert_eq!(
        ::std::mem::align_of::<mutex_waiter>(),
        8usize,
        concat!("Alignment of ", stringify!(mutex_waiter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mutex_waiter>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex_waiter),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mutex_waiter>())).task as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex_waiter),
            "::",
            stringify!(task)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mutex_waiter>())).ww_ctx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex_waiter),
            "::",
            stringify!(ww_ctx)
        )
    );
}
extern "C" {
    pub fn __mutex_init(
        lock: *mut mutex,
        name: *const ::std::os::raw::c_char,
        key: *mut lock_class_key,
    );
}
extern "C" {
    pub fn mutex_lock(lock: *mut mutex);
}
extern "C" {
    pub fn mutex_lock_interruptible(lock: *mut mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mutex_lock_killable(lock: *mut mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mutex_lock_io(lock: *mut mutex);
}
extern "C" {
    pub fn mutex_trylock(lock: *mut mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mutex_unlock(lock: *mut mutex);
}
extern "C" {
    pub fn atomic_dec_and_mutex_lock(cnt: *mut atomic_t, lock: *mut mutex)
        -> ::std::os::raw::c_int;
}
pub const mutex_trylock_recursive_enum_MUTEX_TRYLOCK_FAILED: mutex_trylock_recursive_enum = 0;
pub const mutex_trylock_recursive_enum_MUTEX_TRYLOCK_SUCCESS: mutex_trylock_recursive_enum = 1;
pub const mutex_trylock_recursive_enum_MUTEX_TRYLOCK_RECURSIVE: mutex_trylock_recursive_enum = 2;
pub type mutex_trylock_recursive_enum = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rw_semaphore {
    pub count: atomic_long_t,
    pub wait_list: list_head,
    pub wait_lock: raw_spinlock_t,
    pub osq: optimistic_spin_queue,
    pub owner: *mut task_struct,
}
#[test]
fn bindgen_test_layout_rw_semaphore() {
    assert_eq!(
        ::std::mem::size_of::<rw_semaphore>(),
        40usize,
        concat!("Size of: ", stringify!(rw_semaphore))
    );
    assert_eq!(
        ::std::mem::align_of::<rw_semaphore>(),
        8usize,
        concat!("Alignment of ", stringify!(rw_semaphore))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rw_semaphore>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rw_semaphore>())).wait_list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(wait_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rw_semaphore>())).wait_lock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(wait_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rw_semaphore>())).osq as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(osq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rw_semaphore>())).owner as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(owner)
        )
    );
}
extern "C" {
    pub fn rwsem_down_read_failed(sem: *mut rw_semaphore) -> *mut rw_semaphore;
}
extern "C" {
    pub fn rwsem_down_read_failed_killable(sem: *mut rw_semaphore) -> *mut rw_semaphore;
}
extern "C" {
    pub fn rwsem_down_write_failed(sem: *mut rw_semaphore) -> *mut rw_semaphore;
}
extern "C" {
    pub fn rwsem_down_write_failed_killable(sem: *mut rw_semaphore) -> *mut rw_semaphore;
}
extern "C" {
    pub fn rwsem_wake(arg1: *mut rw_semaphore) -> *mut rw_semaphore;
}
extern "C" {
    pub fn rwsem_downgrade_wake(sem: *mut rw_semaphore) -> *mut rw_semaphore;
}
extern "C" {
    pub fn __init_rwsem(
        sem: *mut rw_semaphore,
        name: *const ::std::os::raw::c_char,
        key: *mut lock_class_key,
    );
}
extern "C" {
    pub fn down_read(sem: *mut rw_semaphore);
}
extern "C" {
    pub fn down_read_killable(sem: *mut rw_semaphore) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn down_read_trylock(sem: *mut rw_semaphore) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn down_write(sem: *mut rw_semaphore);
}
extern "C" {
    pub fn down_write_killable(sem: *mut rw_semaphore) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn down_write_trylock(sem: *mut rw_semaphore) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn up_read(sem: *mut rw_semaphore);
}
extern "C" {
    pub fn up_write(sem: *mut rw_semaphore);
}
extern "C" {
    pub fn downgrade_write(sem: *mut rw_semaphore);
}
extern "C" {
    pub fn call_rcu_bh(head: *mut callback_head, func: rcu_callback_t);
}
extern "C" {
    pub fn call_rcu_sched(head: *mut callback_head, func: rcu_callback_t);
}
extern "C" {
    pub fn synchronize_sched();
}
extern "C" {
    pub fn rcu_barrier_tasks();
}
extern "C" {
    pub fn rcu_init();
}
extern "C" {
    #[link_name = "\u{1}rcu_scheduler_active"]
    pub static mut rcu_scheduler_active: ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcu_sched_qs();
}
extern "C" {
    pub fn rcu_bh_qs();
}
extern "C" {
    pub fn rcu_check_callbacks(user: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rcu_report_dead(cpu: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rcu_cpu_starting(cpu: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rcutree_migrate_callbacks(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rcu_sysrq_start();
}
extern "C" {
    pub fn rcu_sysrq_end();
}
extern "C" {
    pub fn call_rcu_tasks(head: *mut callback_head, func: rcu_callback_t);
}
extern "C" {
    pub fn synchronize_rcu_tasks();
}
extern "C" {
    pub fn exit_tasks_rcu_start();
}
extern "C" {
    pub fn exit_tasks_rcu_finish();
}
extern "C" {
    pub fn rcu_note_context_switch(preempt: bool_);
}
extern "C" {
    pub fn rcu_needs_cpu(basem: __u64, nextevt: *mut __u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcu_cpu_stall_reset();
}
extern "C" {
    pub fn synchronize_rcu_bh();
}
extern "C" {
    pub fn synchronize_sched_expedited();
}
extern "C" {
    pub fn synchronize_rcu_expedited();
}
extern "C" {
    pub fn kfree_call_rcu(head: *mut callback_head, func: rcu_callback_t);
}
extern "C" {
    pub fn rcu_barrier();
}
extern "C" {
    pub fn rcu_barrier_bh();
}
extern "C" {
    pub fn rcu_barrier_sched();
}
extern "C" {
    pub fn get_state_synchronize_rcu() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn cond_synchronize_rcu(oldstate: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn get_state_synchronize_sched() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn cond_synchronize_sched(oldstate: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn rcu_idle_enter();
}
extern "C" {
    pub fn rcu_idle_exit();
}
extern "C" {
    pub fn rcu_irq_enter();
}
extern "C" {
    pub fn rcu_irq_exit();
}
extern "C" {
    pub fn rcu_irq_enter_irqson();
}
extern "C" {
    pub fn rcu_irq_exit_irqson();
}
extern "C" {
    pub fn rcu_irq_enter_disabled() -> bool_;
}
extern "C" {
    pub fn exit_rcu();
}
extern "C" {
    pub fn rcu_scheduler_starting();
}
extern "C" {
    pub fn rcu_end_inkernel_boot();
}
extern "C" {
    pub fn rcu_is_watching() -> bool_;
}
extern "C" {
    pub fn rcu_all_qs();
}
extern "C" {
    pub fn rcutree_prepare_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcutree_online_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcutree_offline_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcutree_dead_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcutree_dying_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timespec {
    pub tv_sec: __kernel_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timeval {
    pub tv_sec: __kernel_time_t,
    pub tv_usec: __kernel_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
pub type time64_t = __s64;
pub type timeu64_t = __u64;
extern "C" {
    pub fn set_normalized_timespec64(ts: *mut timespec, sec: time64_t, nsec: s64);
}
extern "C" {
    #[doc = " ns_to_timespec64 - Convert nanoseconds to timespec64"]
    #[doc = " @nsec:\tthe nanoseconds value to be converted"]
    #[doc = ""]
    #[doc = " Returns the timespec64 representation of the nsec parameter."]
    pub fn ns_to_timespec64(nsec: s64) -> timespec;
}
extern "C" {
    pub fn timespec64_add_safe(lhs: timespec, rhs: timespec) -> timespec;
}
extern "C" {
    #[link_name = "\u{1}sys_tz"]
    pub static mut sys_tz: timezone;
}
extern "C" {
    pub fn get_timespec64(ts: *mut timespec, uts: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn put_timespec64(ts: *const timespec, uts: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_itimerspec64(it: *mut itimerspec, uit: *const itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn put_itimerspec64(it: *const itimerspec, uit: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktime64(
        year: ::std::os::raw::c_uint,
        mon: ::std::os::raw::c_uint,
        day: ::std::os::raw::c_uint,
        hour: ::std::os::raw::c_uint,
        min: ::std::os::raw::c_uint,
        sec: ::std::os::raw::c_uint,
    ) -> time64_t;
}
extern "C" {
    pub fn do_setitimer(
        which: ::std::os::raw::c_int,
        value: *mut itimerval,
        ovalue: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_getitimer(
        which: ::std::os::raw::c_int,
        value: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_utimes(
        dfd: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        times: *mut timespec,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_long,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        40usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
}
extern "C" {
    pub fn time64_to_tm(totalsecs: time64_t, offset: ::std::os::raw::c_int, result: *mut tm);
}
extern "C" {
    pub fn timespec_trunc(t: timespec, gran: ::std::os::raw::c_uint) -> timespec;
}
extern "C" {
    #[doc = " ns_to_timeval - Convert nanoseconds to timeval"]
    #[doc = " @nsec:\tthe nanoseconds value to be converted"]
    #[doc = ""]
    #[doc = " Returns the timeval representation of the nsec parameter."]
    pub fn ns_to_timeval(nsec: s64) -> timeval;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timex {
    pub _bindgen_opaque_blob: [u64; 26usize],
}
#[test]
fn bindgen_test_layout_timex() {
    assert_eq!(
        ::std::mem::size_of::<timex>(),
        208usize,
        concat!("Size of: ", stringify!(timex))
    );
    assert_eq!(
        ::std::mem::align_of::<timex>(),
        8usize,
        concat!("Alignment of ", stringify!(timex))
    );
}
pub type cycles_t = ::std::os::raw::c_ulonglong;
extern "C" {
    #[link_name = "\u{1}cpu_khz"]
    pub static mut cpu_khz: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}tsc_khz"]
    pub static mut tsc_khz: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn disable_TSC();
}
extern "C" {
    pub fn convert_art_to_tsc(art: __u64) -> system_counterval_t;
}
extern "C" {
    pub fn tsc_early_delay_calibrate();
}
extern "C" {
    pub fn tsc_init();
}
extern "C" {
    pub fn mark_tsc_unstable(reason: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn unsynchronized_tsc() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn check_tsc_unstable() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mark_tsc_async_resets(reason: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn native_calibrate_cpu() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn native_calibrate_tsc() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn native_sched_clock_from_tsc(tsc: __u64) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "\u{1}tsc_clocksource_reliable"]
    pub static mut tsc_clocksource_reliable: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}tsc_async_resets"]
    pub static mut tsc_async_resets: bool_;
}
extern "C" {
    pub fn tsc_store_and_check_tsc_adjust(bootcpu: bool_) -> bool_;
}
extern "C" {
    pub fn tsc_verify_tsc_adjust(resume: bool_);
}
extern "C" {
    pub fn check_tsc_sync_source(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn check_tsc_sync_target();
}
extern "C" {
    pub fn notsc_setup(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tsc_save_sched_clock_state();
}
extern "C" {
    pub fn tsc_restore_sched_clock_state();
}
extern "C" {
    pub fn cpu_khz_from_msr() -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}tick_usec"]
    pub static mut tick_usec: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}tick_nsec"]
    pub static mut tick_nsec: ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn do_adjtimex(arg1: *mut timex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hardpps(arg1: *const timespec, arg2: *const timespec);
}
extern "C" {
    pub fn read_current_timer(timer_val: *mut ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ntp_notify_cmos_timer();
}
extern "C" {
    pub fn register_refined_jiffies(
        clock_tick_rate: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}jiffies_64"]
    pub static mut jiffies_64: __u64;
}
extern "C" {
    #[link_name = "\u{1}jiffies"]
    pub static mut jiffies: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}preset_lpj"]
    pub static mut preset_lpj: ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn jiffies_to_msecs(j: ::std::os::raw::c_ulong) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn jiffies_to_usecs(j: ::std::os::raw::c_ulong) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn jiffies64_to_nsecs(j: __u64) -> __u64;
}
extern "C" {
    pub fn __msecs_to_jiffies(m: ::std::os::raw::c_uint) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __usecs_to_jiffies(u: ::std::os::raw::c_uint) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn timespec64_to_jiffies(value: *const timespec) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn jiffies_to_timespec64(jiffies: ::std::os::raw::c_ulong, value: *mut timespec);
}
extern "C" {
    pub fn timeval_to_jiffies(value: *const timeval) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn jiffies_to_timeval(jiffies: ::std::os::raw::c_ulong, value: *mut timeval);
}
extern "C" {
    pub fn jiffies_to_clock_t(x: ::std::os::raw::c_ulong) -> clock_t;
}
extern "C" {
    pub fn clock_t_to_jiffies(x: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn jiffies_64_to_clock_t(x: __u64) -> __u64;
}
extern "C" {
    pub fn nsec_to_clock_t(x: __u64) -> __u64;
}
extern "C" {
    pub fn nsecs_to_jiffies64(n: __u64) -> __u64;
}
extern "C" {
    pub fn nsecs_to_jiffies(n: __u64) -> ::std::os::raw::c_ulong;
}
pub type ktime_t = s64;
extern "C" {
    pub fn ktime_add_safe(lhs: ktime_t, rhs: ktime_t) -> ktime_t;
}
extern "C" {
    pub fn timekeeping_init();
}
extern "C" {
    #[link_name = "\u{1}timekeeping_suspended"]
    pub static mut timekeeping_suspended: ::std::os::raw::c_int;
}
extern "C" {
    pub fn update_process_times(user: ::std::os::raw::c_int);
}
extern "C" {
    pub fn xtime_update(ticks: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn do_settimeofday64(ts: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_sys_settimeofday64(tv: *const timespec, tz: *const timezone)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn current_kernel_time64() -> timespec;
}
extern "C" {
    pub fn get_monotonic_coarse64() -> timespec;
}
extern "C" {
    pub fn getrawmonotonic64(ts: *mut timespec);
}
extern "C" {
    pub fn ktime_get_ts64(ts: *mut timespec);
}
extern "C" {
    pub fn ktime_get_seconds() -> time64_t;
}
extern "C" {
    pub fn ktime_get_real_seconds() -> time64_t;
}
extern "C" {
    pub fn __getnstimeofday64(tv: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getnstimeofday64(tv: *mut timespec);
}
extern "C" {
    pub fn getboottime64(ts: *mut timespec);
}
pub const tk_offsets_TK_OFFS_REAL: tk_offsets = 0;
pub const tk_offsets_TK_OFFS_BOOT: tk_offsets = 1;
pub const tk_offsets_TK_OFFS_TAI: tk_offsets = 2;
pub const tk_offsets_TK_OFFS_MAX: tk_offsets = 3;
pub type tk_offsets = u32;
extern "C" {
    pub fn ktime_get() -> ktime_t;
}
extern "C" {
    pub fn ktime_get_with_offset(offs: tk_offsets) -> ktime_t;
}
extern "C" {
    pub fn ktime_mono_to_any(tmono: ktime_t, offs: tk_offsets) -> ktime_t;
}
extern "C" {
    pub fn ktime_get_raw() -> ktime_t;
}
extern "C" {
    pub fn ktime_get_resolution_ns() -> u32;
}
extern "C" {
    pub fn ktime_get_mono_fast_ns() -> __u64;
}
extern "C" {
    pub fn ktime_get_raw_fast_ns() -> __u64;
}
extern "C" {
    pub fn ktime_get_boot_fast_ns() -> __u64;
}
extern "C" {
    pub fn ktime_get_real_fast_ns() -> __u64;
}
extern "C" {
    pub fn timekeeping_rtc_skipsuspend() -> bool_;
}
extern "C" {
    pub fn timekeeping_rtc_skipresume() -> bool_;
}
extern "C" {
    pub fn timekeeping_inject_sleeptime64(delta: *mut timespec);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct system_time_snapshot {
    pub cycles: __u64,
    pub real: ktime_t,
    pub raw: ktime_t,
    pub clock_was_set_seq: ::std::os::raw::c_uint,
    pub cs_was_changed_seq: u8,
}
#[test]
fn bindgen_test_layout_system_time_snapshot() {
    assert_eq!(
        ::std::mem::size_of::<system_time_snapshot>(),
        32usize,
        concat!("Size of: ", stringify!(system_time_snapshot))
    );
    assert_eq!(
        ::std::mem::align_of::<system_time_snapshot>(),
        8usize,
        concat!("Alignment of ", stringify!(system_time_snapshot))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<system_time_snapshot>())).cycles as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(system_time_snapshot),
            "::",
            stringify!(cycles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<system_time_snapshot>())).real as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(system_time_snapshot),
            "::",
            stringify!(real)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<system_time_snapshot>())).raw as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(system_time_snapshot),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<system_time_snapshot>())).clock_was_set_seq as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(system_time_snapshot),
            "::",
            stringify!(clock_was_set_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<system_time_snapshot>())).cs_was_changed_seq as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(system_time_snapshot),
            "::",
            stringify!(cs_was_changed_seq)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct system_device_crosststamp {
    pub device: ktime_t,
    pub sys_realtime: ktime_t,
    pub sys_monoraw: ktime_t,
}
#[test]
fn bindgen_test_layout_system_device_crosststamp() {
    assert_eq!(
        ::std::mem::size_of::<system_device_crosststamp>(),
        24usize,
        concat!("Size of: ", stringify!(system_device_crosststamp))
    );
    assert_eq!(
        ::std::mem::align_of::<system_device_crosststamp>(),
        8usize,
        concat!("Alignment of ", stringify!(system_device_crosststamp))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<system_device_crosststamp>())).device as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(system_device_crosststamp),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<system_device_crosststamp>())).sys_realtime as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(system_device_crosststamp),
            "::",
            stringify!(sys_realtime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<system_device_crosststamp>())).sys_monoraw as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(system_device_crosststamp),
            "::",
            stringify!(sys_monoraw)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct system_counterval_t {
    pub cycles: __u64,
    pub cs: *mut clocksource,
}
#[test]
fn bindgen_test_layout_system_counterval_t() {
    assert_eq!(
        ::std::mem::size_of::<system_counterval_t>(),
        16usize,
        concat!("Size of: ", stringify!(system_counterval_t))
    );
    assert_eq!(
        ::std::mem::align_of::<system_counterval_t>(),
        8usize,
        concat!("Alignment of ", stringify!(system_counterval_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<system_counterval_t>())).cycles as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(system_counterval_t),
            "::",
            stringify!(cycles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<system_counterval_t>())).cs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(system_counterval_t),
            "::",
            stringify!(cs)
        )
    );
}
extern "C" {
    pub fn get_device_system_crosststamp(
        get_time_fn: ::std::option::Option<
            unsafe extern "C" fn(
                device_time: *mut ktime_t,
                system_counterval: *mut system_counterval_t,
                ctx: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        ctx: *mut ::std::os::raw::c_void,
        history: *mut system_time_snapshot,
        xtstamp: *mut system_device_crosststamp,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ktime_get_snapshot(systime_snapshot: *mut system_time_snapshot);
}
extern "C" {
    #[link_name = "\u{1}persistent_clock_is_local"]
    pub static mut persistent_clock_is_local: ::std::os::raw::c_int;
}
extern "C" {
    pub fn read_persistent_clock64(ts: *mut timespec);
}
extern "C" {
    pub fn read_boot_clock64(ts: *mut timespec);
}
extern "C" {
    pub fn update_persistent_clock64(now: timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __current_kernel_time() -> timespec;
}
extern "C" {
    pub fn read_persistent_clock(ts: *mut timespec);
}
extern "C" {
    pub fn update_persistent_clock(now: timespec) -> ::std::os::raw::c_int;
}
pub const debug_obj_state_ODEBUG_STATE_NONE: debug_obj_state = 0;
pub const debug_obj_state_ODEBUG_STATE_INIT: debug_obj_state = 1;
pub const debug_obj_state_ODEBUG_STATE_INACTIVE: debug_obj_state = 2;
pub const debug_obj_state_ODEBUG_STATE_ACTIVE: debug_obj_state = 3;
pub const debug_obj_state_ODEBUG_STATE_DESTROYED: debug_obj_state = 4;
pub const debug_obj_state_ODEBUG_STATE_NOTAVAILABLE: debug_obj_state = 5;
pub const debug_obj_state_ODEBUG_STATE_MAX: debug_obj_state = 6;
pub type debug_obj_state = u32;
#[doc = " struct debug_obj - representaion of an tracked object"]
#[doc = " @node:\thlist node to link the object into the tracker list"]
#[doc = " @state:\ttracked object state"]
#[doc = " @astate:\tcurrent active state"]
#[doc = " @object:\tpointer to the real object"]
#[doc = " @descr:\tpointer to an object type specific debug description structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct debug_obj {
    pub node: hlist_node,
    pub state: debug_obj_state,
    pub astate: ::std::os::raw::c_uint,
    pub object: *mut ::std::os::raw::c_void,
    pub descr: *mut debug_obj_descr,
}
#[test]
fn bindgen_test_layout_debug_obj() {
    assert_eq!(
        ::std::mem::size_of::<debug_obj>(),
        40usize,
        concat!("Size of: ", stringify!(debug_obj))
    );
    assert_eq!(
        ::std::mem::align_of::<debug_obj>(),
        8usize,
        concat!("Alignment of ", stringify!(debug_obj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debug_obj>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debug_obj>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debug_obj>())).astate as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj),
            "::",
            stringify!(astate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debug_obj>())).object as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debug_obj>())).descr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj),
            "::",
            stringify!(descr)
        )
    );
}
#[doc = " struct debug_obj_descr - object type specific debug description structure"]
#[doc = ""]
#[doc = " @name:\t\tname of the object typee"]
#[doc = " @debug_hint:\t\tfunction returning address, which have associated"]
#[doc = "\t\t\tkernel symbol, to allow identify the object"]
#[doc = " @is_static_object:\treturn true if the obj is static, otherwise return false"]
#[doc = " @fixup_init:\t\tfixup function, which is called when the init check"]
#[doc = "\t\t\tfails. All fixup functions must return true if fixup"]
#[doc = "\t\t\twas successful, otherwise return false"]
#[doc = " @fixup_activate:\tfixup function, which is called when the activate check"]
#[doc = "\t\t\tfails"]
#[doc = " @fixup_destroy:\tfixup function, which is called when the destroy check"]
#[doc = "\t\t\tfails"]
#[doc = " @fixup_free:\t\tfixup function, which is called when the free check"]
#[doc = "\t\t\tfails"]
#[doc = " @fixup_assert_init:  fixup function, which is called when the assert_init"]
#[doc = "\t\t\tcheck fails"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct debug_obj_descr {
    pub name: *const ::std::os::raw::c_char,
    pub debug_hint: ::std::option::Option<
        unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
    >,
    pub is_static_object:
        ::std::option::Option<unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void) -> bool_>,
    pub fixup_init: ::std::option::Option<
        unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, state: debug_obj_state) -> bool_,
    >,
    pub fixup_activate: ::std::option::Option<
        unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, state: debug_obj_state) -> bool_,
    >,
    pub fixup_destroy: ::std::option::Option<
        unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, state: debug_obj_state) -> bool_,
    >,
    pub fixup_free: ::std::option::Option<
        unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, state: debug_obj_state) -> bool_,
    >,
    pub fixup_assert_init: ::std::option::Option<
        unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, state: debug_obj_state) -> bool_,
    >,
}
#[test]
fn bindgen_test_layout_debug_obj_descr() {
    assert_eq!(
        ::std::mem::size_of::<debug_obj_descr>(),
        64usize,
        concat!("Size of: ", stringify!(debug_obj_descr))
    );
    assert_eq!(
        ::std::mem::align_of::<debug_obj_descr>(),
        8usize,
        concat!("Alignment of ", stringify!(debug_obj_descr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debug_obj_descr>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj_descr),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debug_obj_descr>())).debug_hint as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj_descr),
            "::",
            stringify!(debug_hint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<debug_obj_descr>())).is_static_object as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj_descr),
            "::",
            stringify!(is_static_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debug_obj_descr>())).fixup_init as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj_descr),
            "::",
            stringify!(fixup_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debug_obj_descr>())).fixup_activate as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj_descr),
            "::",
            stringify!(fixup_activate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debug_obj_descr>())).fixup_destroy as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj_descr),
            "::",
            stringify!(fixup_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debug_obj_descr>())).fixup_free as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj_descr),
            "::",
            stringify!(fixup_free)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<debug_obj_descr>())).fixup_assert_init as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj_descr),
            "::",
            stringify!(fixup_assert_init)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tvec_base {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timer_list {
    pub entry: hlist_node,
    pub expires: ::std::os::raw::c_ulong,
    pub function: ::std::option::Option<unsafe extern "C" fn(arg1: *mut timer_list)>,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_timer_list() {
    assert_eq!(
        ::std::mem::size_of::<timer_list>(),
        40usize,
        concat!("Size of: ", stringify!(timer_list))
    );
    assert_eq!(
        ::std::mem::align_of::<timer_list>(),
        8usize,
        concat!("Alignment of ", stringify!(timer_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timer_list>())).entry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_list),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timer_list>())).expires as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_list),
            "::",
            stringify!(expires)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timer_list>())).function as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_list),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timer_list>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_list),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn init_timer_key(
        timer: *mut timer_list,
        func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut timer_list)>,
        flags: ::std::os::raw::c_uint,
        name: *const ::std::os::raw::c_char,
        key: *mut lock_class_key,
    );
}
extern "C" {
    pub fn add_timer_on(timer: *mut timer_list, cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn del_timer(timer: *mut timer_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mod_timer(
        timer: *mut timer_list,
        expires: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mod_timer_pending(
        timer: *mut timer_list,
        expires: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_reduce(
        timer: *mut timer_list,
        expires: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn add_timer(timer: *mut timer_list);
}
extern "C" {
    pub fn try_to_del_timer_sync(timer: *mut timer_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn del_timer_sync(timer: *mut timer_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn init_timers();
}
extern "C" {
    pub fn run_local_timers();
}
extern "C" {
    pub fn it_real_fn(arg1: *mut hrtimer) -> hrtimer_restart;
}
extern "C" {
    #[link_name = "\u{1}sysctl_timer_migration"]
    pub static mut sysctl_timer_migration: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn timer_migration_handler(
        table: *mut ctl_table,
        write: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __round_jiffies(
        j: ::std::os::raw::c_ulong,
        cpu: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __round_jiffies_relative(
        j: ::std::os::raw::c_ulong,
        cpu: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn round_jiffies(j: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn round_jiffies_relative(j: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __round_jiffies_up(
        j: ::std::os::raw::c_ulong,
        cpu: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __round_jiffies_up_relative(
        j: ::std::os::raw::c_ulong,
        cpu: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn round_jiffies_up(j: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn round_jiffies_up_relative(j: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn timers_prepare_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timers_dead_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct workqueue_struct {
    _unused: [u8; 0],
}
pub type work_func_t = ::std::option::Option<unsafe extern "C" fn(work: *mut work_struct)>;
extern "C" {
    pub fn delayed_work_timer_fn(t: *mut timer_list);
}
pub const WORK_STRUCT_PENDING_BIT: _bindgen_ty_9 = 0;
pub const WORK_STRUCT_DELAYED_BIT: _bindgen_ty_9 = 1;
pub const WORK_STRUCT_PWQ_BIT: _bindgen_ty_9 = 2;
pub const WORK_STRUCT_LINKED_BIT: _bindgen_ty_9 = 3;
pub const WORK_STRUCT_COLOR_SHIFT: _bindgen_ty_9 = 4;
pub const WORK_STRUCT_COLOR_BITS: _bindgen_ty_9 = 4;
pub const WORK_STRUCT_PENDING: _bindgen_ty_9 = 1;
pub const WORK_STRUCT_DELAYED: _bindgen_ty_9 = 2;
pub const WORK_STRUCT_PWQ: _bindgen_ty_9 = 4;
pub const WORK_STRUCT_LINKED: _bindgen_ty_9 = 8;
pub const WORK_STRUCT_STATIC: _bindgen_ty_9 = 0;
pub const WORK_NR_COLORS: _bindgen_ty_9 = 15;
pub const WORK_NO_COLOR: _bindgen_ty_9 = 15;
pub const WORK_CPU_UNBOUND: _bindgen_ty_9 = 8192;
pub const WORK_STRUCT_FLAG_BITS: _bindgen_ty_9 = 8;
pub const WORK_OFFQ_FLAG_BASE: _bindgen_ty_9 = 4;
pub const __WORK_OFFQ_CANCELING: _bindgen_ty_9 = 4;
pub const WORK_OFFQ_CANCELING: _bindgen_ty_9 = 16;
pub const WORK_OFFQ_FLAG_BITS: _bindgen_ty_9 = 1;
pub const WORK_OFFQ_POOL_SHIFT: _bindgen_ty_9 = 5;
pub const WORK_OFFQ_LEFT: _bindgen_ty_9 = 59;
pub const WORK_OFFQ_POOL_BITS: _bindgen_ty_9 = 31;
pub const WORK_OFFQ_POOL_NONE: _bindgen_ty_9 = 2147483647;
pub const WORK_STRUCT_FLAG_MASK: _bindgen_ty_9 = 255;
pub const WORK_STRUCT_WQ_DATA_MASK: _bindgen_ty_9 = -256;
pub const WORK_STRUCT_NO_POOL: _bindgen_ty_9 = 68719476704;
pub const WORK_BUSY_PENDING: _bindgen_ty_9 = 1;
pub const WORK_BUSY_RUNNING: _bindgen_ty_9 = 2;
pub const WORKER_DESC_LEN: _bindgen_ty_9 = 24;
pub type _bindgen_ty_9 = i64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct work_struct {
    pub data: atomic_long_t,
    pub entry: list_head,
    pub func: work_func_t,
}
#[test]
fn bindgen_test_layout_work_struct() {
    assert_eq!(
        ::std::mem::size_of::<work_struct>(),
        32usize,
        concat!("Size of: ", stringify!(work_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<work_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(work_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<work_struct>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(work_struct),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<work_struct>())).entry as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(work_struct),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<work_struct>())).func as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(work_struct),
            "::",
            stringify!(func)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct delayed_work {
    pub work: work_struct,
    pub timer: timer_list,
    pub wq: *mut workqueue_struct,
    pub cpu: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_delayed_work() {
    assert_eq!(
        ::std::mem::size_of::<delayed_work>(),
        88usize,
        concat!("Size of: ", stringify!(delayed_work))
    );
    assert_eq!(
        ::std::mem::align_of::<delayed_work>(),
        8usize,
        concat!("Alignment of ", stringify!(delayed_work))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<delayed_work>())).work as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(delayed_work),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<delayed_work>())).timer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(delayed_work),
            "::",
            stringify!(timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<delayed_work>())).wq as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(delayed_work),
            "::",
            stringify!(wq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<delayed_work>())).cpu as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(delayed_work),
            "::",
            stringify!(cpu)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_work {
    pub work: work_struct,
    pub rcu: callback_head,
    pub wq: *mut workqueue_struct,
}
#[test]
fn bindgen_test_layout_rcu_work() {
    assert_eq!(
        ::std::mem::size_of::<rcu_work>(),
        56usize,
        concat!("Size of: ", stringify!(rcu_work))
    );
    assert_eq!(
        ::std::mem::align_of::<rcu_work>(),
        8usize,
        concat!("Alignment of ", stringify!(rcu_work))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_work>())).work as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_work),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_work>())).rcu as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_work),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_work>())).wq as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_work),
            "::",
            stringify!(wq)
        )
    );
}
#[doc = " struct workqueue_attrs - A struct for workqueue attributes."]
#[doc = ""]
#[doc = " This can be used to change attributes of an unbound workqueue."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct workqueue_attrs {
    #[doc = " @nice: nice level"]
    pub nice: ::std::os::raw::c_int,
    #[doc = " @cpumask: allowed CPUs"]
    pub cpumask: cpumask_var_t,
    #[doc = " @no_numa: disable NUMA affinity"]
    #[doc = ""]
    #[doc = " Unlike other fields, ``no_numa`` isn't a property of a worker_pool. It"]
    #[doc = " only modifies how :c:func:`apply_workqueue_attrs` select pools and thus"]
    #[doc = " doesn't participate in pool hash calculations or equality comparisons."]
    pub no_numa: bool_,
}
#[test]
fn bindgen_test_layout_workqueue_attrs() {
    assert_eq!(
        ::std::mem::size_of::<workqueue_attrs>(),
        24usize,
        concat!("Size of: ", stringify!(workqueue_attrs))
    );
    assert_eq!(
        ::std::mem::align_of::<workqueue_attrs>(),
        8usize,
        concat!("Alignment of ", stringify!(workqueue_attrs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<workqueue_attrs>())).nice as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(workqueue_attrs),
            "::",
            stringify!(nice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<workqueue_attrs>())).cpumask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(workqueue_attrs),
            "::",
            stringify!(cpumask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<workqueue_attrs>())).no_numa as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(workqueue_attrs),
            "::",
            stringify!(no_numa)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct execute_work {
    pub work: work_struct,
}
#[test]
fn bindgen_test_layout_execute_work() {
    assert_eq!(
        ::std::mem::size_of::<execute_work>(),
        32usize,
        concat!("Size of: ", stringify!(execute_work))
    );
    assert_eq!(
        ::std::mem::align_of::<execute_work>(),
        8usize,
        concat!("Alignment of ", stringify!(execute_work))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<execute_work>())).work as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(execute_work),
            "::",
            stringify!(work)
        )
    );
}
pub const WQ_UNBOUND: _bindgen_ty_10 = 2;
pub const WQ_FREEZABLE: _bindgen_ty_10 = 4;
pub const WQ_MEM_RECLAIM: _bindgen_ty_10 = 8;
pub const WQ_HIGHPRI: _bindgen_ty_10 = 16;
pub const WQ_CPU_INTENSIVE: _bindgen_ty_10 = 32;
pub const WQ_SYSFS: _bindgen_ty_10 = 64;
pub const WQ_POWER_EFFICIENT: _bindgen_ty_10 = 128;
pub const __WQ_DRAINING: _bindgen_ty_10 = 65536;
pub const __WQ_ORDERED: _bindgen_ty_10 = 131072;
pub const __WQ_LEGACY: _bindgen_ty_10 = 262144;
pub const __WQ_ORDERED_EXPLICIT: _bindgen_ty_10 = 524288;
pub const WQ_MAX_ACTIVE: _bindgen_ty_10 = 512;
pub const WQ_MAX_UNBOUND_PER_CPU: _bindgen_ty_10 = 4;
pub const WQ_DFL_ACTIVE: _bindgen_ty_10 = 256;
pub type _bindgen_ty_10 = u32;
extern "C" {
    #[link_name = "\u{1}system_wq"]
    pub static mut system_wq: *mut workqueue_struct;
}
extern "C" {
    #[link_name = "\u{1}system_highpri_wq"]
    pub static mut system_highpri_wq: *mut workqueue_struct;
}
extern "C" {
    #[link_name = "\u{1}system_long_wq"]
    pub static mut system_long_wq: *mut workqueue_struct;
}
extern "C" {
    #[link_name = "\u{1}system_unbound_wq"]
    pub static mut system_unbound_wq: *mut workqueue_struct;
}
extern "C" {
    #[link_name = "\u{1}system_freezable_wq"]
    pub static mut system_freezable_wq: *mut workqueue_struct;
}
extern "C" {
    #[link_name = "\u{1}system_power_efficient_wq"]
    pub static mut system_power_efficient_wq: *mut workqueue_struct;
}
extern "C" {
    #[link_name = "\u{1}system_freezable_power_efficient_wq"]
    pub static mut system_freezable_power_efficient_wq: *mut workqueue_struct;
}
extern "C" {
    pub fn __alloc_workqueue_key(
        fmt: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
        max_active: ::std::os::raw::c_int,
        key: *mut lock_class_key,
        lock_name: *const ::std::os::raw::c_char,
        ...
    ) -> *mut workqueue_struct;
}
extern "C" {
    pub fn destroy_workqueue(wq: *mut workqueue_struct);
}
extern "C" {
    pub fn alloc_workqueue_attrs(gfp_mask: gfp_t) -> *mut workqueue_attrs;
}
extern "C" {
    pub fn free_workqueue_attrs(attrs: *mut workqueue_attrs);
}
extern "C" {
    pub fn apply_workqueue_attrs(
        wq: *mut workqueue_struct,
        attrs: *const workqueue_attrs,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn workqueue_set_unbound_cpumask(cpumask: cpumask_var_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn queue_work_on(
        cpu: ::std::os::raw::c_int,
        wq: *mut workqueue_struct,
        work: *mut work_struct,
    ) -> bool_;
}
extern "C" {
    pub fn queue_delayed_work_on(
        cpu: ::std::os::raw::c_int,
        wq: *mut workqueue_struct,
        work: *mut delayed_work,
        delay: ::std::os::raw::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn mod_delayed_work_on(
        cpu: ::std::os::raw::c_int,
        wq: *mut workqueue_struct,
        dwork: *mut delayed_work,
        delay: ::std::os::raw::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn queue_rcu_work(wq: *mut workqueue_struct, rwork: *mut rcu_work) -> bool_;
}
extern "C" {
    pub fn flush_workqueue(wq: *mut workqueue_struct);
}
extern "C" {
    pub fn drain_workqueue(wq: *mut workqueue_struct);
}
extern "C" {
    pub fn schedule_on_each_cpu(func: work_func_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execute_in_process_context(
        fn_: work_func_t,
        arg1: *mut execute_work,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flush_work(work: *mut work_struct) -> bool_;
}
extern "C" {
    pub fn cancel_work(work: *mut work_struct) -> bool_;
}
extern "C" {
    pub fn cancel_work_sync(work: *mut work_struct) -> bool_;
}
extern "C" {
    pub fn flush_delayed_work(dwork: *mut delayed_work) -> bool_;
}
extern "C" {
    pub fn cancel_delayed_work(dwork: *mut delayed_work) -> bool_;
}
extern "C" {
    pub fn cancel_delayed_work_sync(dwork: *mut delayed_work) -> bool_;
}
extern "C" {
    pub fn flush_rcu_work(rwork: *mut rcu_work) -> bool_;
}
extern "C" {
    pub fn workqueue_set_max_active(wq: *mut workqueue_struct, max_active: ::std::os::raw::c_int);
}
extern "C" {
    pub fn current_work() -> *mut work_struct;
}
extern "C" {
    pub fn current_is_workqueue_rescuer() -> bool_;
}
extern "C" {
    pub fn workqueue_congested(cpu: ::std::os::raw::c_int, wq: *mut workqueue_struct) -> bool_;
}
extern "C" {
    pub fn work_busy(work: *mut work_struct) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn set_worker_desc(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn print_worker_info(log_lvl: *const ::std::os::raw::c_char, task: *mut task_struct);
}
extern "C" {
    pub fn show_workqueue_state();
}
extern "C" {
    pub fn work_on_cpu(
        cpu: ::std::os::raw::c_int,
        fn_: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_long,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn work_on_cpu_safe(
        cpu: ::std::os::raw::c_int,
        fn_: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_long,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn freeze_workqueues_begin();
}
extern "C" {
    pub fn freeze_workqueues_busy() -> bool_;
}
extern "C" {
    pub fn thaw_workqueues();
}
extern "C" {
    pub fn workqueue_sysfs_register(wq: *mut workqueue_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn workqueue_prepare_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn workqueue_online_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn workqueue_offline_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn workqueue_init_early() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn workqueue_init() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_cblist {
    pub head: *mut callback_head,
    pub tail: *mut *mut callback_head,
    pub len: ::std::os::raw::c_long,
    pub len_lazy: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rcu_cblist() {
    assert_eq!(
        ::std::mem::size_of::<rcu_cblist>(),
        32usize,
        concat!("Size of: ", stringify!(rcu_cblist))
    );
    assert_eq!(
        ::std::mem::align_of::<rcu_cblist>(),
        8usize,
        concat!("Alignment of ", stringify!(rcu_cblist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_cblist>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_cblist),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_cblist>())).tail as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_cblist),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_cblist>())).len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_cblist),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_cblist>())).len_lazy as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_cblist),
            "::",
            stringify!(len_lazy)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_segcblist {
    pub head: *mut callback_head,
    pub tails: [*mut *mut callback_head; 4usize],
    pub gp_seq: [::std::os::raw::c_ulong; 4usize],
    pub len: ::std::os::raw::c_long,
    pub len_lazy: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rcu_segcblist() {
    assert_eq!(
        ::std::mem::size_of::<rcu_segcblist>(),
        88usize,
        concat!("Size of: ", stringify!(rcu_segcblist))
    );
    assert_eq!(
        ::std::mem::align_of::<rcu_segcblist>(),
        8usize,
        concat!("Alignment of ", stringify!(rcu_segcblist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_segcblist>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_segcblist),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_segcblist>())).tails as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_segcblist),
            "::",
            stringify!(tails)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_segcblist>())).gp_seq as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_segcblist),
            "::",
            stringify!(gp_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_segcblist>())).len as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_segcblist),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_segcblist>())).len_lazy as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_segcblist),
            "::",
            stringify!(len_lazy)
        )
    );
}
extern "C" {
    pub fn init_srcu_struct(sp: *mut srcu_struct) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct completion {
    pub done: ::std::os::raw::c_uint,
    pub wait: wait_queue_head_t,
}
#[test]
fn bindgen_test_layout_completion() {
    assert_eq!(
        ::std::mem::size_of::<completion>(),
        32usize,
        concat!("Size of: ", stringify!(completion))
    );
    assert_eq!(
        ::std::mem::align_of::<completion>(),
        8usize,
        concat!("Alignment of ", stringify!(completion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<completion>())).done as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(completion),
            "::",
            stringify!(done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<completion>())).wait as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(completion),
            "::",
            stringify!(wait)
        )
    );
}
extern "C" {
    pub fn wait_for_completion(arg1: *mut completion);
}
extern "C" {
    pub fn wait_for_completion_io(arg1: *mut completion);
}
extern "C" {
    pub fn wait_for_completion_interruptible(x: *mut completion) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait_for_completion_killable(x: *mut completion) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait_for_completion_timeout(
        x: *mut completion,
        timeout: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wait_for_completion_io_timeout(
        x: *mut completion,
        timeout: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wait_for_completion_interruptible_timeout(
        x: *mut completion,
        timeout: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wait_for_completion_killable_timeout(
        x: *mut completion,
        timeout: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn try_wait_for_completion(x: *mut completion) -> bool_;
}
extern "C" {
    pub fn completion_done(x: *mut completion) -> bool_;
}
extern "C" {
    pub fn complete(arg1: *mut completion);
}
extern "C" {
    pub fn complete_all(arg1: *mut completion);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_data {
    pub srcu_lock_count: [::std::os::raw::c_ulong; 2usize],
    pub srcu_unlock_count: [::std::os::raw::c_ulong; 2usize],
    pub __bindgen_padding_0: [u32; 8usize],
    pub lock: spinlock_t,
    pub srcu_cblist: rcu_segcblist,
    pub srcu_gp_seq_needed: ::std::os::raw::c_ulong,
    pub srcu_gp_seq_needed_exp: ::std::os::raw::c_ulong,
    pub srcu_cblist_invoking: bool_,
    pub work: delayed_work,
    pub srcu_barrier_head: callback_head,
    pub mynode: *mut srcu_node,
    pub grpmask: ::std::os::raw::c_ulong,
    pub cpu: ::std::os::raw::c_int,
    pub sp: *mut srcu_struct,
}
#[test]
fn bindgen_test_layout_srcu_data() {
    assert_eq!(
        ::std::mem::size_of::<srcu_data>(),
        320usize,
        concat!("Size of: ", stringify!(srcu_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).srcu_lock_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_lock_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).srcu_unlock_count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_unlock_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).lock as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).srcu_cblist as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_cblist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).srcu_gp_seq_needed as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_gp_seq_needed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srcu_data>())).srcu_gp_seq_needed_exp as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_gp_seq_needed_exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).srcu_cblist_invoking as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_cblist_invoking)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).work as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).srcu_barrier_head as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_barrier_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).mynode as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(mynode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).grpmask as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(grpmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).cpu as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).sp as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(sp)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_node {
    pub lock: spinlock_t,
    pub srcu_have_cbs: [::std::os::raw::c_ulong; 4usize],
    pub srcu_data_have_cbs: [::std::os::raw::c_ulong; 4usize],
    pub srcu_gp_seq_needed_exp: ::std::os::raw::c_ulong,
    pub srcu_parent: *mut srcu_node,
    pub grplo: ::std::os::raw::c_int,
    pub grphi: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_srcu_node() {
    assert_eq!(
        ::std::mem::size_of::<srcu_node>(),
        96usize,
        concat!("Size of: ", stringify!(srcu_node))
    );
    assert_eq!(
        ::std::mem::align_of::<srcu_node>(),
        8usize,
        concat!("Alignment of ", stringify!(srcu_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_node>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_node>())).srcu_have_cbs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(srcu_have_cbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_node>())).srcu_data_have_cbs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(srcu_data_have_cbs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srcu_node>())).srcu_gp_seq_needed_exp as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(srcu_gp_seq_needed_exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_node>())).srcu_parent as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(srcu_parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_node>())).grplo as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(grplo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_node>())).grphi as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(grphi)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_struct {
    pub node: [srcu_node; 521usize],
    pub level: [*mut srcu_node; 4usize],
    pub srcu_cb_mutex: mutex,
    pub lock: spinlock_t,
    pub srcu_gp_mutex: mutex,
    pub srcu_idx: ::std::os::raw::c_uint,
    pub srcu_gp_seq: ::std::os::raw::c_ulong,
    pub srcu_gp_seq_needed: ::std::os::raw::c_ulong,
    pub srcu_gp_seq_needed_exp: ::std::os::raw::c_ulong,
    pub srcu_last_gp_end: ::std::os::raw::c_ulong,
    pub sda: *mut srcu_data,
    pub srcu_barrier_seq: ::std::os::raw::c_ulong,
    pub srcu_barrier_mutex: mutex,
    pub srcu_barrier_completion: completion,
    pub srcu_barrier_cpu_cnt: atomic_t,
    pub work: delayed_work,
}
#[test]
fn bindgen_test_layout_srcu_struct() {
    assert_eq!(
        ::std::mem::size_of::<srcu_struct>(),
        50336usize,
        concat!("Size of: ", stringify!(srcu_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<srcu_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(srcu_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).level as *const _ as usize },
        50016usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).srcu_cb_mutex as *const _ as usize },
        50048usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_cb_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).lock as *const _ as usize },
        50080usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).srcu_gp_mutex as *const _ as usize },
        50088usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_gp_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).srcu_idx as *const _ as usize },
        50120usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).srcu_gp_seq as *const _ as usize },
        50128usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_gp_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).srcu_gp_seq_needed as *const _ as usize },
        50136usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_gp_seq_needed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srcu_struct>())).srcu_gp_seq_needed_exp as *const _ as usize
        },
        50144usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_gp_seq_needed_exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).srcu_last_gp_end as *const _ as usize },
        50152usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_last_gp_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).sda as *const _ as usize },
        50160usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(sda)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).srcu_barrier_seq as *const _ as usize },
        50168usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_barrier_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).srcu_barrier_mutex as *const _ as usize },
        50176usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_barrier_mutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srcu_struct>())).srcu_barrier_completion as *const _ as usize
        },
        50208usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_barrier_completion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srcu_struct>())).srcu_barrier_cpu_cnt as *const _ as usize
        },
        50240usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_barrier_cpu_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).work as *const _ as usize },
        50248usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(work)
        )
    );
}
extern "C" {
    pub fn synchronize_srcu_expedited(sp: *mut srcu_struct);
}
extern "C" {
    pub fn srcu_barrier(sp: *mut srcu_struct);
}
extern "C" {
    pub fn srcu_torture_stats_print(
        sp: *mut srcu_struct,
        tt: *mut ::std::os::raw::c_char,
        tf: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn call_srcu(
        sp: *mut srcu_struct,
        head: *mut callback_head,
        func: ::std::option::Option<unsafe extern "C" fn(head: *mut callback_head)>,
    );
}
extern "C" {
    pub fn cleanup_srcu_struct(sp: *mut srcu_struct);
}
extern "C" {
    pub fn __srcu_read_lock(sp: *mut srcu_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __srcu_read_unlock(sp: *mut srcu_struct, idx: ::std::os::raw::c_int);
}
extern "C" {
    pub fn synchronize_srcu(sp: *mut srcu_struct);
}
pub type notifier_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        nb: *mut notifier_block,
        action: ::std::os::raw::c_ulong,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct notifier_block {
    pub notifier_call: notifier_fn_t,
    pub next: *mut notifier_block,
    pub priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_notifier_block() {
    assert_eq!(
        ::std::mem::size_of::<notifier_block>(),
        24usize,
        concat!("Size of: ", stringify!(notifier_block))
    );
    assert_eq!(
        ::std::mem::align_of::<notifier_block>(),
        8usize,
        concat!("Alignment of ", stringify!(notifier_block))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<notifier_block>())).notifier_call as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(notifier_block),
            "::",
            stringify!(notifier_call)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<notifier_block>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(notifier_block),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<notifier_block>())).priority as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(notifier_block),
            "::",
            stringify!(priority)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blocking_notifier_head {
    pub rwsem: rw_semaphore,
    pub head: *mut notifier_block,
}
#[test]
fn bindgen_test_layout_blocking_notifier_head() {
    assert_eq!(
        ::std::mem::size_of::<blocking_notifier_head>(),
        48usize,
        concat!("Size of: ", stringify!(blocking_notifier_head))
    );
    assert_eq!(
        ::std::mem::align_of::<blocking_notifier_head>(),
        8usize,
        concat!("Alignment of ", stringify!(blocking_notifier_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<blocking_notifier_head>())).rwsem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blocking_notifier_head),
            "::",
            stringify!(rwsem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<blocking_notifier_head>())).head as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(blocking_notifier_head),
            "::",
            stringify!(head)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raw_notifier_head {
    pub head: *mut notifier_block,
}
#[test]
fn bindgen_test_layout_raw_notifier_head() {
    assert_eq!(
        ::std::mem::size_of::<raw_notifier_head>(),
        8usize,
        concat!("Size of: ", stringify!(raw_notifier_head))
    );
    assert_eq!(
        ::std::mem::align_of::<raw_notifier_head>(),
        8usize,
        concat!("Alignment of ", stringify!(raw_notifier_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raw_notifier_head>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raw_notifier_head),
            "::",
            stringify!(head)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_notifier_head {
    pub mutex: mutex,
    pub srcu: srcu_struct,
    pub head: *mut notifier_block,
}
#[test]
fn bindgen_test_layout_srcu_notifier_head() {
    assert_eq!(
        ::std::mem::size_of::<srcu_notifier_head>(),
        50376usize,
        concat!("Size of: ", stringify!(srcu_notifier_head))
    );
    assert_eq!(
        ::std::mem::align_of::<srcu_notifier_head>(),
        8usize,
        concat!("Alignment of ", stringify!(srcu_notifier_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_notifier_head>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_notifier_head),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_notifier_head>())).srcu as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_notifier_head),
            "::",
            stringify!(srcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_notifier_head>())).head as *const _ as usize },
        50368usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_notifier_head),
            "::",
            stringify!(head)
        )
    );
}
extern "C" {
    pub fn srcu_init_notifier_head(nh: *mut srcu_notifier_head);
}
extern "C" {
    pub fn atomic_notifier_chain_register(
        nh: *mut atomic_notifier_head,
        nb: *mut notifier_block,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blocking_notifier_chain_register(
        nh: *mut blocking_notifier_head,
        nb: *mut notifier_block,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raw_notifier_chain_register(
        nh: *mut raw_notifier_head,
        nb: *mut notifier_block,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srcu_notifier_chain_register(
        nh: *mut srcu_notifier_head,
        nb: *mut notifier_block,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blocking_notifier_chain_cond_register(
        nh: *mut blocking_notifier_head,
        nb: *mut notifier_block,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_notifier_chain_unregister(
        nh: *mut atomic_notifier_head,
        nb: *mut notifier_block,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blocking_notifier_chain_unregister(
        nh: *mut blocking_notifier_head,
        nb: *mut notifier_block,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raw_notifier_chain_unregister(
        nh: *mut raw_notifier_head,
        nb: *mut notifier_block,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srcu_notifier_chain_unregister(
        nh: *mut srcu_notifier_head,
        nb: *mut notifier_block,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_notifier_call_chain(
        nh: *mut atomic_notifier_head,
        val: ::std::os::raw::c_ulong,
        v: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __atomic_notifier_call_chain(
        nh: *mut atomic_notifier_head,
        val: ::std::os::raw::c_ulong,
        v: *mut ::std::os::raw::c_void,
        nr_to_call: ::std::os::raw::c_int,
        nr_calls: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blocking_notifier_call_chain(
        nh: *mut blocking_notifier_head,
        val: ::std::os::raw::c_ulong,
        v: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __blocking_notifier_call_chain(
        nh: *mut blocking_notifier_head,
        val: ::std::os::raw::c_ulong,
        v: *mut ::std::os::raw::c_void,
        nr_to_call: ::std::os::raw::c_int,
        nr_calls: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raw_notifier_call_chain(
        nh: *mut raw_notifier_head,
        val: ::std::os::raw::c_ulong,
        v: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __raw_notifier_call_chain(
        nh: *mut raw_notifier_head,
        val: ::std::os::raw::c_ulong,
        v: *mut ::std::os::raw::c_void,
        nr_to_call: ::std::os::raw::c_int,
        nr_calls: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srcu_notifier_call_chain(
        nh: *mut srcu_notifier_head,
        val: ::std::os::raw::c_ulong,
        v: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __srcu_notifier_call_chain(
        nh: *mut srcu_notifier_head,
        val: ::std::os::raw::c_ulong,
        v: *mut ::std::os::raw::c_void,
        nr_to_call: ::std::os::raw::c_int,
        nr_calls: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}reboot_notifier_list"]
    pub static mut reboot_notifier_list: blocking_notifier_head;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct memory_block {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct resource {
    _unused: [u8; 0],
}
pub const MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE: _bindgen_ty_11 = 12;
pub const SECTION_INFO: _bindgen_ty_11 = 12;
pub const MIX_SECTION_INFO: _bindgen_ty_11 = 13;
pub const NODE_INFO: _bindgen_ty_11 = 14;
pub const MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE: _bindgen_ty_11 = 14;
pub type _bindgen_ty_11 = u32;
pub const MMOP_OFFLINE: _bindgen_ty_12 = -1;
pub const MMOP_ONLINE_KEEP: _bindgen_ty_12 = 0;
pub const MMOP_ONLINE_KERNEL: _bindgen_ty_12 = 1;
pub const MMOP_ONLINE_MOVABLE: _bindgen_ty_12 = 2;
pub type _bindgen_ty_12 = i32;
extern "C" {
    pub fn zone_grow_free_lists(
        zone: *mut zone,
        new_nr_pages: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zone_grow_waitqueues(
        zone: *mut zone,
        nr_pages: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn add_one_highpage(
        page: *mut page,
        pfn: ::std::os::raw::c_int,
        bad_ppro: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn online_pages(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn test_pages_in_a_zone(
        start_pfn: ::std::os::raw::c_ulong,
        end_pfn: ::std::os::raw::c_ulong,
        valid_start: *mut ::std::os::raw::c_ulong,
        valid_end: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __offline_isolated_pages(arg1: ::std::os::raw::c_ulong, arg2: ::std::os::raw::c_ulong);
}
pub type online_page_callback_t = ::std::option::Option<unsafe extern "C" fn(page: *mut page)>;
extern "C" {
    pub fn set_online_page_callback(callback: online_page_callback_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn restore_online_page_callback(callback: online_page_callback_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __online_page_set_limits(page: *mut page);
}
extern "C" {
    pub fn __online_page_increment_counters(page: *mut page);
}
extern "C" {
    pub fn __online_page_free(page: *mut page);
}
extern "C" {
    pub fn try_online_node(nid: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}memhp_auto_online"]
    pub static mut memhp_auto_online: bool_;
}
extern "C" {
    #[link_name = "\u{1}movable_node_enabled"]
    pub static mut movable_node_enabled: bool_;
}
extern "C" {
    pub fn is_pageblock_removable_nolock(page: *mut page) -> bool_;
}
extern "C" {
    pub fn arch_remove_memory(start: __u64, size: __u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __remove_pages(
        zone: *mut zone,
        start_pfn: ::std::os::raw::c_ulong,
        nr_pages: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __add_pages(
        nid: ::std::os::raw::c_int,
        start_pfn: ::std::os::raw::c_ulong,
        nr_pages: ::std::os::raw::c_ulong,
        want_memblock: bool_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn add_pages(
        nid: ::std::os::raw::c_int,
        start_pfn: ::std::os::raw::c_ulong,
        nr_pages: ::std::os::raw::c_ulong,
        want_memblock: bool_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memory_add_physaddr_to_nid(start: __u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}node_data"]
    pub static mut node_data: [*mut pg_data_t; 0usize];
}
extern "C" {
    pub fn register_page_bootmem_info_node(pgdat: *mut pglist_data);
}
extern "C" {
    pub fn put_page_bootmem(page: *mut page);
}
extern "C" {
    pub fn get_page_bootmem(
        ingo: ::std::os::raw::c_ulong,
        page: *mut page,
        type_: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn get_online_mems();
}
extern "C" {
    pub fn put_online_mems();
}
extern "C" {
    pub fn mem_hotplug_begin();
}
extern "C" {
    pub fn mem_hotplug_done();
}
extern "C" {
    pub fn set_default_mem_hotplug_zone(zone: zone_type);
}
extern "C" {
    pub fn set_zone_contiguous(zone: *mut zone);
}
extern "C" {
    pub fn clear_zone_contiguous(zone: *mut zone);
}
extern "C" {
    pub fn is_mem_section_removable(
        pfn: ::std::os::raw::c_ulong,
        nr_pages: ::std::os::raw::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn try_offline_node(nid: ::std::os::raw::c_int);
}
extern "C" {
    pub fn offline_pages(
        start_pfn: ::std::os::raw::c_ulong,
        nr_pages: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove_memory(nid: ::std::os::raw::c_int, start: __u64, size: __u64);
}
extern "C" {
    pub fn walk_memory_range(
        start_pfn: ::std::os::raw::c_ulong,
        end_pfn: ::std::os::raw::c_ulong,
        arg: *mut ::std::os::raw::c_void,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut memory_block,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __add_memory(
        nid: ::std::os::raw::c_int,
        start: __u64,
        size: __u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn add_memory(
        nid: ::std::os::raw::c_int,
        start: __u64,
        size: __u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn add_memory_resource(
        nid: ::std::os::raw::c_int,
        resource: *mut resource,
        online: bool_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arch_add_memory(
        nid: ::std::os::raw::c_int,
        start: __u64,
        size: __u64,
        want_memblock: bool_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn move_pfn_range_to_zone(
        zone: *mut zone,
        start_pfn: ::std::os::raw::c_ulong,
        nr_pages: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn is_memblock_offlined(mem: *mut memory_block) -> bool_;
}
extern "C" {
    pub fn sparse_add_one_section(
        pgdat: *mut pglist_data,
        start_pfn: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sparse_remove_one_section(
        zone: *mut zone,
        ms: *mut mem_section,
        map_offset: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn sparse_decode_mem_map(
        coded_mem_map: ::std::os::raw::c_ulong,
        pnum: ::std::os::raw::c_ulong,
    ) -> *mut page;
}
extern "C" {
    pub fn allow_online_pfn_range(
        nid: ::std::os::raw::c_int,
        pfn: ::std::os::raw::c_ulong,
        nr_pages: ::std::os::raw::c_ulong,
        online_type: ::std::os::raw::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn zone_for_pfn_range(
        online_type: ::std::os::raw::c_int,
        nid: ::std::os::raw::c_int,
        start_pfn: ::std::os::raw::c_uint,
        nr_pages: ::std::os::raw::c_ulong,
    ) -> *mut zone;
}
extern "C" {
    pub fn build_all_zonelists(pgdat: *mut pg_data_t);
}
extern "C" {
    pub fn wakeup_kswapd(zone: *mut zone, order: ::std::os::raw::c_int, classzone_idx: zone_type);
}
extern "C" {
    pub fn __zone_watermark_ok(
        z: *mut zone,
        order: ::std::os::raw::c_uint,
        mark: ::std::os::raw::c_ulong,
        classzone_idx: ::std::os::raw::c_int,
        alloc_flags: ::std::os::raw::c_uint,
        free_pages: ::std::os::raw::c_long,
    ) -> bool_;
}
extern "C" {
    pub fn zone_watermark_ok(
        z: *mut zone,
        order: ::std::os::raw::c_uint,
        mark: ::std::os::raw::c_ulong,
        classzone_idx: ::std::os::raw::c_int,
        alloc_flags: ::std::os::raw::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn zone_watermark_ok_safe(
        z: *mut zone,
        order: ::std::os::raw::c_uint,
        mark: ::std::os::raw::c_ulong,
        classzone_idx: ::std::os::raw::c_int,
    ) -> bool_;
}
pub const memmap_context_MEMMAP_EARLY: memmap_context = 0;
pub const memmap_context_MEMMAP_HOTPLUG: memmap_context = 1;
pub type memmap_context = u32;
extern "C" {
    pub fn init_currently_empty_zone(
        zone: *mut zone,
        start_pfn: ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn lruvec_init(lruvec: *mut lruvec);
}
extern "C" {
    pub fn lruvec_lru_size(
        lruvec: *mut lruvec,
        lru: lru_list,
        zone_idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn memory_present(
        nid: ::std::os::raw::c_int,
        start: ::std::os::raw::c_ulong,
        end: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    #[link_name = "\u{1}movable_zone"]
    pub static mut movable_zone: ::std::os::raw::c_int;
}
extern "C" {
    pub fn min_free_kbytes_sysctl_handler(
        arg1: *mut ctl_table,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn watermark_scale_factor_sysctl_handler(
        arg1: *mut ctl_table,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}sysctl_lowmem_reserve_ratio"]
    pub static mut sysctl_lowmem_reserve_ratio: [::std::os::raw::c_int; 4usize];
}
extern "C" {
    pub fn lowmem_reserve_ratio_sysctl_handler(
        arg1: *mut ctl_table,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn percpu_pagelist_fraction_sysctl_handler(
        arg1: *mut ctl_table,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sysctl_min_unmapped_ratio_sysctl_handler(
        arg1: *mut ctl_table,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sysctl_min_slab_ratio_sysctl_handler(
        arg1: *mut ctl_table,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_zonelist_order_handler(
        arg1: *mut ctl_table,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}numa_zonelist_order"]
    pub static mut numa_zonelist_order: [::std::os::raw::c_char; 0usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mpf_intel {
    pub signature: [::std::os::raw::c_char; 4usize],
    pub physptr: ::std::os::raw::c_uint,
    pub length: ::std::os::raw::c_uchar,
    pub specification: ::std::os::raw::c_uchar,
    pub checksum: ::std::os::raw::c_uchar,
    pub feature1: ::std::os::raw::c_uchar,
    pub feature2: ::std::os::raw::c_uchar,
    pub feature3: ::std::os::raw::c_uchar,
    pub feature4: ::std::os::raw::c_uchar,
    pub feature5: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_mpf_intel() {
    assert_eq!(
        ::std::mem::size_of::<mpf_intel>(),
        16usize,
        concat!("Size of: ", stringify!(mpf_intel))
    );
    assert_eq!(
        ::std::mem::align_of::<mpf_intel>(),
        4usize,
        concat!("Alignment of ", stringify!(mpf_intel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpf_intel>())).signature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpf_intel),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpf_intel>())).physptr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpf_intel),
            "::",
            stringify!(physptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpf_intel>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpf_intel),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpf_intel>())).specification as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(mpf_intel),
            "::",
            stringify!(specification)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpf_intel>())).checksum as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(mpf_intel),
            "::",
            stringify!(checksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpf_intel>())).feature1 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(mpf_intel),
            "::",
            stringify!(feature1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpf_intel>())).feature2 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mpf_intel),
            "::",
            stringify!(feature2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpf_intel>())).feature3 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(mpf_intel),
            "::",
            stringify!(feature3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpf_intel>())).feature4 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(mpf_intel),
            "::",
            stringify!(feature4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpf_intel>())).feature5 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(mpf_intel),
            "::",
            stringify!(feature5)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mpc_table {
    pub signature: [::std::os::raw::c_char; 4usize],
    pub length: ::std::os::raw::c_ushort,
    pub spec: ::std::os::raw::c_char,
    pub checksum: ::std::os::raw::c_char,
    pub oem: [::std::os::raw::c_char; 8usize],
    pub productid: [::std::os::raw::c_char; 12usize],
    pub oemptr: ::std::os::raw::c_uint,
    pub oemsize: ::std::os::raw::c_ushort,
    pub oemcount: ::std::os::raw::c_ushort,
    pub lapic: ::std::os::raw::c_uint,
    pub reserved: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_mpc_table() {
    assert_eq!(
        ::std::mem::size_of::<mpc_table>(),
        44usize,
        concat!("Size of: ", stringify!(mpc_table))
    );
    assert_eq!(
        ::std::mem::align_of::<mpc_table>(),
        4usize,
        concat!("Alignment of ", stringify!(mpc_table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_table>())).signature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_table),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_table>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_table),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_table>())).spec as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_table),
            "::",
            stringify!(spec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_table>())).checksum as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_table),
            "::",
            stringify!(checksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_table>())).oem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_table),
            "::",
            stringify!(oem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_table>())).productid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_table),
            "::",
            stringify!(productid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_table>())).oemptr as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_table),
            "::",
            stringify!(oemptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_table>())).oemsize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_table),
            "::",
            stringify!(oemsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_table>())).oemcount as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_table),
            "::",
            stringify!(oemcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_table>())).lapic as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_table),
            "::",
            stringify!(lapic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_table>())).reserved as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_table),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mpc_cpu {
    pub type_: ::std::os::raw::c_uchar,
    pub apicid: ::std::os::raw::c_uchar,
    pub apicver: ::std::os::raw::c_uchar,
    pub cpuflag: ::std::os::raw::c_uchar,
    pub cpufeature: ::std::os::raw::c_uint,
    pub featureflag: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout_mpc_cpu() {
    assert_eq!(
        ::std::mem::size_of::<mpc_cpu>(),
        20usize,
        concat!("Size of: ", stringify!(mpc_cpu))
    );
    assert_eq!(
        ::std::mem::align_of::<mpc_cpu>(),
        4usize,
        concat!("Alignment of ", stringify!(mpc_cpu))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_cpu>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_cpu),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_cpu>())).apicid as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_cpu),
            "::",
            stringify!(apicid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_cpu>())).apicver as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_cpu),
            "::",
            stringify!(apicver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_cpu>())).cpuflag as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_cpu),
            "::",
            stringify!(cpuflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_cpu>())).cpufeature as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_cpu),
            "::",
            stringify!(cpufeature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_cpu>())).featureflag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_cpu),
            "::",
            stringify!(featureflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_cpu>())).reserved as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_cpu),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mpc_bus {
    pub type_: ::std::os::raw::c_uchar,
    pub busid: ::std::os::raw::c_uchar,
    pub bustype: [::std::os::raw::c_uchar; 6usize],
}
#[test]
fn bindgen_test_layout_mpc_bus() {
    assert_eq!(
        ::std::mem::size_of::<mpc_bus>(),
        8usize,
        concat!("Size of: ", stringify!(mpc_bus))
    );
    assert_eq!(
        ::std::mem::align_of::<mpc_bus>(),
        1usize,
        concat!("Alignment of ", stringify!(mpc_bus))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_bus>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_bus),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_bus>())).busid as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_bus),
            "::",
            stringify!(busid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_bus>())).bustype as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_bus),
            "::",
            stringify!(bustype)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mpc_ioapic {
    pub type_: ::std::os::raw::c_uchar,
    pub apicid: ::std::os::raw::c_uchar,
    pub apicver: ::std::os::raw::c_uchar,
    pub flags: ::std::os::raw::c_uchar,
    pub apicaddr: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_mpc_ioapic() {
    assert_eq!(
        ::std::mem::size_of::<mpc_ioapic>(),
        8usize,
        concat!("Size of: ", stringify!(mpc_ioapic))
    );
    assert_eq!(
        ::std::mem::align_of::<mpc_ioapic>(),
        4usize,
        concat!("Alignment of ", stringify!(mpc_ioapic))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_ioapic>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_ioapic),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_ioapic>())).apicid as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_ioapic),
            "::",
            stringify!(apicid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_ioapic>())).apicver as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_ioapic),
            "::",
            stringify!(apicver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_ioapic>())).flags as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_ioapic),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_ioapic>())).apicaddr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_ioapic),
            "::",
            stringify!(apicaddr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mpc_intsrc {
    pub type_: ::std::os::raw::c_uchar,
    pub irqtype: ::std::os::raw::c_uchar,
    pub irqflag: ::std::os::raw::c_ushort,
    pub srcbus: ::std::os::raw::c_uchar,
    pub srcbusirq: ::std::os::raw::c_uchar,
    pub dstapic: ::std::os::raw::c_uchar,
    pub dstirq: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_mpc_intsrc() {
    assert_eq!(
        ::std::mem::size_of::<mpc_intsrc>(),
        8usize,
        concat!("Size of: ", stringify!(mpc_intsrc))
    );
    assert_eq!(
        ::std::mem::align_of::<mpc_intsrc>(),
        2usize,
        concat!("Alignment of ", stringify!(mpc_intsrc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_intsrc>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_intsrc),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_intsrc>())).irqtype as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_intsrc),
            "::",
            stringify!(irqtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_intsrc>())).irqflag as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_intsrc),
            "::",
            stringify!(irqflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_intsrc>())).srcbus as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_intsrc),
            "::",
            stringify!(srcbus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_intsrc>())).srcbusirq as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_intsrc),
            "::",
            stringify!(srcbusirq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_intsrc>())).dstapic as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_intsrc),
            "::",
            stringify!(dstapic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_intsrc>())).dstirq as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_intsrc),
            "::",
            stringify!(dstirq)
        )
    );
}
pub const mp_irq_source_types_mp_INT: mp_irq_source_types = 0;
pub const mp_irq_source_types_mp_NMI: mp_irq_source_types = 1;
pub const mp_irq_source_types_mp_SMI: mp_irq_source_types = 2;
pub const mp_irq_source_types_mp_ExtINT: mp_irq_source_types = 3;
pub type mp_irq_source_types = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mpc_lintsrc {
    pub type_: ::std::os::raw::c_uchar,
    pub irqtype: ::std::os::raw::c_uchar,
    pub irqflag: ::std::os::raw::c_ushort,
    pub srcbusid: ::std::os::raw::c_uchar,
    pub srcbusirq: ::std::os::raw::c_uchar,
    pub destapic: ::std::os::raw::c_uchar,
    pub destapiclint: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_mpc_lintsrc() {
    assert_eq!(
        ::std::mem::size_of::<mpc_lintsrc>(),
        8usize,
        concat!("Size of: ", stringify!(mpc_lintsrc))
    );
    assert_eq!(
        ::std::mem::align_of::<mpc_lintsrc>(),
        2usize,
        concat!("Alignment of ", stringify!(mpc_lintsrc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_lintsrc>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_lintsrc),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_lintsrc>())).irqtype as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_lintsrc),
            "::",
            stringify!(irqtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_lintsrc>())).irqflag as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_lintsrc),
            "::",
            stringify!(irqflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_lintsrc>())).srcbusid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_lintsrc),
            "::",
            stringify!(srcbusid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_lintsrc>())).srcbusirq as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_lintsrc),
            "::",
            stringify!(srcbusirq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_lintsrc>())).destapic as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_lintsrc),
            "::",
            stringify!(destapic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_lintsrc>())).destapiclint as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_lintsrc),
            "::",
            stringify!(destapiclint)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mpc_oemtable {
    pub signature: [::std::os::raw::c_char; 4usize],
    pub length: ::std::os::raw::c_ushort,
    pub rev: ::std::os::raw::c_char,
    pub checksum: ::std::os::raw::c_char,
    pub mpc: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_mpc_oemtable() {
    assert_eq!(
        ::std::mem::size_of::<mpc_oemtable>(),
        16usize,
        concat!("Size of: ", stringify!(mpc_oemtable))
    );
    assert_eq!(
        ::std::mem::align_of::<mpc_oemtable>(),
        2usize,
        concat!("Alignment of ", stringify!(mpc_oemtable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_oemtable>())).signature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_oemtable),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_oemtable>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_oemtable),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_oemtable>())).rev as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_oemtable),
            "::",
            stringify!(rev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_oemtable>())).checksum as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_oemtable),
            "::",
            stringify!(checksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_oemtable>())).mpc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_oemtable),
            "::",
            stringify!(mpc)
        )
    );
}
pub const mp_bustype_MP_BUS_ISA: mp_bustype = 1;
pub const mp_bustype_MP_BUS_EISA: mp_bustype = 2;
pub const mp_bustype_MP_BUS_PCI: mp_bustype = 3;
pub type mp_bustype = u32;
#[doc = " struct x86_init_mpparse - platform specific mpparse ops"]
#[doc = " @mpc_record:\t\t\tplatform specific mpc record accounting"]
#[doc = " @setup_ioapic_ids:\t\tplatform specific ioapic id override"]
#[doc = " @mpc_apic_id:\t\tplatform specific mpc apic id assignment"]
#[doc = " @smp_read_mpc_oem:\t\tplatform specific oem mpc table setup"]
#[doc = " @mpc_oem_pci_bus:\t\tplatform specific pci bus setup (default NULL)"]
#[doc = " @mpc_oem_bus_info:\t\tplatform specific mpc bus info"]
#[doc = " @find_smp_config:\t\tfind the smp configuration"]
#[doc = " @get_smp_config:\t\tget the smp configuration"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_init_mpparse {
    pub mpc_record: ::std::option::Option<unsafe extern "C" fn(mode: ::std::os::raw::c_uint)>,
    pub setup_ioapic_ids: ::std::option::Option<unsafe extern "C" fn()>,
    pub mpc_apic_id:
        ::std::option::Option<unsafe extern "C" fn(m: *mut mpc_cpu) -> ::std::os::raw::c_int>,
    pub smp_read_mpc_oem: ::std::option::Option<unsafe extern "C" fn(mpc: *mut mpc_table)>,
    pub mpc_oem_pci_bus: ::std::option::Option<unsafe extern "C" fn(m: *mut mpc_bus)>,
    pub mpc_oem_bus_info: ::std::option::Option<
        unsafe extern "C" fn(m: *mut mpc_bus, name: *mut ::std::os::raw::c_char),
    >,
    pub find_smp_config: ::std::option::Option<unsafe extern "C" fn()>,
    pub get_smp_config: ::std::option::Option<unsafe extern "C" fn(early: ::std::os::raw::c_uint)>,
}
#[test]
fn bindgen_test_layout_x86_init_mpparse() {
    assert_eq!(
        ::std::mem::size_of::<x86_init_mpparse>(),
        64usize,
        concat!("Size of: ", stringify!(x86_init_mpparse))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_init_mpparse>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_init_mpparse))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_mpparse>())).mpc_record as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_mpparse),
            "::",
            stringify!(mpc_record)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_init_mpparse>())).setup_ioapic_ids as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_mpparse),
            "::",
            stringify!(setup_ioapic_ids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_mpparse>())).mpc_apic_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_mpparse),
            "::",
            stringify!(mpc_apic_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_init_mpparse>())).smp_read_mpc_oem as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_mpparse),
            "::",
            stringify!(smp_read_mpc_oem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_init_mpparse>())).mpc_oem_pci_bus as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_mpparse),
            "::",
            stringify!(mpc_oem_pci_bus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_init_mpparse>())).mpc_oem_bus_info as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_mpparse),
            "::",
            stringify!(mpc_oem_bus_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_init_mpparse>())).find_smp_config as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_mpparse),
            "::",
            stringify!(find_smp_config)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_mpparse>())).get_smp_config as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_mpparse),
            "::",
            stringify!(get_smp_config)
        )
    );
}
#[doc = " struct x86_init_resources - platform specific resource related ops"]
#[doc = " @probe_roms:\t\t\tprobe BIOS roms"]
#[doc = " @reserve_resources:\t\treserve the standard resources for the"]
#[doc = "\t\t\t\tplatform"]
#[doc = " @memory_setup:\t\tplatform specific memory setup"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_init_resources {
    pub probe_roms: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserve_resources: ::std::option::Option<unsafe extern "C" fn()>,
    pub memory_setup: ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_x86_init_resources() {
    assert_eq!(
        ::std::mem::size_of::<x86_init_resources>(),
        24usize,
        concat!("Size of: ", stringify!(x86_init_resources))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_init_resources>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_init_resources))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_resources>())).probe_roms as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_resources),
            "::",
            stringify!(probe_roms)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_init_resources>())).reserve_resources as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_resources),
            "::",
            stringify!(reserve_resources)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_resources>())).memory_setup as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_resources),
            "::",
            stringify!(memory_setup)
        )
    );
}
#[doc = " struct x86_init_irqs - platform specific interrupt setup"]
#[doc = " @pre_vector_init:\t\tinit code to run before interrupt vectors"]
#[doc = "\t\t\t\tare set up."]
#[doc = " @intr_init:\t\t\tinterrupt init code"]
#[doc = " @trap_init:\t\t\tplatform specific trap setup"]
#[doc = " @intr_mode_select:\t\tinterrupt delivery mode selection"]
#[doc = " @intr_mode_init:\t\tinterrupt delivery mode setup"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_init_irqs {
    pub pre_vector_init: ::std::option::Option<unsafe extern "C" fn()>,
    pub intr_init: ::std::option::Option<unsafe extern "C" fn()>,
    pub trap_init: ::std::option::Option<unsafe extern "C" fn()>,
    pub intr_mode_select: ::std::option::Option<unsafe extern "C" fn()>,
    pub intr_mode_init: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_x86_init_irqs() {
    assert_eq!(
        ::std::mem::size_of::<x86_init_irqs>(),
        40usize,
        concat!("Size of: ", stringify!(x86_init_irqs))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_init_irqs>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_init_irqs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_irqs>())).pre_vector_init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_irqs),
            "::",
            stringify!(pre_vector_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_irqs>())).intr_init as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_irqs),
            "::",
            stringify!(intr_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_irqs>())).trap_init as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_irqs),
            "::",
            stringify!(trap_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_irqs>())).intr_mode_select as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_irqs),
            "::",
            stringify!(intr_mode_select)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_irqs>())).intr_mode_init as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_irqs),
            "::",
            stringify!(intr_mode_init)
        )
    );
}
#[doc = " struct x86_init_oem - oem platform specific customizing functions"]
#[doc = " @arch_setup:\t\t\tplatform specific architecture setup"]
#[doc = " @banner:\t\t\tprint a platform specific banner"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_init_oem {
    pub arch_setup: ::std::option::Option<unsafe extern "C" fn()>,
    pub banner: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_x86_init_oem() {
    assert_eq!(
        ::std::mem::size_of::<x86_init_oem>(),
        16usize,
        concat!("Size of: ", stringify!(x86_init_oem))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_init_oem>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_init_oem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_oem>())).arch_setup as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_oem),
            "::",
            stringify!(arch_setup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_oem>())).banner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_oem),
            "::",
            stringify!(banner)
        )
    );
}
#[doc = " struct x86_init_paging - platform specific paging functions"]
#[doc = " @pagetable_init:\tplatform specific paging initialization call to setup"]
#[doc = "\t\t\tthe kernel pagetables and prepare accessors functions."]
#[doc = "\t\t\tCallback must call paging_init(). Called once after the"]
#[doc = "\t\t\tdirect mapping for phys memory is available."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_init_paging {
    pub pagetable_init: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_x86_init_paging() {
    assert_eq!(
        ::std::mem::size_of::<x86_init_paging>(),
        8usize,
        concat!("Size of: ", stringify!(x86_init_paging))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_init_paging>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_init_paging))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_paging>())).pagetable_init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_paging),
            "::",
            stringify!(pagetable_init)
        )
    );
}
#[doc = " struct x86_init_timers - platform specific timer setup"]
#[doc = " @setup_perpcu_clockev:\tset up the per cpu clock event device for the"]
#[doc = "\t\t\t\tboot cpu"]
#[doc = " @timer_init:\t\t\tinitialize the platform timer (default PIT/HPET)"]
#[doc = " @wallclock_init:\t\tinit the wallclock device"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_init_timers {
    pub setup_percpu_clockev: ::std::option::Option<unsafe extern "C" fn()>,
    pub timer_init: ::std::option::Option<unsafe extern "C" fn()>,
    pub wallclock_init: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_x86_init_timers() {
    assert_eq!(
        ::std::mem::size_of::<x86_init_timers>(),
        24usize,
        concat!("Size of: ", stringify!(x86_init_timers))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_init_timers>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_init_timers))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_init_timers>())).setup_percpu_clockev as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_timers),
            "::",
            stringify!(setup_percpu_clockev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_timers>())).timer_init as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_timers),
            "::",
            stringify!(timer_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_timers>())).wallclock_init as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_timers),
            "::",
            stringify!(wallclock_init)
        )
    );
}
#[doc = " struct x86_init_iommu - platform specific iommu setup"]
#[doc = " @iommu_init:\t\t\tplatform specific iommu setup"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_init_iommu {
    pub iommu_init: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_x86_init_iommu() {
    assert_eq!(
        ::std::mem::size_of::<x86_init_iommu>(),
        8usize,
        concat!("Size of: ", stringify!(x86_init_iommu))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_init_iommu>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_init_iommu))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_iommu>())).iommu_init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_iommu),
            "::",
            stringify!(iommu_init)
        )
    );
}
#[doc = " struct x86_init_pci - platform specific pci init functions"]
#[doc = " @arch_init:\t\t\tplatform specific pci arch init call"]
#[doc = " @init:\t\t\tplatform specific pci subsystem init"]
#[doc = " @init_irq:\t\t\tplatform specific pci irq init"]
#[doc = " @fixup_irqs:\t\t\tplatform specific pci irq fixup"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_init_pci {
    pub arch_init: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub init: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub init_irq: ::std::option::Option<unsafe extern "C" fn()>,
    pub fixup_irqs: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_x86_init_pci() {
    assert_eq!(
        ::std::mem::size_of::<x86_init_pci>(),
        32usize,
        concat!("Size of: ", stringify!(x86_init_pci))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_init_pci>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_init_pci))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_pci>())).arch_init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_pci),
            "::",
            stringify!(arch_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_pci>())).init as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_pci),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_pci>())).init_irq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_pci),
            "::",
            stringify!(init_irq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_pci>())).fixup_irqs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_pci),
            "::",
            stringify!(fixup_irqs)
        )
    );
}
#[doc = " struct x86_hyper_init - x86 hypervisor init functions"]
#[doc = " @init_platform:\t\tplatform setup"]
#[doc = " @guest_late_init:\t\tguest late init"]
#[doc = " @x2apic_available:\t\tX2APIC detection"]
#[doc = " @init_mem_mapping:\t\tsetup early mappings during init_mem_mapping()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_hyper_init {
    pub init_platform: ::std::option::Option<unsafe extern "C" fn()>,
    pub guest_late_init: ::std::option::Option<unsafe extern "C" fn()>,
    pub x2apic_available: ::std::option::Option<unsafe extern "C" fn() -> bool_>,
    pub init_mem_mapping: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_x86_hyper_init() {
    assert_eq!(
        ::std::mem::size_of::<x86_hyper_init>(),
        32usize,
        concat!("Size of: ", stringify!(x86_hyper_init))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_hyper_init>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_hyper_init))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hyper_init>())).init_platform as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hyper_init),
            "::",
            stringify!(init_platform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hyper_init>())).guest_late_init as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hyper_init),
            "::",
            stringify!(guest_late_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hyper_init>())).x2apic_available as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hyper_init),
            "::",
            stringify!(x2apic_available)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hyper_init>())).init_mem_mapping as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hyper_init),
            "::",
            stringify!(init_mem_mapping)
        )
    );
}
#[doc = " struct x86_init_ops - functions for platform specific setup"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_init_ops {
    pub resources: x86_init_resources,
    pub mpparse: x86_init_mpparse,
    pub irqs: x86_init_irqs,
    pub oem: x86_init_oem,
    pub paging: x86_init_paging,
    pub timers: x86_init_timers,
    pub iommu: x86_init_iommu,
    pub pci: x86_init_pci,
    pub hyper: x86_hyper_init,
}
#[test]
fn bindgen_test_layout_x86_init_ops() {
    assert_eq!(
        ::std::mem::size_of::<x86_init_ops>(),
        248usize,
        concat!("Size of: ", stringify!(x86_init_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_init_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_init_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_ops>())).resources as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_ops),
            "::",
            stringify!(resources)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_ops>())).mpparse as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_ops),
            "::",
            stringify!(mpparse)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_ops>())).irqs as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_ops),
            "::",
            stringify!(irqs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_ops>())).oem as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_ops),
            "::",
            stringify!(oem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_ops>())).paging as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_ops),
            "::",
            stringify!(paging)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_ops>())).timers as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_ops),
            "::",
            stringify!(timers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_ops>())).iommu as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_ops),
            "::",
            stringify!(iommu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_ops>())).pci as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_ops),
            "::",
            stringify!(pci)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_ops>())).hyper as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_ops),
            "::",
            stringify!(hyper)
        )
    );
}
#[doc = " struct x86_cpuinit_ops - platform specific cpu hotplug setups"]
#[doc = " @setup_percpu_clockev:\tset up the per cpu clock event device"]
#[doc = " @early_percpu_clock_init:\tearly init of the per cpu clock event device"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_cpuinit_ops {
    pub setup_percpu_clockev: ::std::option::Option<unsafe extern "C" fn()>,
    pub early_percpu_clock_init: ::std::option::Option<unsafe extern "C" fn()>,
    pub fixup_cpu_id: ::std::option::Option<
        unsafe extern "C" fn(c: *mut cpuinfo_x86, node: ::std::os::raw::c_int),
    >,
}
#[test]
fn bindgen_test_layout_x86_cpuinit_ops() {
    assert_eq!(
        ::std::mem::size_of::<x86_cpuinit_ops>(),
        24usize,
        concat!("Size of: ", stringify!(x86_cpuinit_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_cpuinit_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_cpuinit_ops))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_cpuinit_ops>())).setup_percpu_clockev as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_cpuinit_ops),
            "::",
            stringify!(setup_percpu_clockev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_cpuinit_ops>())).early_percpu_clock_init as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_cpuinit_ops),
            "::",
            stringify!(early_percpu_clock_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_cpuinit_ops>())).fixup_cpu_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_cpuinit_ops),
            "::",
            stringify!(fixup_cpu_id)
        )
    );
}
#[doc = " struct x86_legacy_devices - legacy x86 devices"]
#[doc = ""]
#[doc = " @pnpbios: this platform can have a PNPBIOS. If this is disabled the platform"]
#[doc = " \tis known to never have a PNPBIOS."]
#[doc = ""]
#[doc = " These are devices known to require LPC or ISA bus. The definition of legacy"]
#[doc = " devices adheres to the ACPI 5.2.9.3 IA-PC Boot Architecture flag"]
#[doc = " ACPI_FADT_LEGACY_DEVICES. These devices consist of user visible devices on"]
#[doc = " the LPC or ISA bus. User visible devices are devices that have end-user"]
#[doc = " accessible connectors (for example, LPT parallel port). Legacy devices on"]
#[doc = " the LPC bus consist for example of serial and parallel ports, PS/2 keyboard"]
#[doc = " / mouse, and the floppy disk controller. A system that lacks all known"]
#[doc = " legacy devices can assume all devices can be detected exclusively via"]
#[doc = " standard device enumeration mechanisms including the ACPI namespace."]
#[doc = ""]
#[doc = " A system which has does not have ACPI_FADT_LEGACY_DEVICES enabled must not"]
#[doc = " have any of the legacy devices enumerated below present."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_legacy_devices {
    pub pnpbios: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_x86_legacy_devices() {
    assert_eq!(
        ::std::mem::size_of::<x86_legacy_devices>(),
        4usize,
        concat!("Size of: ", stringify!(x86_legacy_devices))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_legacy_devices>(),
        4usize,
        concat!("Alignment of ", stringify!(x86_legacy_devices))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_legacy_devices>())).pnpbios as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_legacy_devices),
            "::",
            stringify!(pnpbios)
        )
    );
}
pub const x86_legacy_i8042_state_X86_LEGACY_I8042_PLATFORM_ABSENT: x86_legacy_i8042_state = 0;
pub const x86_legacy_i8042_state_X86_LEGACY_I8042_FIRMWARE_ABSENT: x86_legacy_i8042_state = 1;
pub const x86_legacy_i8042_state_X86_LEGACY_I8042_EXPECTED_PRESENT: x86_legacy_i8042_state = 2;
#[doc = " enum x86_legacy_i8042_state - i8042 keyboard controller state"]
#[doc = " @X86_LEGACY_I8042_PLATFORM_ABSENT: the controller is always absent on"]
#[doc = "\tgiven platform/subarch."]
#[doc = " @X86_LEGACY_I8042_FIRMWARE_ABSENT: firmware reports that the controller"]
#[doc = "\tis absent."]
#[doc = " @X86_LEGACY_i8042_EXPECTED_PRESENT: the controller is likely to be"]
#[doc = "\tpresent, the i8042 driver should probe for controller existence."]
pub type x86_legacy_i8042_state = u32;
#[doc = " struct x86_legacy_features - legacy x86 features"]
#[doc = ""]
#[doc = " @i8042: indicated if we expect the device to have i8042 controller"]
#[doc = "\tpresent."]
#[doc = " @rtc: this device has a CMOS real-time clock present"]
#[doc = " @reserve_bios_regions: boot code will search for the EBDA address and the"]
#[doc = " \tstart of the 640k - 1M BIOS region.  If false, the platform must"]
#[doc = " \tensure that its memory map correctly reserves sub-1MB regions as needed."]
#[doc = " @devices: legacy x86 devices, refer to struct x86_legacy_devices"]
#[doc = " \tdocumentation for further details."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_legacy_features {
    pub i8042: x86_legacy_i8042_state,
    pub rtc: ::std::os::raw::c_int,
    pub no_vga: ::std::os::raw::c_int,
    pub reserve_bios_regions: ::std::os::raw::c_int,
    pub devices: x86_legacy_devices,
}
#[test]
fn bindgen_test_layout_x86_legacy_features() {
    assert_eq!(
        ::std::mem::size_of::<x86_legacy_features>(),
        20usize,
        concat!("Size of: ", stringify!(x86_legacy_features))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_legacy_features>(),
        4usize,
        concat!("Alignment of ", stringify!(x86_legacy_features))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_legacy_features>())).i8042 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_legacy_features),
            "::",
            stringify!(i8042)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_legacy_features>())).rtc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_legacy_features),
            "::",
            stringify!(rtc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_legacy_features>())).no_vga as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_legacy_features),
            "::",
            stringify!(no_vga)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_legacy_features>())).reserve_bios_regions as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_legacy_features),
            "::",
            stringify!(reserve_bios_regions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_legacy_features>())).devices as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_legacy_features),
            "::",
            stringify!(devices)
        )
    );
}
#[doc = " struct x86_hyper_runtime - x86 hypervisor specific runtime callbacks"]
#[doc = ""]
#[doc = " @pin_vcpu:\t\tpin current vcpu to specified physical cpu (run rarely)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_hyper_runtime {
    pub pin_vcpu: ::std::option::Option<unsafe extern "C" fn(cpu: ::std::os::raw::c_int)>,
}
#[test]
fn bindgen_test_layout_x86_hyper_runtime() {
    assert_eq!(
        ::std::mem::size_of::<x86_hyper_runtime>(),
        8usize,
        concat!("Size of: ", stringify!(x86_hyper_runtime))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_hyper_runtime>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_hyper_runtime))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hyper_runtime>())).pin_vcpu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hyper_runtime),
            "::",
            stringify!(pin_vcpu)
        )
    );
}
#[doc = " struct x86_platform_ops - platform specific runtime functions"]
#[doc = " @calibrate_cpu:\t\tcalibrate CPU"]
#[doc = " @calibrate_tsc:\t\tcalibrate TSC, if different from CPU"]
#[doc = " @get_wallclock:\t\tget time from HW clock like RTC etc."]
#[doc = " @set_wallclock:\t\tset time back to HW clock"]
#[doc = " @is_untracked_pat_range\texclude from PAT logic"]
#[doc = " @nmi_init\t\t\tenable NMI on cpus"]
#[doc = " @save_sched_clock_state:\tsave state for sched_clock() on suspend"]
#[doc = " @restore_sched_clock_state:\trestore state for sched_clock() on resume"]
#[doc = " @apic_post_init:\t\tadjust apic if needed"]
#[doc = " @legacy:\t\t\tlegacy features"]
#[doc = " @set_legacy_features:\toverride legacy features. Use of this callback"]
#[doc = " \t\t\t\tis highly discouraged. You should only need"]
#[doc = " \t\t\t\tthis if your hardware platform requires further"]
#[doc = " \t\t\t\tcustom fine tuning far beyond what may be"]
#[doc = " \t\t\t\tpossible in x86_early_init_platform_quirks() by"]
#[doc = " \t\t\t\tonly using the current x86_hardware_subarch"]
#[doc = " \t\t\t\tsemantics."]
#[doc = " @hyper:\t\t\tx86 hypervisor specific runtime callbacks"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_platform_ops {
    pub calibrate_cpu: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_ulong>,
    pub calibrate_tsc: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_ulong>,
    pub get_wallclock: ::std::option::Option<unsafe extern "C" fn(ts: *mut timespec)>,
    pub set_wallclock:
        ::std::option::Option<unsafe extern "C" fn(ts: *const timespec) -> ::std::os::raw::c_int>,
    pub iommu_shutdown: ::std::option::Option<unsafe extern "C" fn()>,
    pub is_untracked_pat_range:
        ::std::option::Option<unsafe extern "C" fn(start: __u64, end: __u64) -> bool_>,
    pub nmi_init: ::std::option::Option<unsafe extern "C" fn()>,
    pub get_nmi_reason: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_uchar>,
    pub save_sched_clock_state: ::std::option::Option<unsafe extern "C" fn()>,
    pub restore_sched_clock_state: ::std::option::Option<unsafe extern "C" fn()>,
    pub apic_post_init: ::std::option::Option<unsafe extern "C" fn()>,
    pub legacy: x86_legacy_features,
    pub set_legacy_features: ::std::option::Option<unsafe extern "C" fn()>,
    pub hyper: x86_hyper_runtime,
}
#[test]
fn bindgen_test_layout_x86_platform_ops() {
    assert_eq!(
        ::std::mem::size_of::<x86_platform_ops>(),
        128usize,
        concat!("Size of: ", stringify!(x86_platform_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_platform_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_platform_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_platform_ops>())).calibrate_cpu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(calibrate_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_platform_ops>())).calibrate_tsc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(calibrate_tsc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_platform_ops>())).get_wallclock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(get_wallclock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_platform_ops>())).set_wallclock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(set_wallclock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_platform_ops>())).iommu_shutdown as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(iommu_shutdown)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_platform_ops>())).is_untracked_pat_range as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(is_untracked_pat_range)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_platform_ops>())).nmi_init as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(nmi_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_platform_ops>())).get_nmi_reason as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(get_nmi_reason)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_platform_ops>())).save_sched_clock_state as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(save_sched_clock_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_platform_ops>())).restore_sched_clock_state as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(restore_sched_clock_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_platform_ops>())).apic_post_init as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(apic_post_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_platform_ops>())).legacy as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(legacy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_platform_ops>())).set_legacy_features as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(set_legacy_features)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_platform_ops>())).hyper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(hyper)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pci_dev {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_msi_ops {
    pub setup_msi_irqs: ::std::option::Option<
        unsafe extern "C" fn(
            dev: *mut pci_dev,
            nvec: ::std::os::raw::c_int,
            type_: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub teardown_msi_irq: ::std::option::Option<unsafe extern "C" fn(irq: ::std::os::raw::c_uint)>,
    pub teardown_msi_irqs: ::std::option::Option<unsafe extern "C" fn(dev: *mut pci_dev)>,
    pub restore_msi_irqs: ::std::option::Option<unsafe extern "C" fn(dev: *mut pci_dev)>,
}
#[test]
fn bindgen_test_layout_x86_msi_ops() {
    assert_eq!(
        ::std::mem::size_of::<x86_msi_ops>(),
        32usize,
        concat!("Size of: ", stringify!(x86_msi_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_msi_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_msi_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_msi_ops>())).setup_msi_irqs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_msi_ops),
            "::",
            stringify!(setup_msi_irqs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_msi_ops>())).teardown_msi_irq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_msi_ops),
            "::",
            stringify!(teardown_msi_irq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_msi_ops>())).teardown_msi_irqs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_msi_ops),
            "::",
            stringify!(teardown_msi_irqs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_msi_ops>())).restore_msi_irqs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_msi_ops),
            "::",
            stringify!(restore_msi_irqs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_io_apic_ops {
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            apic: ::std::os::raw::c_uint,
            reg: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_uint,
    >,
    pub disable: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_x86_io_apic_ops() {
    assert_eq!(
        ::std::mem::size_of::<x86_io_apic_ops>(),
        16usize,
        concat!("Size of: ", stringify!(x86_io_apic_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_io_apic_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_io_apic_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_io_apic_ops>())).read as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_io_apic_ops),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_io_apic_ops>())).disable as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_io_apic_ops),
            "::",
            stringify!(disable)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}x86_init"]
    pub static mut x86_init: x86_init_ops;
}
extern "C" {
    #[link_name = "\u{1}x86_cpuinit"]
    pub static mut x86_cpuinit: x86_cpuinit_ops;
}
extern "C" {
    #[link_name = "\u{1}x86_platform"]
    pub static mut x86_platform: x86_platform_ops;
}
extern "C" {
    #[link_name = "\u{1}x86_msi"]
    pub static mut x86_msi: x86_msi_ops;
}
extern "C" {
    #[link_name = "\u{1}x86_io_apic_ops"]
    pub static mut x86_io_apic_ops: x86_io_apic_ops;
}
extern "C" {
    pub fn x86_early_init_platform_quirks();
}
extern "C" {
    pub fn x86_init_noop();
}
extern "C" {
    pub fn x86_init_uint_noop(unused: ::std::os::raw::c_uint);
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct local_apic {
    pub __reserved_01: local_apic__bindgen_ty_1,
    pub __reserved_02: local_apic__bindgen_ty_2,
    pub id: local_apic__bindgen_ty_3,
    pub version: local_apic__bindgen_ty_4,
    pub __reserved_03: local_apic__bindgen_ty_5,
    pub __reserved_04: local_apic__bindgen_ty_6,
    pub __reserved_05: local_apic__bindgen_ty_7,
    pub __reserved_06: local_apic__bindgen_ty_8,
    pub tpr: local_apic__bindgen_ty_9,
    pub apr: local_apic__bindgen_ty_10,
    pub ppr: local_apic__bindgen_ty_11,
    pub eoi: local_apic__bindgen_ty_12,
    pub __reserved_07: local_apic__bindgen_ty_13,
    pub ldr: local_apic__bindgen_ty_14,
    pub dfr: local_apic__bindgen_ty_15,
    pub svr: local_apic__bindgen_ty_16,
    pub isr: [local_apic__bindgen_ty_17; 8usize],
    pub tmr: [local_apic__bindgen_ty_18; 8usize],
    pub irr: [local_apic__bindgen_ty_19; 8usize],
    pub esr: local_apic__bindgen_ty_20,
    pub __reserved_08: local_apic__bindgen_ty_21,
    pub __reserved_09: local_apic__bindgen_ty_22,
    pub __reserved_10: local_apic__bindgen_ty_23,
    pub __reserved_11: local_apic__bindgen_ty_24,
    pub __reserved_12: local_apic__bindgen_ty_25,
    pub __reserved_13: local_apic__bindgen_ty_26,
    pub __reserved_14: local_apic__bindgen_ty_27,
    pub icr1: local_apic__bindgen_ty_28,
    pub icr2: local_apic__bindgen_ty_29,
    pub lvt_timer: local_apic__bindgen_ty_30,
    pub lvt_thermal: local_apic__bindgen_ty_31,
    pub lvt_pc: local_apic__bindgen_ty_32,
    pub lvt_lint0: local_apic__bindgen_ty_33,
    pub lvt_lint1: local_apic__bindgen_ty_34,
    pub lvt_error: local_apic__bindgen_ty_35,
    pub timer_icr: local_apic__bindgen_ty_36,
    pub timer_ccr: local_apic__bindgen_ty_37,
    pub __reserved_16: local_apic__bindgen_ty_38,
    pub __reserved_17: local_apic__bindgen_ty_39,
    pub __reserved_18: local_apic__bindgen_ty_40,
    pub __reserved_19: local_apic__bindgen_ty_41,
    pub timer_dcr: local_apic__bindgen_ty_42,
    pub __reserved_20: local_apic__bindgen_ty_43,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_1 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_1>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_1),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_2 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_2>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_2),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_3 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_3))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_3>())).__reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_3),
            "::",
            stringify!(__reserved)
        )
    );
}
impl local_apic__bindgen_ty_3 {
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn phys_apic_id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_phys_apic_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __reserved_1: ::std::os::raw::c_uint,
        phys_apic_id: ::std::os::raw::c_uint,
        __reserved_2: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let phys_apic_id: u32 = unsafe { ::std::mem::transmute(phys_apic_id) };
            phys_apic_id as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_4 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub __reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_4>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_4>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_4))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_4>())).__reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_4),
            "::",
            stringify!(__reserved)
        )
    );
}
impl local_apic__bindgen_ty_4 {
    #[inline]
    pub fn version(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn max_lvt(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_max_lvt(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        version: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
        max_lvt: ::std::os::raw::c_uint,
        __reserved_2: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let max_lvt: u32 = unsafe { ::std::mem::transmute(max_lvt) };
            max_lvt as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_5 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_5>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_5>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_5))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_5>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_5),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_6 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_6>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_6>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_6))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_6>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_6),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_7 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_7>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_7>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_7))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_7>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_7),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_8 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_8() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_8>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_8))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_8>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_8))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_8>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_8),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_9 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __reserved_2: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_9() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_9>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_9))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_9>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_9))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_9>())).__reserved_2 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_9),
            "::",
            stringify!(__reserved_2)
        )
    );
}
impl local_apic__bindgen_ty_9 {
    #[inline]
    pub fn priority(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_priority(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        priority: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let priority: u32 = unsafe { ::std::mem::transmute(priority) };
            priority as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_10 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __reserved_2: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_10() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_10>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_10))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_10>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_10))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_10>())).__reserved_2 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_10),
            "::",
            stringify!(__reserved_2)
        )
    );
}
impl local_apic__bindgen_ty_10 {
    #[inline]
    pub fn priority(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_priority(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        priority: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let priority: u32 = unsafe { ::std::mem::transmute(priority) };
            priority as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_11 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __reserved_2: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_11() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_11>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_11))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_11>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_11))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_11>())).__reserved_2 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_11),
            "::",
            stringify!(__reserved_2)
        )
    );
}
impl local_apic__bindgen_ty_11 {
    #[inline]
    pub fn priority(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_priority(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        priority: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let priority: u32 = unsafe { ::std::mem::transmute(priority) };
            priority as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_12 {
    pub eoi: ::std::os::raw::c_uint,
    pub __reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_12() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_12>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_12))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_12>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_12))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic__bindgen_ty_12>())).eoi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_12),
            "::",
            stringify!(eoi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_12>())).__reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_12),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_13 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_13() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_13>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_13))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_13>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_13))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_13>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_13),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_14 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __reserved_2: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_14() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_14>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_14))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_14>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_14))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_14>())).__reserved_2 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_14),
            "::",
            stringify!(__reserved_2)
        )
    );
}
impl local_apic__bindgen_ty_14 {
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn logical_dest(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_logical_dest(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __reserved_1: ::std::os::raw::c_uint,
        logical_dest: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let logical_dest: u32 = unsafe { ::std::mem::transmute(logical_dest) };
            logical_dest as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_15 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __reserved_2: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_15() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_15>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_15))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_15>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_15))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_15>())).__reserved_2 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_15),
            "::",
            stringify!(__reserved_2)
        )
    );
}
impl local_apic__bindgen_ty_15 {
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn model(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_model(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __reserved_1: ::std::os::raw::c_uint,
        model: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let model: u32 = unsafe { ::std::mem::transmute(model) };
            model as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_16 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __reserved_3: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_16() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_16>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_16))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_16>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_16))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_16>())).__reserved_3 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_16),
            "::",
            stringify!(__reserved_3)
        )
    );
}
impl local_apic__bindgen_ty_16 {
    #[inline]
    pub fn spurious_vector(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_spurious_vector(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn apic_enabled(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_apic_enabled(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn focus_cpu(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_focus_cpu(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        spurious_vector: ::std::os::raw::c_uint,
        apic_enabled: ::std::os::raw::c_uint,
        focus_cpu: ::std::os::raw::c_uint,
        __reserved_2: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let spurious_vector: u32 = unsafe { ::std::mem::transmute(spurious_vector) };
            spurious_vector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let apic_enabled: u32 = unsafe { ::std::mem::transmute(apic_enabled) };
            apic_enabled as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let focus_cpu: u32 = unsafe { ::std::mem::transmute(focus_cpu) };
            focus_cpu as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_17 {
    pub bitfield: ::std::os::raw::c_uint,
    pub __reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_17() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_17>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_17))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_17>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_17))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_17>())).bitfield as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_17),
            "::",
            stringify!(bitfield)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_17>())).__reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_17),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_18 {
    pub bitfield: ::std::os::raw::c_uint,
    pub __reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_18() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_18>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_18))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_18>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_18))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_18>())).bitfield as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_18),
            "::",
            stringify!(bitfield)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_18>())).__reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_18),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_19 {
    pub bitfield: ::std::os::raw::c_uint,
    pub __reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_19() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_19>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_19))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_19>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_19))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_19>())).bitfield as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_19),
            "::",
            stringify!(bitfield)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_19>())).__reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_19),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union local_apic__bindgen_ty_20 {
    pub error_bits: local_apic__bindgen_ty_20__bindgen_ty_1,
    pub all_errors: local_apic__bindgen_ty_20__bindgen_ty_2,
    _bindgen_union_align: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_20__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __reserved_3: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_20__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_20__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(local_apic__bindgen_ty_20__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_20__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(local_apic__bindgen_ty_20__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_20__bindgen_ty_1>())).__reserved_3
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_20__bindgen_ty_1),
            "::",
            stringify!(__reserved_3)
        )
    );
}
impl local_apic__bindgen_ty_20__bindgen_ty_1 {
    #[inline]
    pub fn send_cs_error(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_send_cs_error(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn receive_cs_error(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_receive_cs_error(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn send_accept_error(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_send_accept_error(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn receive_accept_error(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_receive_accept_error(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn send_illegal_vector(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_send_illegal_vector(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn receive_illegal_vector(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_receive_illegal_vector(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn illegal_register_address(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_illegal_register_address(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        send_cs_error: ::std::os::raw::c_uint,
        receive_cs_error: ::std::os::raw::c_uint,
        send_accept_error: ::std::os::raw::c_uint,
        receive_accept_error: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
        send_illegal_vector: ::std::os::raw::c_uint,
        receive_illegal_vector: ::std::os::raw::c_uint,
        illegal_register_address: ::std::os::raw::c_uint,
        __reserved_2: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let send_cs_error: u32 = unsafe { ::std::mem::transmute(send_cs_error) };
            send_cs_error as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let receive_cs_error: u32 = unsafe { ::std::mem::transmute(receive_cs_error) };
            receive_cs_error as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let send_accept_error: u32 = unsafe { ::std::mem::transmute(send_accept_error) };
            send_accept_error as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let receive_accept_error: u32 = unsafe { ::std::mem::transmute(receive_accept_error) };
            receive_accept_error as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let send_illegal_vector: u32 = unsafe { ::std::mem::transmute(send_illegal_vector) };
            send_illegal_vector as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let receive_illegal_vector: u32 =
                unsafe { ::std::mem::transmute(receive_illegal_vector) };
            receive_illegal_vector as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let illegal_register_address: u32 =
                unsafe { ::std::mem::transmute(illegal_register_address) };
            illegal_register_address as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_20__bindgen_ty_2 {
    pub errors: ::std::os::raw::c_uint,
    pub __reserved_3: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_20__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_20__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(local_apic__bindgen_ty_20__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_20__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(local_apic__bindgen_ty_20__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_20__bindgen_ty_2>())).errors as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_20__bindgen_ty_2),
            "::",
            stringify!(errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_20__bindgen_ty_2>())).__reserved_3
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_20__bindgen_ty_2),
            "::",
            stringify!(__reserved_3)
        )
    );
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_20() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_20>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_20))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_20>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_20))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_20>())).error_bits as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_20),
            "::",
            stringify!(error_bits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_20>())).all_errors as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_20),
            "::",
            stringify!(all_errors)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_21 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_21() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_21>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_21))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_21>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_21))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_21>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_21),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_22 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_22() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_22>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_22))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_22>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_22))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_22>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_22),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_23 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_23() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_23>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_23))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_23>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_23))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_23>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_23),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_24 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_24() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_24>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_24))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_24>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_24))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_24>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_24),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_25 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_25() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_25>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_25))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_25>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_25))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_25>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_25),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_26 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_26() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_26>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_26))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_26>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_26))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_26>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_26),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_27 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_27() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_27>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_27))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_27>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_27))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_27>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_27),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_28 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __reserved_4: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_28() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_28>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_28))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_28>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_28))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_28>())).__reserved_4 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_28),
            "::",
            stringify!(__reserved_4)
        )
    );
}
impl local_apic__bindgen_ty_28 {
    #[inline]
    pub fn vector(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_mode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_mode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn destination_mode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_destination_mode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn level(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_level(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trigger(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_trigger(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn shorthand(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_shorthand(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_3(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_3(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vector: ::std::os::raw::c_uint,
        delivery_mode: ::std::os::raw::c_uint,
        destination_mode: ::std::os::raw::c_uint,
        delivery_status: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
        level: ::std::os::raw::c_uint,
        trigger: ::std::os::raw::c_uint,
        __reserved_2: ::std::os::raw::c_uint,
        shorthand: ::std::os::raw::c_uint,
        __reserved_3: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let vector: u32 = unsafe { ::std::mem::transmute(vector) };
            vector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let delivery_mode: u32 = unsafe { ::std::mem::transmute(delivery_mode) };
            delivery_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let destination_mode: u32 = unsafe { ::std::mem::transmute(destination_mode) };
            destination_mode as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let delivery_status: u32 = unsafe { ::std::mem::transmute(delivery_status) };
            delivery_status as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let level: u32 = unsafe { ::std::mem::transmute(level) };
            level as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let trigger: u32 = unsafe { ::std::mem::transmute(trigger) };
            trigger as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let shorthand: u32 = unsafe { ::std::mem::transmute(shorthand) };
            shorthand as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let __reserved_3: u32 = unsafe { ::std::mem::transmute(__reserved_3) };
            __reserved_3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_29 {
    pub dest: local_apic__bindgen_ty_29__bindgen_ty_1,
    pub __reserved_4: [::std::os::raw::c_uint; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union local_apic__bindgen_ty_29__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u32>,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_29__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_29__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(local_apic__bindgen_ty_29__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_29__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(local_apic__bindgen_ty_29__bindgen_ty_1)
        )
    );
}
impl local_apic__bindgen_ty_29__bindgen_ty_1 {
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn phys_dest(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_phys_dest(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_3(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_3(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn logical_dest(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_logical_dest(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __reserved_1: ::std::os::raw::c_uint,
        phys_dest: ::std::os::raw::c_uint,
        __reserved_2: ::std::os::raw::c_uint,
        __reserved_3: ::std::os::raw::c_uint,
        logical_dest: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let phys_dest: u32 = unsafe { ::std::mem::transmute(phys_dest) };
            phys_dest as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 24u8, {
            let __reserved_3: u32 = unsafe { ::std::mem::transmute(__reserved_3) };
            __reserved_3 as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let logical_dest: u32 = unsafe { ::std::mem::transmute(logical_dest) };
            logical_dest as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_29() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_29>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_29))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_29>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_29))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic__bindgen_ty_29>())).dest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_29),
            "::",
            stringify!(dest)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_29>())).__reserved_4 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_29),
            "::",
            stringify!(__reserved_4)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_30 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __reserved_4: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_30() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_30>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_30))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_30>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_30))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_30>())).__reserved_4 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_30),
            "::",
            stringify!(__reserved_4)
        )
    );
}
impl local_apic__bindgen_ty_30 {
    #[inline]
    pub fn vector(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mask(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn timer_mode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timer_mode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_3(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_3(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vector: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
        delivery_status: ::std::os::raw::c_uint,
        __reserved_2: ::std::os::raw::c_uint,
        mask: ::std::os::raw::c_uint,
        timer_mode: ::std::os::raw::c_uint,
        __reserved_3: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let vector: u32 = unsafe { ::std::mem::transmute(vector) };
            vector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let delivery_status: u32 = unsafe { ::std::mem::transmute(delivery_status) };
            delivery_status as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let mask: u32 = unsafe { ::std::mem::transmute(mask) };
            mask as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let timer_mode: u32 = unsafe { ::std::mem::transmute(timer_mode) };
            timer_mode as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let __reserved_3: u32 = unsafe { ::std::mem::transmute(__reserved_3) };
            __reserved_3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_31 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __reserved_4: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_31() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_31>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_31))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_31>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_31))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_31>())).__reserved_4 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_31),
            "::",
            stringify!(__reserved_4)
        )
    );
}
impl local_apic__bindgen_ty_31 {
    #[inline]
    pub fn vector(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_mode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_mode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mask(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_3(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_3(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vector: ::std::os::raw::c_uint,
        delivery_mode: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
        delivery_status: ::std::os::raw::c_uint,
        __reserved_2: ::std::os::raw::c_uint,
        mask: ::std::os::raw::c_uint,
        __reserved_3: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let vector: u32 = unsafe { ::std::mem::transmute(vector) };
            vector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let delivery_mode: u32 = unsafe { ::std::mem::transmute(delivery_mode) };
            delivery_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let delivery_status: u32 = unsafe { ::std::mem::transmute(delivery_status) };
            delivery_status as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let mask: u32 = unsafe { ::std::mem::transmute(mask) };
            mask as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let __reserved_3: u32 = unsafe { ::std::mem::transmute(__reserved_3) };
            __reserved_3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_32 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __reserved_4: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_32() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_32>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_32))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_32>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_32>())).__reserved_4 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_32),
            "::",
            stringify!(__reserved_4)
        )
    );
}
impl local_apic__bindgen_ty_32 {
    #[inline]
    pub fn vector(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_mode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_mode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mask(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_3(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_3(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vector: ::std::os::raw::c_uint,
        delivery_mode: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
        delivery_status: ::std::os::raw::c_uint,
        __reserved_2: ::std::os::raw::c_uint,
        mask: ::std::os::raw::c_uint,
        __reserved_3: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let vector: u32 = unsafe { ::std::mem::transmute(vector) };
            vector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let delivery_mode: u32 = unsafe { ::std::mem::transmute(delivery_mode) };
            delivery_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let delivery_status: u32 = unsafe { ::std::mem::transmute(delivery_status) };
            delivery_status as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let mask: u32 = unsafe { ::std::mem::transmute(mask) };
            mask as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let __reserved_3: u32 = unsafe { ::std::mem::transmute(__reserved_3) };
            __reserved_3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_33 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __reserved_3: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_33() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_33>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_33))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_33>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_33))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_33>())).__reserved_3 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_33),
            "::",
            stringify!(__reserved_3)
        )
    );
}
impl local_apic__bindgen_ty_33 {
    #[inline]
    pub fn vector(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_mode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_mode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn polarity(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_polarity(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn remote_irr(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_remote_irr(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trigger(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_trigger(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mask(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vector: ::std::os::raw::c_uint,
        delivery_mode: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
        delivery_status: ::std::os::raw::c_uint,
        polarity: ::std::os::raw::c_uint,
        remote_irr: ::std::os::raw::c_uint,
        trigger: ::std::os::raw::c_uint,
        mask: ::std::os::raw::c_uint,
        __reserved_2: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let vector: u32 = unsafe { ::std::mem::transmute(vector) };
            vector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let delivery_mode: u32 = unsafe { ::std::mem::transmute(delivery_mode) };
            delivery_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let delivery_status: u32 = unsafe { ::std::mem::transmute(delivery_status) };
            delivery_status as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let polarity: u32 = unsafe { ::std::mem::transmute(polarity) };
            polarity as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let remote_irr: u32 = unsafe { ::std::mem::transmute(remote_irr) };
            remote_irr as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let trigger: u32 = unsafe { ::std::mem::transmute(trigger) };
            trigger as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let mask: u32 = unsafe { ::std::mem::transmute(mask) };
            mask as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_34 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __reserved_3: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_34() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_34>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_34))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_34>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_34))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_34>())).__reserved_3 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_34),
            "::",
            stringify!(__reserved_3)
        )
    );
}
impl local_apic__bindgen_ty_34 {
    #[inline]
    pub fn vector(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_mode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_mode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn polarity(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_polarity(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn remote_irr(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_remote_irr(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trigger(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_trigger(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mask(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vector: ::std::os::raw::c_uint,
        delivery_mode: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
        delivery_status: ::std::os::raw::c_uint,
        polarity: ::std::os::raw::c_uint,
        remote_irr: ::std::os::raw::c_uint,
        trigger: ::std::os::raw::c_uint,
        mask: ::std::os::raw::c_uint,
        __reserved_2: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let vector: u32 = unsafe { ::std::mem::transmute(vector) };
            vector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let delivery_mode: u32 = unsafe { ::std::mem::transmute(delivery_mode) };
            delivery_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let delivery_status: u32 = unsafe { ::std::mem::transmute(delivery_status) };
            delivery_status as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let polarity: u32 = unsafe { ::std::mem::transmute(polarity) };
            polarity as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let remote_irr: u32 = unsafe { ::std::mem::transmute(remote_irr) };
            remote_irr as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let trigger: u32 = unsafe { ::std::mem::transmute(trigger) };
            trigger as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let mask: u32 = unsafe { ::std::mem::transmute(mask) };
            mask as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_35 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __reserved_4: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_35() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_35>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_35))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_35>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_35))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_35>())).__reserved_4 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_35),
            "::",
            stringify!(__reserved_4)
        )
    );
}
impl local_apic__bindgen_ty_35 {
    #[inline]
    pub fn vector(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mask(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_3(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_3(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vector: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
        delivery_status: ::std::os::raw::c_uint,
        __reserved_2: ::std::os::raw::c_uint,
        mask: ::std::os::raw::c_uint,
        __reserved_3: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let vector: u32 = unsafe { ::std::mem::transmute(vector) };
            vector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let delivery_status: u32 = unsafe { ::std::mem::transmute(delivery_status) };
            delivery_status as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let mask: u32 = unsafe { ::std::mem::transmute(mask) };
            mask as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let __reserved_3: u32 = unsafe { ::std::mem::transmute(__reserved_3) };
            __reserved_3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_36 {
    pub initial_count: ::std::os::raw::c_uint,
    pub __reserved_2: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_36() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_36>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_36))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_36>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_36))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_36>())).initial_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_36),
            "::",
            stringify!(initial_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_36>())).__reserved_2 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_36),
            "::",
            stringify!(__reserved_2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_37 {
    pub curr_count: ::std::os::raw::c_uint,
    pub __reserved_2: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_37() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_37>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_37))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_37>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_37))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_37>())).curr_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_37),
            "::",
            stringify!(curr_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_37>())).__reserved_2 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_37),
            "::",
            stringify!(__reserved_2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_38 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_38() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_38>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_38))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_38>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_38))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_38>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_38),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_39 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_39() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_39>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_39))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_39>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_39))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_39>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_39),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_40 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_40() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_40>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_40))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_40>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_40))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_40>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_40),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_41 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_41() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_41>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_41))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_41>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_41))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_41>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_41),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_42 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __reserved_2: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_42() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_42>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_42))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_42>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_42))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_42>())).__reserved_2 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_42),
            "::",
            stringify!(__reserved_2)
        )
    );
}
impl local_apic__bindgen_ty_42 {
    #[inline]
    pub fn divisor(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_divisor(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        divisor: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let divisor: u32 = unsafe { ::std::mem::transmute(divisor) };
            divisor as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_43 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_43() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_43>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_43))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_43>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_43))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_43>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_43),
            "::",
            stringify!(__reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_local_apic() {
    assert_eq!(
        ::std::mem::size_of::<local_apic>(),
        1024usize,
        concat!("Size of: ", stringify!(local_apic))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic>(),
        1usize,
        concat!("Alignment of ", stringify!(local_apic))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_01 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_01)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_02 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_02)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).id as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).version as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_03 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_03)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_04 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_04)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_05 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_05)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_06 as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_06)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).tpr as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(tpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).apr as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(apr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).ppr as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(ppr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).eoi as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(eoi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_07 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_07)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).ldr as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(ldr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).dfr as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(dfr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).svr as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(svr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).isr as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(isr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).tmr as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(tmr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).irr as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(irr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).esr as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(esr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_08 as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_08)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_09 as *const _ as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_09)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_10 as *const _ as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_11 as *const _ as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_12 as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_13 as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_14 as *const _ as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).icr1 as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(icr1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).icr2 as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(icr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).lvt_timer as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(lvt_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).lvt_thermal as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(lvt_thermal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).lvt_pc as *const _ as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(lvt_pc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).lvt_lint0 as *const _ as usize },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(lvt_lint0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).lvt_lint1 as *const _ as usize },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(lvt_lint1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).lvt_error as *const _ as usize },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(lvt_error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).timer_icr as *const _ as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(timer_icr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).timer_ccr as *const _ as usize },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(timer_ccr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_16 as *const _ as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_17 as *const _ as usize },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_17)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_18 as *const _ as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_18)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_19 as *const _ as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_19)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).timer_dcr as *const _ as usize },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(timer_dcr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_20 as *const _ as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_20)
        )
    );
}
pub const ioapic_irq_destination_types_dest_Fixed: ioapic_irq_destination_types = 0;
pub const ioapic_irq_destination_types_dest_LowestPrio: ioapic_irq_destination_types = 1;
pub const ioapic_irq_destination_types_dest_SMI: ioapic_irq_destination_types = 2;
pub const ioapic_irq_destination_types_dest__reserved_1: ioapic_irq_destination_types = 3;
pub const ioapic_irq_destination_types_dest_NMI: ioapic_irq_destination_types = 4;
pub const ioapic_irq_destination_types_dest_INIT: ioapic_irq_destination_types = 5;
pub const ioapic_irq_destination_types_dest__reserved_2: ioapic_irq_destination_types = 6;
pub const ioapic_irq_destination_types_dest_ExtINT: ioapic_irq_destination_types = 7;
pub type ioapic_irq_destination_types = u32;
extern "C" {
    #[link_name = "\u{1}pic_mode"]
    pub static mut pic_mode: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}mp_bus_not_pci"]
    pub static mut mp_bus_not_pci: [::std::os::raw::c_ulong; 4usize];
}
extern "C" {
    #[link_name = "\u{1}boot_cpu_physical_apicid"]
    pub static mut boot_cpu_physical_apicid: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}boot_cpu_apic_version"]
    pub static mut boot_cpu_apic_version: u8;
}
extern "C" {
    #[link_name = "\u{1}mp_lapic_addr"]
    pub static mut mp_lapic_addr: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}smp_found_config"]
    pub static mut smp_found_config: ::std::os::raw::c_int;
}
extern "C" {
    pub fn e820__memblock_alloc_reserved_mpc_new();
}
extern "C" {
    #[link_name = "\u{1}enable_update_mptable"]
    pub static mut enable_update_mptable: ::std::os::raw::c_int;
}
extern "C" {
    pub fn default_mpc_apic_id(m: *mut mpc_cpu) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn default_smp_read_mpc_oem(mpc: *mut mpc_table);
}
extern "C" {
    pub fn default_mpc_oem_bus_info(m: *mut mpc_bus, str: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn default_find_smp_config();
}
extern "C" {
    pub fn default_get_smp_config(early: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn generic_processor_info(
        apicid: ::std::os::raw::c_int,
        version: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct physid_mask {
    pub mask: [::std::os::raw::c_ulong; 512usize],
}
#[test]
fn bindgen_test_layout_physid_mask() {
    assert_eq!(
        ::std::mem::size_of::<physid_mask>(),
        4096usize,
        concat!("Size of: ", stringify!(physid_mask))
    );
    assert_eq!(
        ::std::mem::align_of::<physid_mask>(),
        8usize,
        concat!("Alignment of ", stringify!(physid_mask))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<physid_mask>())).mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(physid_mask),
            "::",
            stringify!(mask)
        )
    );
}
pub type physid_mask_t = physid_mask;
extern "C" {
    #[link_name = "\u{1}phys_cpu_present_map"]
    pub static mut phys_cpu_present_map: physid_mask_t;
}
extern "C" {
    #[link_name = "\u{1}x86_cpu_to_node_map"]
    pub static mut x86_cpu_to_node_map: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}x86_cpu_to_node_map_early_ptr"]
    pub static mut x86_cpu_to_node_map_early_ptr: *mut ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}x86_cpu_to_node_map_early_map"]
    pub static mut x86_cpu_to_node_map_early_map: [::std::os::raw::c_int; 0usize];
}
extern "C" {
    #[link_name = "\u{1}node_to_cpumask_map"]
    pub static mut node_to_cpumask_map: [cpumask_var_t; 1024usize];
}
extern "C" {
    pub fn setup_node_to_cpumask_map();
}
extern "C" {
    pub fn __node_distance(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cpu_coregroup_mask(cpu: ::std::os::raw::c_int) -> *const cpumask;
}
extern "C" {
    #[link_name = "\u{1}__max_logical_packages"]
    pub static mut __max_logical_packages: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}__max_smt_threads"]
    pub static mut __max_smt_threads: ::std::os::raw::c_int;
}
extern "C" {
    pub fn topology_update_package_map(
        apicid: ::std::os::raw::c_uint,
        cpu: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn topology_phys_to_logical_pkg(pkg: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn topology_is_primary_thread(cpu: ::std::os::raw::c_uint) -> bool_;
}
extern "C" {
    pub fn topology_smt_supported() -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pci_bus {
    _unused: [u8; 0],
}
extern "C" {
    pub fn x86_pci_root_bus_node(bus: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn x86_pci_root_bus_resources(bus: ::std::os::raw::c_int, resources: *mut list_head);
}
extern "C" {
    #[link_name = "\u{1}x86_topology_update"]
    pub static mut x86_topology_update: bool_;
}
extern "C" {
    #[link_name = "\u{1}sched_core_priority"]
    pub static mut sched_core_priority: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}sysctl_sched_itmt_enabled"]
    pub static mut sysctl_sched_itmt_enabled: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sched_set_itmt_core_prio(prio: ::std::os::raw::c_int, core_cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn sched_set_itmt_support() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_clear_itmt_support();
}
extern "C" {
    #[link_name = "\u{1}numa_off"]
    pub static mut numa_off: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__apicid_to_node"]
    pub static mut __apicid_to_node: [s16; 32768usize];
}
extern "C" {
    #[link_name = "\u{1}numa_nodes_parsed"]
    pub static mut numa_nodes_parsed: nodemask_t;
}
extern "C" {
    pub fn numa_add_memblk(
        nodeid: ::std::os::raw::c_int,
        start: __u64,
        end: __u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_set_distance(
        from: ::std::os::raw::c_int,
        to: ::std::os::raw::c_int,
        distance: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn numa_cpu_node(cpu: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_set_node(cpu: ::std::os::raw::c_int, node: ::std::os::raw::c_int);
}
extern "C" {
    pub fn numa_clear_node(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn init_cpu_to_node();
}
extern "C" {
    pub fn numa_add_cpu(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn numa_remove_cpu(cpu: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mm_context_t {
    pub ctx_id: __u64,
    pub tlb_gen: atomic64_t,
    pub ldt_usr_sem: rw_semaphore,
    pub ldt: *mut ldt_struct,
    pub ia32_compat: ::std::os::raw::c_ushort,
    pub lock: mutex,
    pub vdso: *mut ::std::os::raw::c_void,
    pub vdso_image: *mut vdso_image,
    pub perf_rdpmc_allowed: atomic_t,
    pub pkey_allocation_map: u16,
    pub execute_only_pkey: s16,
    pub bd_addr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_mm_context_t() {
    assert_eq!(
        ::std::mem::size_of::<mm_context_t>(),
        136usize,
        concat!("Size of: ", stringify!(mm_context_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mm_context_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mm_context_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_context_t>())).ctx_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(ctx_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_context_t>())).tlb_gen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(tlb_gen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_context_t>())).ldt_usr_sem as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(ldt_usr_sem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_context_t>())).ldt as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(ldt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_context_t>())).ia32_compat as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(ia32_compat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_context_t>())).lock as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_context_t>())).vdso as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(vdso)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_context_t>())).vdso_image as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(vdso_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_context_t>())).perf_rdpmc_allowed as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(perf_rdpmc_allowed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_context_t>())).pkey_allocation_map as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(pkey_allocation_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_context_t>())).execute_only_pkey as *const _ as usize },
        126usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(execute_only_pkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_context_t>())).bd_addr as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(bd_addr)
        )
    );
}
extern "C" {
    pub fn leave_mm(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn early_ioremap(
        phys_addr: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn early_memremap(
        phys_addr: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn early_memremap_ro(
        phys_addr: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn early_memremap_prot(
        phys_addr: resource_size_t,
        size: ::std::os::raw::c_ulong,
        prot_val: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn early_iounmap(addr: *mut ::std::os::raw::c_void, size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn early_memunmap(addr: *mut ::std::os::raw::c_void, size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn early_ioremap_shutdown();
}
extern "C" {
    pub fn early_ioremap_init();
}
extern "C" {
    pub fn early_ioremap_setup();
}
extern "C" {
    pub fn early_ioremap_reset();
}
extern "C" {
    pub fn copy_from_early_mem(
        dest: *mut ::std::os::raw::c_void,
        src: phys_addr_t,
        size: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn valid_phys_addr_range(addr: phys_addr_t, size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn valid_mmap_phys_addr_range(
        pfn: ::std::os::raw::c_ulong,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ioremap_nocache(
        offset: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ioremap_uc(
        offset: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ioremap_cache(
        offset: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ioremap_prot(
        offset: resource_size_t,
        size: ::std::os::raw::c_ulong,
        prot_val: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn iounmap(addr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn set_iounmap_nonlazy();
}
extern "C" {
    pub fn ioread8(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ioread16(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ioread16be(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ioread32(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ioread32be(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ioread64(arg1: *mut ::std::os::raw::c_void) -> __u64;
}
extern "C" {
    pub fn ioread64be(arg1: *mut ::std::os::raw::c_void) -> __u64;
}
extern "C" {
    pub fn iowrite8(arg1: u8, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn iowrite16(arg1: u16, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn iowrite16be(arg1: u16, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn iowrite32(arg1: u32, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn iowrite32be(arg1: u32, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn iowrite64(arg1: __u64, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn iowrite64be(arg1: __u64, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn ioread8_rep(
        port: *mut ::std::os::raw::c_void,
        buf: *mut ::std::os::raw::c_void,
        count: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn ioread16_rep(
        port: *mut ::std::os::raw::c_void,
        buf: *mut ::std::os::raw::c_void,
        count: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn ioread32_rep(
        port: *mut ::std::os::raw::c_void,
        buf: *mut ::std::os::raw::c_void,
        count: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn iowrite8_rep(
        port: *mut ::std::os::raw::c_void,
        buf: *const ::std::os::raw::c_void,
        count: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn iowrite16_rep(
        port: *mut ::std::os::raw::c_void,
        buf: *const ::std::os::raw::c_void,
        count: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn iowrite32_rep(
        port: *mut ::std::os::raw::c_void,
        buf: *const ::std::os::raw::c_void,
        count: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn ioport_map(
        port: ::std::os::raw::c_ulong,
        nr: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ioport_unmap(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pci_iounmap(dev: *mut pci_dev, arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pci_iomap(
        dev: *mut pci_dev,
        bar: ::std::os::raw::c_int,
        max: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pci_iomap_wc(
        dev: *mut pci_dev,
        bar: ::std::os::raw::c_int,
        max: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pci_iomap_range(
        dev: *mut pci_dev,
        bar: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_ulong,
        maxlen: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pci_iomap_wc_range(
        dev: *mut pci_dev,
        bar: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_ulong,
        maxlen: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn native_io_delay();
}
extern "C" {
    #[link_name = "\u{1}io_delay_type"]
    pub static mut io_delay_type: ::std::os::raw::c_int;
}
extern "C" {
    pub fn io_delay_init();
}
extern "C" {
    #[link_name = "\u{1}sev_enable_key"]
    pub static mut sev_enable_key: static_key_false;
}
extern "C" {
    pub fn xlate_dev_mem_ptr(phys: phys_addr_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn unxlate_dev_mem_ptr(phys: phys_addr_t, addr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn ioremap_change_attr(
        vaddr: ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
        pcm: page_cache_mode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ioremap_wc(
        offset: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ioremap_wt(
        offset: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn is_early_ioremap_ptep(ptep: *mut pte_t) -> bool_;
}
pub const xen_domain_type_XEN_NATIVE: xen_domain_type = 0;
pub const xen_domain_type_XEN_PV_DOMAIN: xen_domain_type = 1;
pub const xen_domain_type_XEN_HVM_DOMAIN: xen_domain_type = 2;
pub type xen_domain_type = u32;
extern "C" {
    #[link_name = "\u{1}xen_domain_type"]
    pub static mut xen_domain_type: xen_domain_type;
}
extern "C" {
    #[link_name = "\u{1}xen_pvh"]
    pub static mut xen_pvh: bool_;
}
pub type xen_pfn_t = ::std::os::raw::c_ulong;
pub type xen_ulong_t = ::std::os::raw::c_ulong;
pub type xen_long_t = ::std::os::raw::c_long;
pub type __guest_handle_uchar = *mut ::std::os::raw::c_uchar;
pub type __guest_handle_uint = *mut ::std::os::raw::c_uint;
pub type __guest_handle_char = *mut ::std::os::raw::c_char;
pub type __guest_handle_int = *mut ::std::os::raw::c_int;
pub type __guest_handle_void = *mut ::std::os::raw::c_void;
pub type __guest_handle_uint64_t = *mut u64;
pub type __guest_handle_uint32_t = *mut u32;
pub type __guest_handle_xen_pfn_t = *mut xen_pfn_t;
pub type __guest_handle_xen_ulong_t = *mut xen_ulong_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct trap_info {
    pub vector: u8,
    pub flags: u8,
    pub cs: u16,
    pub address: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_trap_info() {
    assert_eq!(
        ::std::mem::size_of::<trap_info>(),
        16usize,
        concat!("Size of: ", stringify!(trap_info))
    );
    assert_eq!(
        ::std::mem::align_of::<trap_info>(),
        8usize,
        concat!("Alignment of ", stringify!(trap_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trap_info>())).vector as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(trap_info),
            "::",
            stringify!(vector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trap_info>())).flags as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(trap_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trap_info>())).cs as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(trap_info),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trap_info>())).address as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(trap_info),
            "::",
            stringify!(address)
        )
    );
}
pub type __guest_handle_trap_info = *mut trap_info;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct arch_shared_info {
    pub max_pfn: ::std::os::raw::c_ulong,
    pub pfn_to_mfn_frame_list_list: xen_pfn_t,
    pub nmi_reason: ::std::os::raw::c_ulong,
    pub p2m_cr3: ::std::os::raw::c_ulong,
    pub p2m_vaddr: ::std::os::raw::c_ulong,
    pub p2m_generation: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_arch_shared_info() {
    assert_eq!(
        ::std::mem::size_of::<arch_shared_info>(),
        48usize,
        concat!("Size of: ", stringify!(arch_shared_info))
    );
    assert_eq!(
        ::std::mem::align_of::<arch_shared_info>(),
        8usize,
        concat!("Alignment of ", stringify!(arch_shared_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_shared_info>())).max_pfn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_shared_info),
            "::",
            stringify!(max_pfn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<arch_shared_info>())).pfn_to_mfn_frame_list_list as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_shared_info),
            "::",
            stringify!(pfn_to_mfn_frame_list_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_shared_info>())).nmi_reason as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_shared_info),
            "::",
            stringify!(nmi_reason)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_shared_info>())).p2m_cr3 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_shared_info),
            "::",
            stringify!(p2m_cr3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_shared_info>())).p2m_vaddr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_shared_info),
            "::",
            stringify!(p2m_vaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_shared_info>())).p2m_generation as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_shared_info),
            "::",
            stringify!(p2m_generation)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iret_context {
    pub rax: u64,
    pub r11: u64,
    pub rcx: u64,
    pub flags: u64,
    pub rip: u64,
    pub cs: u64,
    pub rflags: u64,
    pub rsp: u64,
    pub ss: u64,
}
#[test]
fn bindgen_test_layout_iret_context() {
    assert_eq!(
        ::std::mem::size_of::<iret_context>(),
        72usize,
        concat!("Size of: ", stringify!(iret_context))
    );
    assert_eq!(
        ::std::mem::align_of::<iret_context>(),
        8usize,
        concat!("Alignment of ", stringify!(iret_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iret_context>())).rax as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iret_context),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iret_context>())).r11 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iret_context),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iret_context>())).rcx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(iret_context),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iret_context>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(iret_context),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iret_context>())).rip as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(iret_context),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iret_context>())).cs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(iret_context),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iret_context>())).rflags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(iret_context),
            "::",
            stringify!(rflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iret_context>())).rsp as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(iret_context),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iret_context>())).ss as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(iret_context),
            "::",
            stringify!(ss)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpu_user_regs {
    pub r15: u64,
    pub r14: u64,
    pub r13: u64,
    pub r12: u64,
    pub __bindgen_anon_1: cpu_user_regs__bindgen_ty_1,
    pub __bindgen_anon_2: cpu_user_regs__bindgen_ty_2,
    pub r11: u64,
    pub r10: u64,
    pub r9: u64,
    pub r8: u64,
    pub __bindgen_anon_3: cpu_user_regs__bindgen_ty_3,
    pub __bindgen_anon_4: cpu_user_regs__bindgen_ty_4,
    pub __bindgen_anon_5: cpu_user_regs__bindgen_ty_5,
    pub __bindgen_anon_6: cpu_user_regs__bindgen_ty_6,
    pub __bindgen_anon_7: cpu_user_regs__bindgen_ty_7,
    pub error_code: u32,
    pub entry_vector: u32,
    pub __bindgen_anon_8: cpu_user_regs__bindgen_ty_8,
    pub cs: u16,
    pub _pad0: [u16; 1usize],
    pub saved_upcall_mask: u8,
    pub _pad1: [u8; 3usize],
    pub __bindgen_anon_9: cpu_user_regs__bindgen_ty_9,
    pub __bindgen_anon_10: cpu_user_regs__bindgen_ty_10,
    pub ss: u16,
    pub _pad2: [u16; 3usize],
    pub es: u16,
    pub _pad3: [u16; 3usize],
    pub ds: u16,
    pub _pad4: [u16; 3usize],
    pub fs: u16,
    pub _pad5: [u16; 3usize],
    pub gs: u16,
    pub _pad6: [u16; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_1 {
    pub rbp: u64,
    pub ebp: u64,
    pub _ebp: u32,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_cpu_user_regs__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cpu_user_regs__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(cpu_user_regs__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_user_regs__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_user_regs__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_1>())).rbp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_1),
            "::",
            stringify!(rbp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_1>())).ebp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_1),
            "::",
            stringify!(ebp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_1>()))._ebp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_1),
            "::",
            stringify!(_ebp)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_2 {
    pub rbx: u64,
    pub ebx: u64,
    pub _ebx: u32,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_cpu_user_regs__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cpu_user_regs__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(cpu_user_regs__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_user_regs__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_user_regs__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_2>())).rbx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_2),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_2>())).ebx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_2),
            "::",
            stringify!(ebx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_2>()))._ebx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_2),
            "::",
            stringify!(_ebx)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_3 {
    pub rax: u64,
    pub eax: u64,
    pub _eax: u32,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_cpu_user_regs__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<cpu_user_regs__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(cpu_user_regs__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_user_regs__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_user_regs__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_3>())).rax as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_3),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_3>())).eax as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_3),
            "::",
            stringify!(eax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_3>()))._eax as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_3),
            "::",
            stringify!(_eax)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_4 {
    pub rcx: u64,
    pub ecx: u64,
    pub _ecx: u32,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_cpu_user_regs__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<cpu_user_regs__bindgen_ty_4>(),
        8usize,
        concat!("Size of: ", stringify!(cpu_user_regs__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_user_regs__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_user_regs__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_4>())).rcx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_4),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_4>())).ecx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_4),
            "::",
            stringify!(ecx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_4>()))._ecx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_4),
            "::",
            stringify!(_ecx)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_5 {
    pub rdx: u64,
    pub edx: u64,
    pub _edx: u32,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_cpu_user_regs__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<cpu_user_regs__bindgen_ty_5>(),
        8usize,
        concat!("Size of: ", stringify!(cpu_user_regs__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_user_regs__bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_user_regs__bindgen_ty_5))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_5>())).rdx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_5),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_5>())).edx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_5),
            "::",
            stringify!(edx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_5>()))._edx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_5),
            "::",
            stringify!(_edx)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_6 {
    pub rsi: u64,
    pub esi: u64,
    pub _esi: u32,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_cpu_user_regs__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<cpu_user_regs__bindgen_ty_6>(),
        8usize,
        concat!("Size of: ", stringify!(cpu_user_regs__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_user_regs__bindgen_ty_6>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_user_regs__bindgen_ty_6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_6>())).rsi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_6),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_6>())).esi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_6),
            "::",
            stringify!(esi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_6>()))._esi as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_6),
            "::",
            stringify!(_esi)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_7 {
    pub rdi: u64,
    pub edi: u64,
    pub _edi: u32,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_cpu_user_regs__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<cpu_user_regs__bindgen_ty_7>(),
        8usize,
        concat!("Size of: ", stringify!(cpu_user_regs__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_user_regs__bindgen_ty_7>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_user_regs__bindgen_ty_7))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_7>())).rdi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_7),
            "::",
            stringify!(rdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_7>())).edi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_7),
            "::",
            stringify!(edi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_7>()))._edi as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_7),
            "::",
            stringify!(_edi)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_8 {
    pub rip: u64,
    pub eip: u64,
    pub _eip: u32,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_cpu_user_regs__bindgen_ty_8() {
    assert_eq!(
        ::std::mem::size_of::<cpu_user_regs__bindgen_ty_8>(),
        8usize,
        concat!("Size of: ", stringify!(cpu_user_regs__bindgen_ty_8))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_user_regs__bindgen_ty_8>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_user_regs__bindgen_ty_8))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_8>())).rip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_8),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_8>())).eip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_8),
            "::",
            stringify!(eip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_8>()))._eip as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_8),
            "::",
            stringify!(_eip)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_9 {
    pub rflags: u64,
    pub eflags: u64,
    pub _eflags: u32,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_cpu_user_regs__bindgen_ty_9() {
    assert_eq!(
        ::std::mem::size_of::<cpu_user_regs__bindgen_ty_9>(),
        8usize,
        concat!("Size of: ", stringify!(cpu_user_regs__bindgen_ty_9))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_user_regs__bindgen_ty_9>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_user_regs__bindgen_ty_9))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_9>())).rflags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_9),
            "::",
            stringify!(rflags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_9>())).eflags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_9),
            "::",
            stringify!(eflags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_9>()))._eflags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_9),
            "::",
            stringify!(_eflags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_10 {
    pub rsp: u64,
    pub esp: u64,
    pub _esp: u32,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_cpu_user_regs__bindgen_ty_10() {
    assert_eq!(
        ::std::mem::size_of::<cpu_user_regs__bindgen_ty_10>(),
        8usize,
        concat!("Size of: ", stringify!(cpu_user_regs__bindgen_ty_10))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_user_regs__bindgen_ty_10>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_user_regs__bindgen_ty_10))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_10>())).rsp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_10),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_10>())).esp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_10),
            "::",
            stringify!(esp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cpu_user_regs__bindgen_ty_10>()))._esp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs__bindgen_ty_10),
            "::",
            stringify!(_esp)
        )
    );
}
#[test]
fn bindgen_test_layout_cpu_user_regs() {
    assert_eq!(
        ::std::mem::size_of::<cpu_user_regs>(),
        200usize,
        concat!("Size of: ", stringify!(cpu_user_regs))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_user_regs>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_user_regs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs>())).r15 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs>())).r14 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs>())).r13 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs>())).r12 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs>())).r11 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs>())).r10 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs>())).r9 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs>())).r8 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs>())).error_code as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs>())).entry_vector as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs),
            "::",
            stringify!(entry_vector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs>())).cs as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs>()))._pad0 as *const _ as usize },
        138usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs),
            "::",
            stringify!(_pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs>())).saved_upcall_mask as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs),
            "::",
            stringify!(saved_upcall_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs>()))._pad1 as *const _ as usize },
        141usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs),
            "::",
            stringify!(_pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs>())).ss as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs>()))._pad2 as *const _ as usize },
        162usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs),
            "::",
            stringify!(_pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs>())).es as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs),
            "::",
            stringify!(es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs>()))._pad3 as *const _ as usize },
        170usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs),
            "::",
            stringify!(_pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs>())).ds as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs),
            "::",
            stringify!(ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs>()))._pad4 as *const _ as usize },
        178usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs),
            "::",
            stringify!(_pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs>())).fs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs>()))._pad5 as *const _ as usize },
        186usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs),
            "::",
            stringify!(_pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs>())).gs as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs),
            "::",
            stringify!(gs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_user_regs>()))._pad6 as *const _ as usize },
        194usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_user_regs),
            "::",
            stringify!(_pad6)
        )
    );
}
pub type __guest_handle_cpu_user_regs = *mut cpu_user_regs;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct arch_vcpu_info {
    pub cr2: ::std::os::raw::c_ulong,
    pub pad: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_arch_vcpu_info() {
    assert_eq!(
        ::std::mem::size_of::<arch_vcpu_info>(),
        16usize,
        concat!("Size of: ", stringify!(arch_vcpu_info))
    );
    assert_eq!(
        ::std::mem::align_of::<arch_vcpu_info>(),
        8usize,
        concat!("Alignment of ", stringify!(arch_vcpu_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_vcpu_info>())).cr2 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_vcpu_info),
            "::",
            stringify!(cr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_vcpu_info>())).pad as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_vcpu_info),
            "::",
            stringify!(pad)
        )
    );
}
pub type xen_callback_t = ::std::os::raw::c_ulong;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct pvclock_vcpu_time_info {
    pub version: u32,
    pub pad0: u32,
    pub tsc_timestamp: __u64,
    pub system_time: __u64,
    pub tsc_to_system_mul: u32,
    pub tsc_shift: s8,
    pub flags: u8,
    pub pad: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_pvclock_vcpu_time_info() {
    assert_eq!(
        ::std::mem::size_of::<pvclock_vcpu_time_info>(),
        32usize,
        concat!("Size of: ", stringify!(pvclock_vcpu_time_info))
    );
    assert_eq!(
        ::std::mem::align_of::<pvclock_vcpu_time_info>(),
        1usize,
        concat!("Alignment of ", stringify!(pvclock_vcpu_time_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvclock_vcpu_time_info>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pvclock_vcpu_time_info),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvclock_vcpu_time_info>())).pad0 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pvclock_vcpu_time_info),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pvclock_vcpu_time_info>())).tsc_timestamp as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pvclock_vcpu_time_info),
            "::",
            stringify!(tsc_timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pvclock_vcpu_time_info>())).system_time as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pvclock_vcpu_time_info),
            "::",
            stringify!(system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pvclock_vcpu_time_info>())).tsc_to_system_mul as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pvclock_vcpu_time_info),
            "::",
            stringify!(tsc_to_system_mul)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pvclock_vcpu_time_info>())).tsc_shift as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pvclock_vcpu_time_info),
            "::",
            stringify!(tsc_shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvclock_vcpu_time_info>())).flags as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(pvclock_vcpu_time_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvclock_vcpu_time_info>())).pad as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(pvclock_vcpu_time_info),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct pvclock_wall_clock {
    pub version: u32,
    pub sec: u32,
    pub nsec: u32,
}
#[test]
fn bindgen_test_layout_pvclock_wall_clock() {
    assert_eq!(
        ::std::mem::size_of::<pvclock_wall_clock>(),
        12usize,
        concat!("Size of: ", stringify!(pvclock_wall_clock))
    );
    assert_eq!(
        ::std::mem::align_of::<pvclock_wall_clock>(),
        1usize,
        concat!("Alignment of ", stringify!(pvclock_wall_clock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvclock_wall_clock>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pvclock_wall_clock),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvclock_wall_clock>())).sec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pvclock_wall_clock),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvclock_wall_clock>())).nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pvclock_wall_clock),
            "::",
            stringify!(nsec)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vcpu_guest_context {
    pub fpu_ctxt: vcpu_guest_context__bindgen_ty_1,
    pub flags: ::std::os::raw::c_ulong,
    pub user_regs: cpu_user_regs,
    pub trap_ctxt: [trap_info; 256usize],
    pub ldt_base: ::std::os::raw::c_ulong,
    pub ldt_ents: ::std::os::raw::c_ulong,
    pub gdt_frames: [::std::os::raw::c_ulong; 16usize],
    pub gdt_ents: ::std::os::raw::c_ulong,
    pub kernel_ss: ::std::os::raw::c_ulong,
    pub kernel_sp: ::std::os::raw::c_ulong,
    pub ctrlreg: [::std::os::raw::c_ulong; 8usize],
    pub debugreg: [::std::os::raw::c_ulong; 8usize],
    pub event_callback_eip: ::std::os::raw::c_ulong,
    pub failsafe_callback_eip: ::std::os::raw::c_ulong,
    pub syscall_callback_eip: ::std::os::raw::c_ulong,
    pub vm_assist: ::std::os::raw::c_ulong,
    pub fs_base: u64,
    pub gs_base_kernel: u64,
    pub gs_base_user: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vcpu_guest_context__bindgen_ty_1 {
    pub x: [::std::os::raw::c_char; 512usize],
}
#[test]
fn bindgen_test_layout_vcpu_guest_context__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vcpu_guest_context__bindgen_ty_1>(),
        512usize,
        concat!("Size of: ", stringify!(vcpu_guest_context__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vcpu_guest_context__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(vcpu_guest_context__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vcpu_guest_context__bindgen_ty_1>())).x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_guest_context__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
}
#[test]
fn bindgen_test_layout_vcpu_guest_context() {
    assert_eq!(
        ::std::mem::size_of::<vcpu_guest_context>(),
        5168usize,
        concat!("Size of: ", stringify!(vcpu_guest_context))
    );
    assert_eq!(
        ::std::mem::align_of::<vcpu_guest_context>(),
        8usize,
        concat!("Alignment of ", stringify!(vcpu_guest_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_guest_context>())).fpu_ctxt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_guest_context),
            "::",
            stringify!(fpu_ctxt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_guest_context>())).flags as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_guest_context),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_guest_context>())).user_regs as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_guest_context),
            "::",
            stringify!(user_regs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_guest_context>())).trap_ctxt as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_guest_context),
            "::",
            stringify!(trap_ctxt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_guest_context>())).ldt_base as *const _ as usize },
        4816usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_guest_context),
            "::",
            stringify!(ldt_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_guest_context>())).ldt_ents as *const _ as usize },
        4824usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_guest_context),
            "::",
            stringify!(ldt_ents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_guest_context>())).gdt_frames as *const _ as usize },
        4832usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_guest_context),
            "::",
            stringify!(gdt_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_guest_context>())).gdt_ents as *const _ as usize },
        4960usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_guest_context),
            "::",
            stringify!(gdt_ents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_guest_context>())).kernel_ss as *const _ as usize },
        4968usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_guest_context),
            "::",
            stringify!(kernel_ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_guest_context>())).kernel_sp as *const _ as usize },
        4976usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_guest_context),
            "::",
            stringify!(kernel_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_guest_context>())).ctrlreg as *const _ as usize },
        4984usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_guest_context),
            "::",
            stringify!(ctrlreg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_guest_context>())).debugreg as *const _ as usize },
        5048usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_guest_context),
            "::",
            stringify!(debugreg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vcpu_guest_context>())).event_callback_eip as *const _ as usize
        },
        5112usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_guest_context),
            "::",
            stringify!(event_callback_eip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vcpu_guest_context>())).failsafe_callback_eip as *const _
                as usize
        },
        5120usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_guest_context),
            "::",
            stringify!(failsafe_callback_eip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vcpu_guest_context>())).syscall_callback_eip as *const _ as usize
        },
        5128usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_guest_context),
            "::",
            stringify!(syscall_callback_eip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_guest_context>())).vm_assist as *const _ as usize },
        5136usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_guest_context),
            "::",
            stringify!(vm_assist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_guest_context>())).fs_base as *const _ as usize },
        5144usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_guest_context),
            "::",
            stringify!(fs_base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vcpu_guest_context>())).gs_base_kernel as *const _ as usize
        },
        5152usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_guest_context),
            "::",
            stringify!(gs_base_kernel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_guest_context>())).gs_base_user as *const _ as usize },
        5160usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_guest_context),
            "::",
            stringify!(gs_base_user)
        )
    );
}
pub type __guest_handle_vcpu_guest_context = *mut vcpu_guest_context;
#[repr(C)]
pub struct xen_pmu_amd_ctxt {
    pub counters: u32,
    pub ctrls: u32,
    pub regs: __IncompleteArrayField<u64>,
}
#[test]
fn bindgen_test_layout_xen_pmu_amd_ctxt() {
    assert_eq!(
        ::std::mem::size_of::<xen_pmu_amd_ctxt>(),
        8usize,
        concat!("Size of: ", stringify!(xen_pmu_amd_ctxt))
    );
    assert_eq!(
        ::std::mem::align_of::<xen_pmu_amd_ctxt>(),
        8usize,
        concat!("Alignment of ", stringify!(xen_pmu_amd_ctxt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_amd_ctxt>())).counters as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_amd_ctxt),
            "::",
            stringify!(counters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_amd_ctxt>())).ctrls as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_amd_ctxt),
            "::",
            stringify!(ctrls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_amd_ctxt>())).regs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_amd_ctxt),
            "::",
            stringify!(regs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xen_pmu_cntr_pair {
    pub counter: u64,
    pub control: u64,
}
#[test]
fn bindgen_test_layout_xen_pmu_cntr_pair() {
    assert_eq!(
        ::std::mem::size_of::<xen_pmu_cntr_pair>(),
        16usize,
        concat!("Size of: ", stringify!(xen_pmu_cntr_pair))
    );
    assert_eq!(
        ::std::mem::align_of::<xen_pmu_cntr_pair>(),
        8usize,
        concat!("Alignment of ", stringify!(xen_pmu_cntr_pair))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_cntr_pair>())).counter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_cntr_pair),
            "::",
            stringify!(counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_cntr_pair>())).control as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_cntr_pair),
            "::",
            stringify!(control)
        )
    );
}
#[repr(C)]
pub struct xen_pmu_intel_ctxt {
    pub fixed_counters: u32,
    pub arch_counters: u32,
    pub global_ctrl: u64,
    pub global_ovf_ctrl: u64,
    pub global_status: u64,
    pub fixed_ctrl: u64,
    pub ds_area: u64,
    pub pebs_enable: u64,
    pub debugctl: u64,
    pub regs: __IncompleteArrayField<u64>,
}
#[test]
fn bindgen_test_layout_xen_pmu_intel_ctxt() {
    assert_eq!(
        ::std::mem::size_of::<xen_pmu_intel_ctxt>(),
        64usize,
        concat!("Size of: ", stringify!(xen_pmu_intel_ctxt))
    );
    assert_eq!(
        ::std::mem::align_of::<xen_pmu_intel_ctxt>(),
        8usize,
        concat!("Alignment of ", stringify!(xen_pmu_intel_ctxt))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xen_pmu_intel_ctxt>())).fixed_counters as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_intel_ctxt),
            "::",
            stringify!(fixed_counters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xen_pmu_intel_ctxt>())).arch_counters as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_intel_ctxt),
            "::",
            stringify!(arch_counters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_intel_ctxt>())).global_ctrl as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_intel_ctxt),
            "::",
            stringify!(global_ctrl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xen_pmu_intel_ctxt>())).global_ovf_ctrl as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_intel_ctxt),
            "::",
            stringify!(global_ovf_ctrl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xen_pmu_intel_ctxt>())).global_status as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_intel_ctxt),
            "::",
            stringify!(global_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_intel_ctxt>())).fixed_ctrl as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_intel_ctxt),
            "::",
            stringify!(fixed_ctrl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_intel_ctxt>())).ds_area as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_intel_ctxt),
            "::",
            stringify!(ds_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_intel_ctxt>())).pebs_enable as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_intel_ctxt),
            "::",
            stringify!(pebs_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_intel_ctxt>())).debugctl as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_intel_ctxt),
            "::",
            stringify!(debugctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_intel_ctxt>())).regs as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_intel_ctxt),
            "::",
            stringify!(regs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xen_pmu_regs {
    pub ip: u64,
    pub sp: u64,
    pub flags: u64,
    pub cs: u16,
    pub ss: u16,
    pub cpl: u8,
    pub pad: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xen_pmu_regs() {
    assert_eq!(
        ::std::mem::size_of::<xen_pmu_regs>(),
        32usize,
        concat!("Size of: ", stringify!(xen_pmu_regs))
    );
    assert_eq!(
        ::std::mem::align_of::<xen_pmu_regs>(),
        8usize,
        concat!("Alignment of ", stringify!(xen_pmu_regs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_regs>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_regs),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_regs>())).sp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_regs),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_regs>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_regs),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_regs>())).cs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_regs),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_regs>())).ss as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_regs),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_regs>())).cpl as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_regs),
            "::",
            stringify!(cpl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_regs>())).pad as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_regs),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
pub struct xen_pmu_arch {
    pub r: xen_pmu_arch__bindgen_ty_1,
    pub pmu_flags: u64,
    pub l: xen_pmu_arch__bindgen_ty_2,
    pub c: xen_pmu_arch__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xen_pmu_arch__bindgen_ty_1 {
    pub regs: xen_pmu_regs,
    pub pad: [u8; 64usize],
    _bindgen_union_align: [u64; 8usize],
}
#[test]
fn bindgen_test_layout_xen_pmu_arch__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<xen_pmu_arch__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(xen_pmu_arch__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<xen_pmu_arch__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(xen_pmu_arch__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_arch__bindgen_ty_1>())).regs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_arch__bindgen_ty_1),
            "::",
            stringify!(regs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_arch__bindgen_ty_1>())).pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_arch__bindgen_ty_1),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xen_pmu_arch__bindgen_ty_2 {
    pub lapic_lvtpc: u32,
    pub pad: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_xen_pmu_arch__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<xen_pmu_arch__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(xen_pmu_arch__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<xen_pmu_arch__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(xen_pmu_arch__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xen_pmu_arch__bindgen_ty_2>())).lapic_lvtpc as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_arch__bindgen_ty_2),
            "::",
            stringify!(lapic_lvtpc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_arch__bindgen_ty_2>())).pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_arch__bindgen_ty_2),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
pub struct xen_pmu_arch__bindgen_ty_3 {
    pub amd: __BindgenUnionField<xen_pmu_amd_ctxt>,
    pub intel: __BindgenUnionField<xen_pmu_intel_ctxt>,
    pub pad: __BindgenUnionField<[u8; 128usize]>,
    pub bindgen_union_field: [u64; 16usize],
}
#[test]
fn bindgen_test_layout_xen_pmu_arch__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<xen_pmu_arch__bindgen_ty_3>(),
        128usize,
        concat!("Size of: ", stringify!(xen_pmu_arch__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<xen_pmu_arch__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(xen_pmu_arch__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_arch__bindgen_ty_3>())).amd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_arch__bindgen_ty_3),
            "::",
            stringify!(amd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xen_pmu_arch__bindgen_ty_3>())).intel as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_arch__bindgen_ty_3),
            "::",
            stringify!(intel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_arch__bindgen_ty_3>())).pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_arch__bindgen_ty_3),
            "::",
            stringify!(pad)
        )
    );
}
#[test]
fn bindgen_test_layout_xen_pmu_arch() {
    assert_eq!(
        ::std::mem::size_of::<xen_pmu_arch>(),
        208usize,
        concat!("Size of: ", stringify!(xen_pmu_arch))
    );
    assert_eq!(
        ::std::mem::align_of::<xen_pmu_arch>(),
        8usize,
        concat!("Alignment of ", stringify!(xen_pmu_arch))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_arch>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_arch),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_arch>())).pmu_flags as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_arch),
            "::",
            stringify!(pmu_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_arch>())).l as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_arch),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_pmu_arch>())).c as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_pmu_arch),
            "::",
            stringify!(c)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mmuext_op {
    pub cmd: ::std::os::raw::c_uint,
    pub arg1: mmuext_op__bindgen_ty_1,
    pub arg2: mmuext_op__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mmuext_op__bindgen_ty_1 {
    pub mfn: xen_pfn_t,
    pub linear_addr: ::std::os::raw::c_ulong,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_mmuext_op__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<mmuext_op__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(mmuext_op__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<mmuext_op__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(mmuext_op__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mmuext_op__bindgen_ty_1>())).mfn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mmuext_op__bindgen_ty_1),
            "::",
            stringify!(mfn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mmuext_op__bindgen_ty_1>())).linear_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mmuext_op__bindgen_ty_1),
            "::",
            stringify!(linear_addr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mmuext_op__bindgen_ty_2 {
    pub nr_ents: ::std::os::raw::c_uint,
    pub vcpumask: *mut ::std::os::raw::c_void,
    pub src_mfn: xen_pfn_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_mmuext_op__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<mmuext_op__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(mmuext_op__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<mmuext_op__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(mmuext_op__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mmuext_op__bindgen_ty_2>())).nr_ents as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mmuext_op__bindgen_ty_2),
            "::",
            stringify!(nr_ents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mmuext_op__bindgen_ty_2>())).vcpumask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mmuext_op__bindgen_ty_2),
            "::",
            stringify!(vcpumask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mmuext_op__bindgen_ty_2>())).src_mfn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mmuext_op__bindgen_ty_2),
            "::",
            stringify!(src_mfn)
        )
    );
}
#[test]
fn bindgen_test_layout_mmuext_op() {
    assert_eq!(
        ::std::mem::size_of::<mmuext_op>(),
        24usize,
        concat!("Size of: ", stringify!(mmuext_op))
    );
    assert_eq!(
        ::std::mem::align_of::<mmuext_op>(),
        8usize,
        concat!("Alignment of ", stringify!(mmuext_op))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mmuext_op>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mmuext_op),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mmuext_op>())).arg1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mmuext_op),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mmuext_op>())).arg2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mmuext_op),
            "::",
            stringify!(arg2)
        )
    );
}
pub type __guest_handle_mmuext_op = *mut mmuext_op;
pub type domid_t = u16;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mmu_update {
    pub ptr: u64,
    pub val: u64,
}
#[test]
fn bindgen_test_layout_mmu_update() {
    assert_eq!(
        ::std::mem::size_of::<mmu_update>(),
        16usize,
        concat!("Size of: ", stringify!(mmu_update))
    );
    assert_eq!(
        ::std::mem::align_of::<mmu_update>(),
        8usize,
        concat!("Alignment of ", stringify!(mmu_update))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mmu_update>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mmu_update),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mmu_update>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mmu_update),
            "::",
            stringify!(val)
        )
    );
}
pub type __guest_handle_mmu_update = *mut mmu_update;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct multicall_entry {
    pub op: xen_ulong_t,
    pub result: xen_long_t,
    pub args: [xen_ulong_t; 6usize],
}
#[test]
fn bindgen_test_layout_multicall_entry() {
    assert_eq!(
        ::std::mem::size_of::<multicall_entry>(),
        64usize,
        concat!("Size of: ", stringify!(multicall_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<multicall_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(multicall_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<multicall_entry>())).op as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multicall_entry),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<multicall_entry>())).result as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multicall_entry),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<multicall_entry>())).args as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(multicall_entry),
            "::",
            stringify!(args)
        )
    );
}
pub type __guest_handle_multicall_entry = *mut multicall_entry;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vcpu_time_info {
    pub version: u32,
    pub pad0: u32,
    pub tsc_timestamp: u64,
    pub system_time: u64,
    pub tsc_to_system_mul: u32,
    pub tsc_shift: i8,
    pub pad1: [i8; 3usize],
}
#[test]
fn bindgen_test_layout_vcpu_time_info() {
    assert_eq!(
        ::std::mem::size_of::<vcpu_time_info>(),
        32usize,
        concat!("Size of: ", stringify!(vcpu_time_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vcpu_time_info>(),
        8usize,
        concat!("Alignment of ", stringify!(vcpu_time_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_time_info>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_time_info),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_time_info>())).pad0 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_time_info),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_time_info>())).tsc_timestamp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_time_info),
            "::",
            stringify!(tsc_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_time_info>())).system_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_time_info),
            "::",
            stringify!(system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vcpu_time_info>())).tsc_to_system_mul as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_time_info),
            "::",
            stringify!(tsc_to_system_mul)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_time_info>())).tsc_shift as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_time_info),
            "::",
            stringify!(tsc_shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_time_info>())).pad1 as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_time_info),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vcpu_info {
    pub evtchn_upcall_pending: u8,
    pub evtchn_upcall_mask: u8,
    pub evtchn_pending_sel: xen_ulong_t,
    pub arch: arch_vcpu_info,
    pub time: pvclock_vcpu_time_info,
}
#[test]
fn bindgen_test_layout_vcpu_info() {
    assert_eq!(
        ::std::mem::size_of::<vcpu_info>(),
        64usize,
        concat!("Size of: ", stringify!(vcpu_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vcpu_info>(),
        8usize,
        concat!("Alignment of ", stringify!(vcpu_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_info>())).evtchn_upcall_pending as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_info),
            "::",
            stringify!(evtchn_upcall_pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_info>())).evtchn_upcall_mask as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_info),
            "::",
            stringify!(evtchn_upcall_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_info>())).evtchn_pending_sel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_info),
            "::",
            stringify!(evtchn_pending_sel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_info>())).arch as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_info),
            "::",
            stringify!(arch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vcpu_info>())).time as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vcpu_info),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct shared_info {
    pub vcpu_info: [vcpu_info; 32usize],
    pub evtchn_pending: [xen_ulong_t; 64usize],
    pub evtchn_mask: [xen_ulong_t; 64usize],
    pub wc: pvclock_wall_clock,
    pub arch: arch_shared_info,
}
#[test]
fn bindgen_test_layout_shared_info() {
    assert_eq!(
        ::std::mem::size_of::<shared_info>(),
        3136usize,
        concat!("Size of: ", stringify!(shared_info))
    );
    assert_eq!(
        ::std::mem::align_of::<shared_info>(),
        8usize,
        concat!("Alignment of ", stringify!(shared_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shared_info>())).vcpu_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(shared_info),
            "::",
            stringify!(vcpu_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shared_info>())).evtchn_pending as *const _ as usize },
        2048usize,
        concat!(
            "Offset of field: ",
            stringify!(shared_info),
            "::",
            stringify!(evtchn_pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shared_info>())).evtchn_mask as *const _ as usize },
        2560usize,
        concat!(
            "Offset of field: ",
            stringify!(shared_info),
            "::",
            stringify!(evtchn_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shared_info>())).wc as *const _ as usize },
        3072usize,
        concat!(
            "Offset of field: ",
            stringify!(shared_info),
            "::",
            stringify!(wc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shared_info>())).arch as *const _ as usize },
        3088usize,
        concat!(
            "Offset of field: ",
            stringify!(shared_info),
            "::",
            stringify!(arch)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct start_info {
    pub magic: [::std::os::raw::c_char; 32usize],
    pub nr_pages: ::std::os::raw::c_ulong,
    pub shared_info: ::std::os::raw::c_ulong,
    pub flags: u32,
    pub store_mfn: xen_pfn_t,
    pub store_evtchn: u32,
    pub console: start_info__bindgen_ty_1,
    pub pt_base: ::std::os::raw::c_ulong,
    pub nr_pt_frames: ::std::os::raw::c_ulong,
    pub mfn_list: ::std::os::raw::c_ulong,
    pub mod_start: ::std::os::raw::c_ulong,
    pub mod_len: ::std::os::raw::c_ulong,
    pub cmd_line: [i8; 1024usize],
    pub first_p2m_pfn: ::std::os::raw::c_ulong,
    pub nr_p2m_frames: ::std::os::raw::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union start_info__bindgen_ty_1 {
    pub domU: start_info__bindgen_ty_1__bindgen_ty_1,
    pub dom0: start_info__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct start_info__bindgen_ty_1__bindgen_ty_1 {
    pub mfn: xen_pfn_t,
    pub evtchn: u32,
}
#[test]
fn bindgen_test_layout_start_info__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<start_info__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(start_info__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<start_info__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(start_info__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<start_info__bindgen_ty_1__bindgen_ty_1>())).mfn as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(start_info__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(mfn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<start_info__bindgen_ty_1__bindgen_ty_1>())).evtchn as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(start_info__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(evtchn)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct start_info__bindgen_ty_1__bindgen_ty_2 {
    pub info_off: u32,
    pub info_size: u32,
}
#[test]
fn bindgen_test_layout_start_info__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<start_info__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(start_info__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<start_info__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(start_info__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<start_info__bindgen_ty_1__bindgen_ty_2>())).info_off as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(start_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(info_off)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<start_info__bindgen_ty_1__bindgen_ty_2>())).info_size as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(start_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(info_size)
        )
    );
}
#[test]
fn bindgen_test_layout_start_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<start_info__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(start_info__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<start_info__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(start_info__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<start_info__bindgen_ty_1>())).domU as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(start_info__bindgen_ty_1),
            "::",
            stringify!(domU)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<start_info__bindgen_ty_1>())).dom0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(start_info__bindgen_ty_1),
            "::",
            stringify!(dom0)
        )
    );
}
#[test]
fn bindgen_test_layout_start_info() {
    assert_eq!(
        ::std::mem::size_of::<start_info>(),
        1168usize,
        concat!("Size of: ", stringify!(start_info))
    );
    assert_eq!(
        ::std::mem::align_of::<start_info>(),
        8usize,
        concat!("Alignment of ", stringify!(start_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<start_info>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(start_info),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<start_info>())).nr_pages as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(start_info),
            "::",
            stringify!(nr_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<start_info>())).shared_info as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(start_info),
            "::",
            stringify!(shared_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<start_info>())).flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(start_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<start_info>())).store_mfn as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(start_info),
            "::",
            stringify!(store_mfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<start_info>())).store_evtchn as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(start_info),
            "::",
            stringify!(store_evtchn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<start_info>())).console as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(start_info),
            "::",
            stringify!(console)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<start_info>())).pt_base as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(start_info),
            "::",
            stringify!(pt_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<start_info>())).nr_pt_frames as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(start_info),
            "::",
            stringify!(nr_pt_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<start_info>())).mfn_list as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(start_info),
            "::",
            stringify!(mfn_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<start_info>())).mod_start as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(start_info),
            "::",
            stringify!(mod_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<start_info>())).mod_len as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(start_info),
            "::",
            stringify!(mod_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<start_info>())).cmd_line as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(start_info),
            "::",
            stringify!(cmd_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<start_info>())).first_p2m_pfn as *const _ as usize },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(start_info),
            "::",
            stringify!(first_p2m_pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<start_info>())).nr_p2m_frames as *const _ as usize },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(start_info),
            "::",
            stringify!(nr_p2m_frames)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xen_multiboot_mod_list {
    pub mod_start: u32,
    pub mod_end: u32,
    pub cmdline: u32,
    pub pad: u32,
}
#[test]
fn bindgen_test_layout_xen_multiboot_mod_list() {
    assert_eq!(
        ::std::mem::size_of::<xen_multiboot_mod_list>(),
        16usize,
        concat!("Size of: ", stringify!(xen_multiboot_mod_list))
    );
    assert_eq!(
        ::std::mem::align_of::<xen_multiboot_mod_list>(),
        4usize,
        concat!("Alignment of ", stringify!(xen_multiboot_mod_list))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xen_multiboot_mod_list>())).mod_start as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_multiboot_mod_list),
            "::",
            stringify!(mod_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_multiboot_mod_list>())).mod_end as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_multiboot_mod_list),
            "::",
            stringify!(mod_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_multiboot_mod_list>())).cmdline as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_multiboot_mod_list),
            "::",
            stringify!(cmdline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xen_multiboot_mod_list>())).pad as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xen_multiboot_mod_list),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dom0_vga_console_info {
    pub video_type: u8,
    pub u: dom0_vga_console_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dom0_vga_console_info__bindgen_ty_1 {
    pub text_mode_3: dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1,
    pub vesa_lfb: dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u32; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1 {
    pub font_height: u16,
    pub cursor_x: u16,
    pub cursor_y: u16,
    pub rows: u16,
    pub columns: u16,
}
#[test]
fn bindgen_test_layout_dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1>(),
        10usize,
        concat!(
            "Size of: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1>()))
                .font_height as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(font_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1>())).cursor_x
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(cursor_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1>())).cursor_y
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(cursor_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1>())).rows
                as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1>())).columns
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(columns)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2 {
    pub width: u16,
    pub height: u16,
    pub bytes_per_line: u16,
    pub bits_per_pixel: u16,
    pub lfb_base: u32,
    pub lfb_size: u32,
    pub red_pos: u8,
    pub red_size: u8,
    pub green_pos: u8,
    pub green_size: u8,
    pub blue_pos: u8,
    pub blue_size: u8,
    pub rsvd_pos: u8,
    pub rsvd_size: u8,
    pub gbl_caps: u32,
    pub mode_attrs: u16,
}
#[test]
fn bindgen_test_layout_dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2>())).width
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2>())).height
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2>()))
                .bytes_per_line as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(bytes_per_line)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2>()))
                .bits_per_pixel as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(bits_per_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2>())).lfb_base
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(lfb_base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2>())).lfb_size
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(lfb_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2>())).red_pos
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(red_pos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2>())).red_size
                as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(red_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2>())).green_pos
                as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(green_pos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2>())).green_size
                as *const _ as usize
        },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(green_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2>())).blue_pos
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(blue_pos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2>())).blue_size
                as *const _ as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(blue_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2>())).rsvd_pos
                as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(rsvd_pos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2>())).rsvd_size
                as *const _ as usize
        },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(rsvd_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2>())).gbl_caps
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(gbl_caps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2>())).mode_attrs
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(mode_attrs)
        )
    );
}
#[test]
fn bindgen_test_layout_dom0_vga_console_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<dom0_vga_console_info__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(dom0_vga_console_info__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<dom0_vga_console_info__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(dom0_vga_console_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dom0_vga_console_info__bindgen_ty_1>())).text_mode_3 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1),
            "::",
            stringify!(text_mode_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dom0_vga_console_info__bindgen_ty_1>())).vesa_lfb as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info__bindgen_ty_1),
            "::",
            stringify!(vesa_lfb)
        )
    );
}
#[test]
fn bindgen_test_layout_dom0_vga_console_info() {
    assert_eq!(
        ::std::mem::size_of::<dom0_vga_console_info>(),
        36usize,
        concat!("Size of: ", stringify!(dom0_vga_console_info))
    );
    assert_eq!(
        ::std::mem::align_of::<dom0_vga_console_info>(),
        4usize,
        concat!("Alignment of ", stringify!(dom0_vga_console_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dom0_vga_console_info>())).video_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info),
            "::",
            stringify!(video_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dom0_vga_console_info>())).u as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dom0_vga_console_info),
            "::",
            stringify!(u)
        )
    );
}
pub type cpumap_t = u64;
pub type xen_domain_handle_t = [u8; 16usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tmem_op {
    pub cmd: u32,
    pub pool_id: i32,
    pub u: tmem_op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tmem_op__bindgen_ty_1 {
    pub new: tmem_op__bindgen_ty_1__bindgen_ty_1,
    pub gen: tmem_op__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tmem_op__bindgen_ty_1__bindgen_ty_1 {
    pub uuid: [u64; 2usize],
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_tmem_op__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<tmem_op__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(tmem_op__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<tmem_op__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(tmem_op__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tmem_op__bindgen_ty_1__bindgen_ty_1>())).uuid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tmem_op__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tmem_op__bindgen_ty_1__bindgen_ty_1>())).flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tmem_op__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tmem_op__bindgen_ty_1__bindgen_ty_2 {
    pub oid: [u64; 3usize],
    pub index: u32,
    pub tmem_offset: u32,
    pub pfn_offset: u32,
    pub len: u32,
    pub gmfn: __guest_handle_void,
}
#[test]
fn bindgen_test_layout_tmem_op__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<tmem_op__bindgen_ty_1__bindgen_ty_2>(),
        48usize,
        concat!("Size of: ", stringify!(tmem_op__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<tmem_op__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(tmem_op__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tmem_op__bindgen_ty_1__bindgen_ty_2>())).oid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tmem_op__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(oid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tmem_op__bindgen_ty_1__bindgen_ty_2>())).index as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tmem_op__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tmem_op__bindgen_ty_1__bindgen_ty_2>())).tmem_offset as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tmem_op__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(tmem_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tmem_op__bindgen_ty_1__bindgen_ty_2>())).pfn_offset as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tmem_op__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(pfn_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tmem_op__bindgen_ty_1__bindgen_ty_2>())).len as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(tmem_op__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tmem_op__bindgen_ty_1__bindgen_ty_2>())).gmfn as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tmem_op__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(gmfn)
        )
    );
}
#[test]
fn bindgen_test_layout_tmem_op__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<tmem_op__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(tmem_op__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<tmem_op__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(tmem_op__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tmem_op__bindgen_ty_1>())).new as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tmem_op__bindgen_ty_1),
            "::",
            stringify!(new)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tmem_op__bindgen_ty_1>())).gen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tmem_op__bindgen_ty_1),
            "::",
            stringify!(gen)
        )
    );
}
#[test]
fn bindgen_test_layout_tmem_op() {
    assert_eq!(
        ::std::mem::size_of::<tmem_op>(),
        56usize,
        concat!("Size of: ", stringify!(tmem_op))
    );
    assert_eq!(
        ::std::mem::align_of::<tmem_op>(),
        8usize,
        concat!("Alignment of ", stringify!(tmem_op))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tmem_op>())).cmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tmem_op),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tmem_op>())).pool_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tmem_op),
            "::",
            stringify!(pool_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tmem_op>())).u as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tmem_op),
            "::",
            stringify!(u)
        )
    );
}
pub type __guest_handle___u64 = *mut __u64;
extern "C" {
    #[link_name = "\u{1}HYPERVISOR_shared_info"]
    pub static mut HYPERVISOR_shared_info: *mut shared_info;
}
extern "C" {
    #[link_name = "\u{1}xen_start_info"]
    pub static mut xen_start_info: *mut start_info;
}
extern "C" {
    pub fn xen_hvm_need_lapic() -> bool_;
}
extern "C" {
    pub fn xen_arch_register_cpu(num: ::std::os::raw::c_int);
}
extern "C" {
    pub fn xen_arch_unregister_cpu(num: ::std::os::raw::c_int);
}
extern "C" {
    pub fn xen_set_iopl_mask(mask: ::std::os::raw::c_uint);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio_vec {
    _unused: [u8; 0],
}
extern "C" {
    pub fn xen_biovec_phys_mergeable(vec1: *const bio_vec, vec2: *const bio_vec) -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fwnode_handle {
    pub secondary: *mut fwnode_handle,
    pub ops: *const fwnode_operations,
}
#[test]
fn bindgen_test_layout_fwnode_handle() {
    assert_eq!(
        ::std::mem::size_of::<fwnode_handle>(),
        16usize,
        concat!("Size of: ", stringify!(fwnode_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<fwnode_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(fwnode_handle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_handle>())).secondary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_handle),
            "::",
            stringify!(secondary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_handle>())).ops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_handle),
            "::",
            stringify!(ops)
        )
    );
}
#[doc = " struct fwnode_endpoint - Fwnode graph endpoint"]
#[doc = " @port: Port number"]
#[doc = " @id: Endpoint id"]
#[doc = " @local_fwnode: reference to the related fwnode"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fwnode_endpoint {
    pub port: ::std::os::raw::c_uint,
    pub id: ::std::os::raw::c_uint,
    pub local_fwnode: *const fwnode_handle,
}
#[test]
fn bindgen_test_layout_fwnode_endpoint() {
    assert_eq!(
        ::std::mem::size_of::<fwnode_endpoint>(),
        16usize,
        concat!("Size of: ", stringify!(fwnode_endpoint))
    );
    assert_eq!(
        ::std::mem::align_of::<fwnode_endpoint>(),
        8usize,
        concat!("Alignment of ", stringify!(fwnode_endpoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_endpoint>())).port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_endpoint),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_endpoint>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_endpoint),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_endpoint>())).local_fwnode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_endpoint),
            "::",
            stringify!(local_fwnode)
        )
    );
}
#[doc = " struct fwnode_reference_args - Fwnode reference with additional arguments"]
#[doc = " @fwnode:- A reference to the base fwnode"]
#[doc = " @nargs: Number of elements in @args array"]
#[doc = " @args: Integer arguments on the fwnode"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fwnode_reference_args {
    pub fwnode: *mut fwnode_handle,
    pub nargs: ::std::os::raw::c_uint,
    pub args: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout_fwnode_reference_args() {
    assert_eq!(
        ::std::mem::size_of::<fwnode_reference_args>(),
        48usize,
        concat!("Size of: ", stringify!(fwnode_reference_args))
    );
    assert_eq!(
        ::std::mem::align_of::<fwnode_reference_args>(),
        8usize,
        concat!("Alignment of ", stringify!(fwnode_reference_args))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_reference_args>())).fwnode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_reference_args),
            "::",
            stringify!(fwnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_reference_args>())).nargs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_reference_args),
            "::",
            stringify!(nargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_reference_args>())).args as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_reference_args),
            "::",
            stringify!(args)
        )
    );
}
#[doc = " struct fwnode_operations - Operations for fwnode interface"]
#[doc = " @get: Get a reference to an fwnode."]
#[doc = " @put: Put a reference to an fwnode."]
#[doc = " @property_present: Return true if a property is present."]
#[doc = " @property_read_integer_array: Read an array of integer properties. Return"]
#[doc = "\t\t\t\t zero on success, a negative error code"]
#[doc = "\t\t\t\t otherwise."]
#[doc = " @property_read_string_array: Read an array of string properties. Return zero"]
#[doc = "\t\t\t\ton success, a negative error code otherwise."]
#[doc = " @get_parent: Return the parent of an fwnode."]
#[doc = " @get_next_child_node: Return the next child node in an iteration."]
#[doc = " @get_named_child_node: Return a child node with a given name."]
#[doc = " @get_reference_args: Return a reference pointed to by a property, with args"]
#[doc = " @graph_get_next_endpoint: Return an endpoint node in an iteration."]
#[doc = " @graph_get_remote_endpoint: Return the remote endpoint node of a local"]
#[doc = "\t\t\t       endpoint node."]
#[doc = " @graph_get_port_parent: Return the parent node of a port node."]
#[doc = " @graph_parse_endpoint: Parse endpoint for port and endpoint id."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fwnode_operations {
    pub get: ::std::option::Option<
        unsafe extern "C" fn(fwnode: *mut fwnode_handle) -> *mut fwnode_handle,
    >,
    pub put: ::std::option::Option<unsafe extern "C" fn(fwnode: *mut fwnode_handle)>,
    pub device_is_available:
        ::std::option::Option<unsafe extern "C" fn(fwnode: *const fwnode_handle) -> bool_>,
    pub property_present: ::std::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            propname: *const ::std::os::raw::c_char,
        ) -> bool_,
    >,
    pub property_read_int_array: ::std::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            propname: *const ::std::os::raw::c_char,
            elem_size: ::std::os::raw::c_uint,
            val: *mut ::std::os::raw::c_void,
            nval: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub property_read_string_array: ::std::option::Option<
        unsafe extern "C" fn(
            fwnode_handle: *const fwnode_handle,
            propname: *const ::std::os::raw::c_char,
            val: *mut *const ::std::os::raw::c_char,
            nval: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_parent: ::std::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *mut fwnode_handle,
    >,
    pub get_next_child_node: ::std::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            child: *mut fwnode_handle,
        ) -> *mut fwnode_handle,
    >,
    pub get_named_child_node: ::std::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            name: *const ::std::os::raw::c_char,
        ) -> *mut fwnode_handle,
    >,
    pub get_reference_args: ::std::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            prop: *const ::std::os::raw::c_char,
            nargs_prop: *const ::std::os::raw::c_char,
            nargs: ::std::os::raw::c_uint,
            index: ::std::os::raw::c_uint,
            args: *mut fwnode_reference_args,
        ) -> ::std::os::raw::c_int,
    >,
    pub graph_get_next_endpoint: ::std::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            prev: *mut fwnode_handle,
        ) -> *mut fwnode_handle,
    >,
    pub graph_get_remote_endpoint: ::std::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *mut fwnode_handle,
    >,
    pub graph_get_port_parent: ::std::option::Option<
        unsafe extern "C" fn(fwnode: *mut fwnode_handle) -> *mut fwnode_handle,
    >,
    pub graph_parse_endpoint: ::std::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            endpoint: *mut fwnode_endpoint,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_fwnode_operations() {
    assert_eq!(
        ::std::mem::size_of::<fwnode_operations>(),
        112usize,
        concat!("Size of: ", stringify!(fwnode_operations))
    );
    assert_eq!(
        ::std::mem::align_of::<fwnode_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(fwnode_operations))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_operations>())).get as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_operations>())).put as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(put)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).device_is_available as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(device_is_available)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).property_present as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(property_present)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).property_read_int_array as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(property_read_int_array)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).property_read_string_array as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(property_read_string_array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_operations>())).get_parent as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(get_parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).get_next_child_node as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(get_next_child_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).get_named_child_node as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(get_named_child_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).get_reference_args as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(get_reference_args)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).graph_get_next_endpoint as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(graph_get_next_endpoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).graph_get_remote_endpoint as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(graph_get_remote_endpoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).graph_get_port_parent as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(graph_get_port_parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).graph_parse_endpoint as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(graph_parse_endpoint)
        )
    );
}
pub const LOGIC_PIO_INDIRECT: _bindgen_ty_13 = 0;
pub const LOGIC_PIO_CPU_MMIO: _bindgen_ty_13 = 1;
pub type _bindgen_ty_13 = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct logic_pio_hwaddr {
    pub list: list_head,
    pub fwnode: *mut fwnode_handle,
    pub hw_start: resource_size_t,
    pub io_start: resource_size_t,
    pub size: resource_size_t,
    pub flags: ::std::os::raw::c_ulong,
    pub hostdata: *mut ::std::os::raw::c_void,
    pub ops: *const logic_pio_host_ops,
}
#[test]
fn bindgen_test_layout_logic_pio_hwaddr() {
    assert_eq!(
        ::std::mem::size_of::<logic_pio_hwaddr>(),
        72usize,
        concat!("Size of: ", stringify!(logic_pio_hwaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<logic_pio_hwaddr>(),
        8usize,
        concat!("Alignment of ", stringify!(logic_pio_hwaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<logic_pio_hwaddr>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(logic_pio_hwaddr),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<logic_pio_hwaddr>())).fwnode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(logic_pio_hwaddr),
            "::",
            stringify!(fwnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<logic_pio_hwaddr>())).hw_start as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(logic_pio_hwaddr),
            "::",
            stringify!(hw_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<logic_pio_hwaddr>())).io_start as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(logic_pio_hwaddr),
            "::",
            stringify!(io_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<logic_pio_hwaddr>())).size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(logic_pio_hwaddr),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<logic_pio_hwaddr>())).flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(logic_pio_hwaddr),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<logic_pio_hwaddr>())).hostdata as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(logic_pio_hwaddr),
            "::",
            stringify!(hostdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<logic_pio_hwaddr>())).ops as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(logic_pio_hwaddr),
            "::",
            stringify!(ops)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct logic_pio_host_ops {
    pub in_: ::std::option::Option<
        unsafe extern "C" fn(
            hostdata: *mut ::std::os::raw::c_void,
            addr: ::std::os::raw::c_ulong,
            dwidth: usize,
        ) -> u32,
    >,
    pub out: ::std::option::Option<
        unsafe extern "C" fn(
            hostdata: *mut ::std::os::raw::c_void,
            addr: ::std::os::raw::c_ulong,
            val: u32,
            dwidth: usize,
        ),
    >,
    pub ins: ::std::option::Option<
        unsafe extern "C" fn(
            hostdata: *mut ::std::os::raw::c_void,
            addr: ::std::os::raw::c_ulong,
            buffer: *mut ::std::os::raw::c_void,
            dwidth: usize,
            count: ::std::os::raw::c_uint,
        ) -> u32,
    >,
    pub outs: ::std::option::Option<
        unsafe extern "C" fn(
            hostdata: *mut ::std::os::raw::c_void,
            addr: ::std::os::raw::c_ulong,
            buffer: *const ::std::os::raw::c_void,
            dwidth: usize,
            count: ::std::os::raw::c_uint,
        ),
    >,
}
#[test]
fn bindgen_test_layout_logic_pio_host_ops() {
    assert_eq!(
        ::std::mem::size_of::<logic_pio_host_ops>(),
        32usize,
        concat!("Size of: ", stringify!(logic_pio_host_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<logic_pio_host_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(logic_pio_host_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<logic_pio_host_ops>())).in_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(logic_pio_host_ops),
            "::",
            stringify!(in_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<logic_pio_host_ops>())).out as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(logic_pio_host_ops),
            "::",
            stringify!(out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<logic_pio_host_ops>())).ins as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(logic_pio_host_ops),
            "::",
            stringify!(ins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<logic_pio_host_ops>())).outs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(logic_pio_host_ops),
            "::",
            stringify!(outs)
        )
    );
}
extern "C" {
    pub fn find_io_range_by_fwnode(fwnode: *mut fwnode_handle) -> *mut logic_pio_hwaddr;
}
extern "C" {
    pub fn logic_pio_trans_hwaddr(
        fwnode: *mut fwnode_handle,
        hw_addr: resource_size_t,
        size: resource_size_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn logic_pio_register_range(newrange: *mut logic_pio_hwaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn logic_pio_unregister_range(range: *mut logic_pio_hwaddr);
}
extern "C" {
    pub fn logic_pio_to_hwaddr(pio: ::std::os::raw::c_ulong) -> resource_size_t;
}
extern "C" {
    pub fn logic_pio_trans_cpuaddr(hw_addr: resource_size_t) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct llist_head {
    pub first: *mut llist_node,
}
#[test]
fn bindgen_test_layout_llist_head() {
    assert_eq!(
        ::std::mem::size_of::<llist_head>(),
        8usize,
        concat!("Size of: ", stringify!(llist_head))
    );
    assert_eq!(
        ::std::mem::align_of::<llist_head>(),
        8usize,
        concat!("Alignment of ", stringify!(llist_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<llist_head>())).first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llist_head),
            "::",
            stringify!(first)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct llist_node {
    pub next: *mut llist_node,
}
#[test]
fn bindgen_test_layout_llist_node() {
    assert_eq!(
        ::std::mem::size_of::<llist_node>(),
        8usize,
        concat!("Size of: ", stringify!(llist_node))
    );
    assert_eq!(
        ::std::mem::align_of::<llist_node>(),
        8usize,
        concat!("Alignment of ", stringify!(llist_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<llist_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llist_node),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn llist_add_batch(
        new_first: *mut llist_node,
        new_last: *mut llist_node,
        head: *mut llist_head,
    ) -> bool_;
}
extern "C" {
    pub fn llist_del_first(head: *mut llist_head) -> *mut llist_node;
}
extern "C" {
    pub fn llist_reverse_order(head: *mut llist_node) -> *mut llist_node;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_node {
    pub __rb_parent_color: ::std::os::raw::c_ulong,
    pub rb_right: *mut rb_node,
    pub rb_left: *mut rb_node,
}
#[test]
fn bindgen_test_layout_rb_node() {
    assert_eq!(
        ::std::mem::size_of::<rb_node>(),
        24usize,
        concat!("Size of: ", stringify!(rb_node))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_node>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rb_node>())).__rb_parent_color as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_node),
            "::",
            stringify!(__rb_parent_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rb_node>())).rb_right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_node),
            "::",
            stringify!(rb_right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rb_node>())).rb_left as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_node),
            "::",
            stringify!(rb_left)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_root {
    pub rb_node: *mut rb_node,
}
#[test]
fn bindgen_test_layout_rb_root() {
    assert_eq!(
        ::std::mem::size_of::<rb_root>(),
        8usize,
        concat!("Size of: ", stringify!(rb_root))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_root>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_root))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rb_root>())).rb_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_root),
            "::",
            stringify!(rb_node)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_root_cached {
    pub rb_root: rb_root,
    pub rb_leftmost: *mut rb_node,
}
#[test]
fn bindgen_test_layout_rb_root_cached() {
    assert_eq!(
        ::std::mem::size_of::<rb_root_cached>(),
        16usize,
        concat!("Size of: ", stringify!(rb_root_cached))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_root_cached>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_root_cached))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rb_root_cached>())).rb_root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_root_cached),
            "::",
            stringify!(rb_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rb_root_cached>())).rb_leftmost as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_root_cached),
            "::",
            stringify!(rb_leftmost)
        )
    );
}
extern "C" {
    pub fn rb_insert_color(arg1: *mut rb_node, arg2: *mut rb_root);
}
extern "C" {
    pub fn rb_erase(arg1: *mut rb_node, arg2: *mut rb_root);
}
extern "C" {
    pub fn rb_next(arg1: *const rb_node) -> *mut rb_node;
}
extern "C" {
    pub fn rb_prev(arg1: *const rb_node) -> *mut rb_node;
}
extern "C" {
    pub fn rb_first(arg1: *const rb_root) -> *mut rb_node;
}
extern "C" {
    pub fn rb_last(arg1: *const rb_root) -> *mut rb_node;
}
extern "C" {
    pub fn rb_insert_color_cached(arg1: *mut rb_node, arg2: *mut rb_root_cached, arg3: bool_);
}
extern "C" {
    pub fn rb_erase_cached(node: *mut rb_node, arg1: *mut rb_root_cached);
}
extern "C" {
    pub fn rb_first_postorder(arg1: *const rb_root) -> *mut rb_node;
}
extern "C" {
    pub fn rb_next_postorder(arg1: *const rb_node) -> *mut rb_node;
}
extern "C" {
    pub fn rb_replace_node(victim: *mut rb_node, new: *mut rb_node, root: *mut rb_root);
}
extern "C" {
    pub fn rb_replace_node_rcu(victim: *mut rb_node, new: *mut rb_node, root: *mut rb_root);
}
extern "C" {
    pub fn rb_replace_node_cached(
        victim: *mut rb_node,
        new: *mut rb_node,
        root: *mut rb_root_cached,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_struct {
    pub next: *mut vm_struct,
    pub addr: *mut ::std::os::raw::c_void,
    pub size: ::std::os::raw::c_ulong,
    pub flags: ::std::os::raw::c_ulong,
    pub pages: *mut *mut page,
    pub nr_pages: ::std::os::raw::c_uint,
    pub phys_addr: phys_addr_t,
    pub caller: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vm_struct() {
    assert_eq!(
        ::std::mem::size_of::<vm_struct>(),
        64usize,
        concat!("Size of: ", stringify!(vm_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<vm_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).pages as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).nr_pages as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(nr_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).phys_addr as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(phys_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).caller as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(caller)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vmap_area {
    pub va_start: ::std::os::raw::c_ulong,
    pub va_end: ::std::os::raw::c_ulong,
    pub flags: ::std::os::raw::c_ulong,
    pub rb_node: rb_node,
    pub list: list_head,
    pub purge_list: llist_node,
    pub vm: *mut vm_struct,
    pub callback_head: callback_head,
}
#[test]
fn bindgen_test_layout_vmap_area() {
    assert_eq!(
        ::std::mem::size_of::<vmap_area>(),
        96usize,
        concat!("Size of: ", stringify!(vmap_area))
    );
    assert_eq!(
        ::std::mem::align_of::<vmap_area>(),
        8usize,
        concat!("Alignment of ", stringify!(vmap_area))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmap_area>())).va_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vmap_area),
            "::",
            stringify!(va_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmap_area>())).va_end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vmap_area),
            "::",
            stringify!(va_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmap_area>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vmap_area),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmap_area>())).rb_node as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vmap_area),
            "::",
            stringify!(rb_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmap_area>())).list as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vmap_area),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmap_area>())).purge_list as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vmap_area),
            "::",
            stringify!(purge_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmap_area>())).vm as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vmap_area),
            "::",
            stringify!(vm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmap_area>())).callback_head as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vmap_area),
            "::",
            stringify!(callback_head)
        )
    );
}
extern "C" {
    pub fn vm_unmap_ram(mem: *const ::std::os::raw::c_void, count: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn vm_map_ram(
        pages: *mut *mut page,
        count: ::std::os::raw::c_uint,
        node: ::std::os::raw::c_int,
        prot: pgprot_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vm_unmap_aliases();
}
extern "C" {
    pub fn vmalloc_init();
}
extern "C" {
    pub fn vmalloc(size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vzalloc(size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vmalloc_user(size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vmalloc_node(
        size: ::std::os::raw::c_ulong,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vzalloc_node(
        size: ::std::os::raw::c_ulong,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vmalloc_exec(size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vmalloc_32(size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vmalloc_32_user(size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __vmalloc(
        size: ::std::os::raw::c_ulong,
        gfp_mask: gfp_t,
        prot: pgprot_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __vmalloc_node_range(
        size: ::std::os::raw::c_ulong,
        align: ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_ulong,
        end: ::std::os::raw::c_ulong,
        gfp_mask: gfp_t,
        prot: pgprot_t,
        vm_flags: ::std::os::raw::c_ulong,
        node: ::std::os::raw::c_int,
        caller: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __vmalloc_node_flags_caller(
        size: ::std::os::raw::c_ulong,
        node: ::std::os::raw::c_int,
        flags: gfp_t,
        caller: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vfree(addr: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn vfree_atomic(addr: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn vmap(
        pages: *mut *mut page,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_ulong,
        prot: pgprot_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vunmap(addr: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn remap_vmalloc_range_partial(
        vma: *mut vm_area_struct,
        uaddr: ::std::os::raw::c_ulong,
        kaddr: *mut ::std::os::raw::c_void,
        pgoff: ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remap_vmalloc_range(
        vma: *mut vm_area_struct,
        addr: *mut ::std::os::raw::c_void,
        pgoff: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vmalloc_sync_mappings();
}
extern "C" {
    pub fn vmalloc_sync_unmappings();
}
extern "C" {
    pub fn get_vm_area(
        size: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
    ) -> *mut vm_struct;
}
extern "C" {
    pub fn get_vm_area_caller(
        size: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
        caller: *const ::std::os::raw::c_void,
    ) -> *mut vm_struct;
}
extern "C" {
    pub fn __get_vm_area(
        size: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_ulong,
        end: ::std::os::raw::c_ulong,
    ) -> *mut vm_struct;
}
extern "C" {
    pub fn __get_vm_area_caller(
        size: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_ulong,
        end: ::std::os::raw::c_ulong,
        caller: *const ::std::os::raw::c_void,
    ) -> *mut vm_struct;
}
extern "C" {
    pub fn remove_vm_area(addr: *const ::std::os::raw::c_void) -> *mut vm_struct;
}
extern "C" {
    pub fn find_vm_area(addr: *const ::std::os::raw::c_void) -> *mut vm_struct;
}
extern "C" {
    pub fn map_vm_area(
        area: *mut vm_struct,
        prot: pgprot_t,
        pages: *mut *mut page,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn map_kernel_range_noflush(
        start: ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
        prot: pgprot_t,
        pages: *mut *mut page,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unmap_kernel_range_noflush(addr: ::std::os::raw::c_ulong, size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn unmap_kernel_range(addr: ::std::os::raw::c_ulong, size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn alloc_vm_area(size: usize, ptes: *mut *mut pte_t) -> *mut vm_struct;
}
extern "C" {
    pub fn free_vm_area(area: *mut vm_struct);
}
extern "C" {
    pub fn vread(
        buf: *mut ::std::os::raw::c_char,
        addr: *mut ::std::os::raw::c_char,
        count: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn vwrite(
        buf: *mut ::std::os::raw::c_char,
        addr: *mut ::std::os::raw::c_char,
        count: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}vmap_area_list"]
    pub static mut vmap_area_list: list_head;
}
extern "C" {
    pub fn vm_area_add_early(vm: *mut vm_struct);
}
extern "C" {
    pub fn vm_area_register_early(vm: *mut vm_struct, align: usize);
}
extern "C" {
    pub fn pcpu_get_vm_areas(
        offsets: *const ::std::os::raw::c_ulong,
        sizes: *const usize,
        nr_vms: ::std::os::raw::c_int,
        align: usize,
    ) -> *mut *mut vm_struct;
}
extern "C" {
    pub fn pcpu_free_vm_areas(vms: *mut *mut vm_struct, nr_vms: ::std::os::raw::c_int);
}
extern "C" {
    pub fn register_vmap_purge_notifier(nb: *mut notifier_block) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unregister_vmap_purge_notifier(nb: *mut notifier_block) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arch_phys_wc_index(handle: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arch_phys_wc_add(
        base: ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arch_phys_wc_del(handle: ::std::os::raw::c_int);
}
extern "C" {
    pub fn arch_io_reserve_memtype_wc(
        start: resource_size_t,
        size: resource_size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arch_io_free_memtype_wc(start: resource_size_t, size: resource_size_t);
}
extern "C" {
    pub fn arch_memremap_can_ram_remap(
        offset: resource_size_t,
        size: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn phys_mem_access_encrypted(
        phys_addr: ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    ) -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct real_mode_header {
    pub text_start: u32,
    pub ro_end: u32,
    pub trampoline_start: u32,
    pub trampoline_status: u32,
    pub trampoline_header: u32,
    pub trampoline_pgd: u32,
    pub wakeup_start: u32,
    pub wakeup_header: u32,
    pub machine_real_restart_asm: u32,
    pub machine_real_restart_seg: u32,
}
#[test]
fn bindgen_test_layout_real_mode_header() {
    assert_eq!(
        ::std::mem::size_of::<real_mode_header>(),
        40usize,
        concat!("Size of: ", stringify!(real_mode_header))
    );
    assert_eq!(
        ::std::mem::align_of::<real_mode_header>(),
        4usize,
        concat!("Alignment of ", stringify!(real_mode_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<real_mode_header>())).text_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(real_mode_header),
            "::",
            stringify!(text_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<real_mode_header>())).ro_end as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(real_mode_header),
            "::",
            stringify!(ro_end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<real_mode_header>())).trampoline_start as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(real_mode_header),
            "::",
            stringify!(trampoline_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<real_mode_header>())).trampoline_status as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(real_mode_header),
            "::",
            stringify!(trampoline_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<real_mode_header>())).trampoline_header as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(real_mode_header),
            "::",
            stringify!(trampoline_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<real_mode_header>())).trampoline_pgd as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(real_mode_header),
            "::",
            stringify!(trampoline_pgd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<real_mode_header>())).wakeup_start as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(real_mode_header),
            "::",
            stringify!(wakeup_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<real_mode_header>())).wakeup_header as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(real_mode_header),
            "::",
            stringify!(wakeup_header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<real_mode_header>())).machine_real_restart_asm as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(real_mode_header),
            "::",
            stringify!(machine_real_restart_asm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<real_mode_header>())).machine_real_restart_seg as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(real_mode_header),
            "::",
            stringify!(machine_real_restart_seg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct trampoline_header {
    pub start: __u64,
    pub efer: __u64,
    pub cr4: u32,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_trampoline_header() {
    assert_eq!(
        ::std::mem::size_of::<trampoline_header>(),
        24usize,
        concat!("Size of: ", stringify!(trampoline_header))
    );
    assert_eq!(
        ::std::mem::align_of::<trampoline_header>(),
        8usize,
        concat!("Alignment of ", stringify!(trampoline_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trampoline_header>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(trampoline_header),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trampoline_header>())).efer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(trampoline_header),
            "::",
            stringify!(efer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trampoline_header>())).cr4 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(trampoline_header),
            "::",
            stringify!(cr4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trampoline_header>())).flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(trampoline_header),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}real_mode_header"]
    pub static mut real_mode_header: *mut real_mode_header;
}
extern "C" {
    #[link_name = "\u{1}real_mode_blob_end"]
    pub static mut real_mode_blob_end: [::std::os::raw::c_uchar; 0usize];
}
extern "C" {
    #[link_name = "\u{1}initial_code"]
    pub static mut initial_code: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}initial_gs"]
    pub static mut initial_gs: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}initial_stack"]
    pub static mut initial_stack: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}real_mode_blob"]
    pub static mut real_mode_blob: [::std::os::raw::c_uchar; 0usize];
}
extern "C" {
    #[link_name = "\u{1}real_mode_relocs"]
    pub static mut real_mode_relocs: [::std::os::raw::c_uchar; 0usize];
}
extern "C" {
    #[link_name = "\u{1}secondary_startup_64"]
    pub static mut secondary_startup_64: [::std::os::raw::c_uchar; 0usize];
}
extern "C" {
    pub fn set_real_mode_mem(mem: phys_addr_t, size: usize);
}
extern "C" {
    pub fn reserve_real_mode();
}
extern "C" {
    #[link_name = "\u{1}acpi_lapic"]
    pub static mut acpi_lapic: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}acpi_ioapic"]
    pub static mut acpi_ioapic: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}acpi_noirq"]
    pub static mut acpi_noirq: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}acpi_strict"]
    pub static mut acpi_strict: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}acpi_disabled"]
    pub static mut acpi_disabled: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}acpi_pci_disabled"]
    pub static mut acpi_pci_disabled: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}acpi_skip_timer_override"]
    pub static mut acpi_skip_timer_override: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}acpi_use_timer_override"]
    pub static mut acpi_use_timer_override: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}acpi_fix_pin2_polarity"]
    pub static mut acpi_fix_pin2_polarity: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}acpi_disable_cmcff"]
    pub static mut acpi_disable_cmcff: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}acpi_sci_flags"]
    pub static mut acpi_sci_flags: u8;
}
extern "C" {
    #[link_name = "\u{1}acpi_sci_override_gsi"]
    pub static mut acpi_sci_override_gsi: ::std::os::raw::c_int;
}
extern "C" {
    pub fn acpi_pic_sci_set_trigger(arg1: ::std::os::raw::c_uint, arg2: u16);
}
extern "C" {
    #[link_name = "\u{1}__acpi_register_gsi"]
    pub static mut __acpi_register_gsi: ::std::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            gsi: u32,
            trigger: ::std::os::raw::c_int,
            polarity: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    #[link_name = "\u{1}__acpi_unregister_gsi"]
    pub static mut __acpi_unregister_gsi: ::std::option::Option<unsafe extern "C" fn(gsi: u32)>;
}
extern "C" {
    pub fn acpi_gsi_to_irq(gsi: u32, irq: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}acpi_suspend_lowlevel"]
    pub static mut acpi_suspend_lowlevel:
        ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn x86_acpi_numa_init() -> ::std::os::raw::c_int;
}
pub const vsyscall_num___NR_vgettimeofday: vsyscall_num = 0;
pub const vsyscall_num___NR_vtime: vsyscall_num = 1;
pub const vsyscall_num___NR_vgetcpu: vsyscall_num = 2;
pub type vsyscall_num = u32;
pub const fixed_addresses_VSYSCALL_PAGE: fixed_addresses = 511;
pub const fixed_addresses_FIX_DBGP_BASE: fixed_addresses = 512;
pub const fixed_addresses_FIX_EARLYCON_MEM_BASE: fixed_addresses = 513;
pub const fixed_addresses_FIX_APIC_BASE: fixed_addresses = 514;
pub const fixed_addresses_FIX_IO_APIC_BASE_0: fixed_addresses = 515;
pub const fixed_addresses_FIX_IO_APIC_BASE_END: fixed_addresses = 642;
pub const fixed_addresses_FIX_PARAVIRT_BOOTMAP: fixed_addresses = 643;
pub const fixed_addresses_FIX_TEXT_POKE1: fixed_addresses = 644;
pub const fixed_addresses_FIX_TEXT_POKE0: fixed_addresses = 645;
pub const fixed_addresses_FIX_APEI_GHES_IRQ: fixed_addresses = 646;
pub const fixed_addresses_FIX_APEI_GHES_NMI: fixed_addresses = 647;
pub const fixed_addresses___end_of_permanent_fixed_addresses: fixed_addresses = 648;
pub const fixed_addresses_FIX_BTMAP_END: fixed_addresses = 1024;
pub const fixed_addresses_FIX_BTMAP_BEGIN: fixed_addresses = 1535;
pub const fixed_addresses_FIX_TBOOT_BASE: fixed_addresses = 1536;
pub const fixed_addresses___end_of_fixed_addresses: fixed_addresses = 1537;
pub type fixed_addresses = u32;
extern "C" {
    pub fn reserve_top_address(reserve: ::std::os::raw::c_ulong);
}
extern "C" {
    #[link_name = "\u{1}fixmaps_set"]
    pub static mut fixmaps_set: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}kmap_pte"]
    pub static mut kmap_pte: *mut pte_t;
}
extern "C" {
    #[link_name = "\u{1}pkmap_page_table"]
    pub static mut pkmap_page_table: *mut pte_t;
}
extern "C" {
    pub fn __native_set_fixmap(idx: fixed_addresses, pte: pte_t);
}
extern "C" {
    pub fn native_set_fixmap(idx: ::std::os::raw::c_uint, phys: phys_addr_t, flags: pgprot_t);
}
extern "C" {
    pub fn early_memremap_encrypted(
        phys_addr: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn early_memremap_encrypted_wp(
        phys_addr: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn early_memremap_decrypted(
        phys_addr: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn early_memremap_decrypted_wp(
        phys_addr: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __early_set_fixmap(idx: fixed_addresses, phys: phys_addr_t, flags: pgprot_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_cpustat_t {
    pub __softirq_pending: u16,
    pub kvm_cpu_l1tf_flush_l1d: u8,
    pub __nmi_count: ::std::os::raw::c_uint,
    pub apic_timer_irqs: ::std::os::raw::c_uint,
    pub irq_spurious_count: ::std::os::raw::c_uint,
    pub icr_read_retry_count: ::std::os::raw::c_uint,
    pub kvm_posted_intr_ipis: ::std::os::raw::c_uint,
    pub kvm_posted_intr_wakeup_ipis: ::std::os::raw::c_uint,
    pub kvm_posted_intr_nested_ipis: ::std::os::raw::c_uint,
    pub x86_platform_ipis: ::std::os::raw::c_uint,
    pub apic_perf_irqs: ::std::os::raw::c_uint,
    pub apic_irq_work_irqs: ::std::os::raw::c_uint,
    pub irq_resched_count: ::std::os::raw::c_uint,
    pub irq_call_count: ::std::os::raw::c_uint,
    pub irq_tlb_count: ::std::os::raw::c_uint,
    pub irq_thermal_count: ::std::os::raw::c_uint,
    pub irq_threshold_count: ::std::os::raw::c_uint,
    pub irq_deferred_error_count: ::std::os::raw::c_uint,
    pub irq_hv_callback_count: ::std::os::raw::c_uint,
    pub __bindgen_padding_0: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_irq_cpustat_t() {
    assert_eq!(
        ::std::mem::size_of::<irq_cpustat_t>(),
        128usize,
        concat!("Size of: ", stringify!(irq_cpustat_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<irq_cpustat_t>())).__softirq_pending as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_cpustat_t),
            "::",
            stringify!(__softirq_pending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<irq_cpustat_t>())).kvm_cpu_l1tf_flush_l1d as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_cpustat_t),
            "::",
            stringify!(kvm_cpu_l1tf_flush_l1d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<irq_cpustat_t>())).__nmi_count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_cpustat_t),
            "::",
            stringify!(__nmi_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<irq_cpustat_t>())).apic_timer_irqs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_cpustat_t),
            "::",
            stringify!(apic_timer_irqs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<irq_cpustat_t>())).irq_spurious_count as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_cpustat_t),
            "::",
            stringify!(irq_spurious_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<irq_cpustat_t>())).icr_read_retry_count as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_cpustat_t),
            "::",
            stringify!(icr_read_retry_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<irq_cpustat_t>())).kvm_posted_intr_ipis as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_cpustat_t),
            "::",
            stringify!(kvm_posted_intr_ipis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<irq_cpustat_t>())).kvm_posted_intr_wakeup_ipis as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_cpustat_t),
            "::",
            stringify!(kvm_posted_intr_wakeup_ipis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<irq_cpustat_t>())).kvm_posted_intr_nested_ipis as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_cpustat_t),
            "::",
            stringify!(kvm_posted_intr_nested_ipis)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<irq_cpustat_t>())).x86_platform_ipis as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_cpustat_t),
            "::",
            stringify!(x86_platform_ipis)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<irq_cpustat_t>())).apic_perf_irqs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_cpustat_t),
            "::",
            stringify!(apic_perf_irqs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<irq_cpustat_t>())).apic_irq_work_irqs as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_cpustat_t),
            "::",
            stringify!(apic_irq_work_irqs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<irq_cpustat_t>())).irq_resched_count as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_cpustat_t),
            "::",
            stringify!(irq_resched_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<irq_cpustat_t>())).irq_call_count as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_cpustat_t),
            "::",
            stringify!(irq_call_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<irq_cpustat_t>())).irq_tlb_count as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_cpustat_t),
            "::",
            stringify!(irq_tlb_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<irq_cpustat_t>())).irq_thermal_count as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_cpustat_t),
            "::",
            stringify!(irq_thermal_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<irq_cpustat_t>())).irq_threshold_count as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_cpustat_t),
            "::",
            stringify!(irq_threshold_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<irq_cpustat_t>())).irq_deferred_error_count as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_cpustat_t),
            "::",
            stringify!(irq_deferred_error_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<irq_cpustat_t>())).irq_hv_callback_count as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_cpustat_t),
            "::",
            stringify!(irq_hv_callback_count)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}irq_stat"]
    pub static mut irq_stat: irq_cpustat_t;
}
extern "C" {
    pub fn ack_bad_irq(irq: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn arch_irq_stat_cpu(cpu: ::std::os::raw::c_uint) -> __u64;
}
extern "C" {
    pub fn arch_irq_stat() -> __u64;
}
extern "C" {
    #[link_name = "\u{1}apic_verbosity"]
    pub static mut apic_verbosity: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}local_apic_timer_c2_ok"]
    pub static mut local_apic_timer_c2_ok: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}disable_apic"]
    pub static mut disable_apic: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}lapic_timer_frequency"]
    pub static mut lapic_timer_frequency: ::std::os::raw::c_uint;
}
pub const apic_intr_mode_id_APIC_PIC: apic_intr_mode_id = 0;
pub const apic_intr_mode_id_APIC_VIRTUAL_WIRE: apic_intr_mode_id = 1;
pub const apic_intr_mode_id_APIC_VIRTUAL_WIRE_NO_CONFIG: apic_intr_mode_id = 2;
pub const apic_intr_mode_id_APIC_SYMMETRIC_IO: apic_intr_mode_id = 3;
pub const apic_intr_mode_id_APIC_SYMMETRIC_IO_NO_ROUTING: apic_intr_mode_id = 4;
pub type apic_intr_mode_id = i32;
extern "C" {
    #[link_name = "\u{1}apic_intr_mode"]
    pub static mut apic_intr_mode: apic_intr_mode_id;
}
extern "C" {
    pub fn __inquire_remote_apic(apicid: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setup_profiling_timer(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn native_apic_wait_icr_idle();
}
extern "C" {
    pub fn native_safe_apic_wait_icr_idle() -> u32;
}
extern "C" {
    pub fn native_apic_icr_write(low: u32, id: u32);
}
extern "C" {
    pub fn native_apic_icr_read() -> __u64;
}
extern "C" {
    pub fn enable_IR_x2apic();
}
extern "C" {
    pub fn get_physical_broadcast() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lapic_get_maxlvt() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clear_local_APIC();
}
extern "C" {
    pub fn disconnect_bsp_APIC(virt_wire_setup: ::std::os::raw::c_int);
}
extern "C" {
    pub fn disable_local_APIC();
}
extern "C" {
    pub fn lapic_shutdown();
}
extern "C" {
    pub fn sync_Arb_IDs();
}
extern "C" {
    pub fn init_bsp_APIC();
}
extern "C" {
    pub fn apic_intr_mode_select();
}
extern "C" {
    pub fn apic_intr_mode_init();
}
extern "C" {
    pub fn setup_local_APIC();
}
extern "C" {
    pub fn init_apic_mappings();
}
extern "C" {
    pub fn register_lapic_address(address: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn setup_boot_APIC_clock();
}
extern "C" {
    pub fn setup_secondary_APIC_clock();
}
extern "C" {
    pub fn lapic_update_tsc_freq();
}
extern "C" {
    pub fn apic_bsp_setup(upmode: bool_);
}
extern "C" {
    pub fn apic_ap_setup();
}
extern "C" {
    pub fn apic_is_clustered_box() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setup_APIC_eilvt(
        lvt_off: u8,
        vector: u8,
        msg_type: u8,
        mask: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lapic_assign_system_vectors();
}
extern "C" {
    pub fn lapic_assign_legacy_vector(isairq: ::std::os::raw::c_uint, replace: bool_);
}
extern "C" {
    pub fn lapic_online();
}
extern "C" {
    pub fn lapic_offline();
}
extern "C" {
    pub fn apic_needs_pit() -> bool_;
}
extern "C" {
    #[link_name = "\u{1}x2apic_mode"]
    pub static mut x2apic_mode: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}x2apic_phys"]
    pub static mut x2apic_phys: ::std::os::raw::c_int;
}
extern "C" {
    pub fn x2apic_set_max_apicid(apicid: u32);
}
extern "C" {
    pub fn check_x2apic();
}
extern "C" {
    pub fn x2apic_setup();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct apic {
    pub eoi_write: ::std::option::Option<unsafe extern "C" fn(reg: u32, v: u32)>,
    pub native_eoi_write: ::std::option::Option<unsafe extern "C" fn(reg: u32, v: u32)>,
    pub write: ::std::option::Option<unsafe extern "C" fn(reg: u32, v: u32)>,
    pub read: ::std::option::Option<unsafe extern "C" fn(reg: u32) -> u32>,
    pub wait_icr_idle: ::std::option::Option<unsafe extern "C" fn()>,
    pub safe_wait_icr_idle: ::std::option::Option<unsafe extern "C" fn() -> u32>,
    pub send_IPI: ::std::option::Option<
        unsafe extern "C" fn(cpu: ::std::os::raw::c_int, vector: ::std::os::raw::c_int),
    >,
    pub send_IPI_mask: ::std::option::Option<
        unsafe extern "C" fn(mask: *const cpumask, vector: ::std::os::raw::c_int),
    >,
    pub send_IPI_mask_allbutself: ::std::option::Option<
        unsafe extern "C" fn(msk: *const cpumask, vec: ::std::os::raw::c_int),
    >,
    pub send_IPI_allbutself:
        ::std::option::Option<unsafe extern "C" fn(vector: ::std::os::raw::c_int)>,
    pub send_IPI_all: ::std::option::Option<unsafe extern "C" fn(vector: ::std::os::raw::c_int)>,
    pub send_IPI_self: ::std::option::Option<unsafe extern "C" fn(vector: ::std::os::raw::c_int)>,
    pub dest_logical: u32,
    pub disable_esr: u32,
    pub irq_delivery_mode: u32,
    pub irq_dest_mode: u32,
    pub vector_allocation_domain: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: ::std::os::raw::c_int,
            retmask: *mut cpumask,
            mask: *const cpumask,
        ),
    >,
    pub cpu_mask_to_apicid: ::std::option::Option<
        unsafe extern "C" fn(
            cpumask: *const cpumask,
            irqdata: *mut irq_data,
            apicid: *mut ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub calc_dest_apicid:
        ::std::option::Option<unsafe extern "C" fn(cpu: ::std::os::raw::c_uint) -> u32>,
    pub icr_read: ::std::option::Option<unsafe extern "C" fn() -> __u64>,
    pub icr_write: ::std::option::Option<unsafe extern "C" fn(low: u32, high: u32)>,
    pub probe: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub acpi_madt_oem_check: ::std::option::Option<
        unsafe extern "C" fn(
            oem_id: *mut ::std::os::raw::c_char,
            oem_table_id: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub apic_id_valid:
        ::std::option::Option<unsafe extern "C" fn(apicid: u32) -> ::std::os::raw::c_int>,
    pub apic_id_registered: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub check_apicid_used: ::std::option::Option<
        unsafe extern "C" fn(map: *mut physid_mask_t, apicid: ::std::os::raw::c_int) -> bool_,
    >,
    pub init_apic_ldr: ::std::option::Option<unsafe extern "C" fn()>,
    pub ioapic_phys_id_map: ::std::option::Option<
        unsafe extern "C" fn(phys_map: *mut physid_mask_t, retmap: *mut physid_mask_t),
    >,
    pub setup_apic_routing: ::std::option::Option<unsafe extern "C" fn()>,
    pub cpu_present_to_apicid: ::std::option::Option<
        unsafe extern "C" fn(mps_cpu: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >,
    pub apicid_to_cpu_present: ::std::option::Option<
        unsafe extern "C" fn(phys_apicid: ::std::os::raw::c_int, retmap: *mut physid_mask_t),
    >,
    pub check_phys_apicid_present: ::std::option::Option<
        unsafe extern "C" fn(phys_apicid: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >,
    pub phys_pkg_id: ::std::option::Option<
        unsafe extern "C" fn(
            cpuid_apic: ::std::os::raw::c_int,
            index_msb: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_apic_id: ::std::option::Option<unsafe extern "C" fn(x: ::std::os::raw::c_ulong) -> u32>,
    pub set_apic_id: ::std::option::Option<unsafe extern "C" fn(id: ::std::os::raw::c_uint) -> u32>,
    pub wakeup_secondary_cpu: ::std::option::Option<
        unsafe extern "C" fn(
            apicid: ::std::os::raw::c_int,
            start_eip: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_int,
    >,
    pub inquire_remote_apic:
        ::std::option::Option<unsafe extern "C" fn(apicid: ::std::os::raw::c_int)>,
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_apic() {
    assert_eq!(
        ::std::mem::size_of::<apic>(),
        288usize,
        concat!("Size of: ", stringify!(apic))
    );
    assert_eq!(
        ::std::mem::align_of::<apic>(),
        8usize,
        concat!("Alignment of ", stringify!(apic))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).eoi_write as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(eoi_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).native_eoi_write as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(native_eoi_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).write as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).read as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).wait_icr_idle as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(wait_icr_idle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).safe_wait_icr_idle as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(safe_wait_icr_idle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).send_IPI as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(send_IPI)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).send_IPI_mask as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(send_IPI_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).send_IPI_mask_allbutself as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(send_IPI_mask_allbutself)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).send_IPI_allbutself as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(send_IPI_allbutself)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).send_IPI_all as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(send_IPI_all)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).send_IPI_self as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(send_IPI_self)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).dest_logical as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(dest_logical)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).disable_esr as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(disable_esr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).irq_delivery_mode as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(irq_delivery_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).irq_dest_mode as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(irq_dest_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).vector_allocation_domain as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(vector_allocation_domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).cpu_mask_to_apicid as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(cpu_mask_to_apicid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).calc_dest_apicid as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(calc_dest_apicid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).icr_read as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(icr_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).icr_write as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(icr_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).probe as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(probe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).acpi_madt_oem_check as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(acpi_madt_oem_check)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).apic_id_valid as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(apic_id_valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).apic_id_registered as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(apic_id_registered)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).check_apicid_used as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(check_apicid_used)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).init_apic_ldr as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(init_apic_ldr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).ioapic_phys_id_map as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(ioapic_phys_id_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).setup_apic_routing as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(setup_apic_routing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).cpu_present_to_apicid as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(cpu_present_to_apicid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).apicid_to_cpu_present as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(apicid_to_cpu_present)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).check_phys_apicid_present as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(check_phys_apicid_present)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).phys_pkg_id as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(phys_pkg_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).get_apic_id as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(get_apic_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).set_apic_id as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(set_apic_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).wakeup_secondary_cpu as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(wakeup_secondary_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).inquire_remote_apic as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(inquire_remote_apic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apic>())).name as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(apic),
            "::",
            stringify!(name)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}apic"]
    pub static mut apic: *mut apic;
}
extern "C" {
    #[link_name = "\u{1}__apicdrivers"]
    pub static mut __apicdrivers: [*mut apic; 0usize];
}
extern "C" {
    #[link_name = "\u{1}__apicdrivers_end"]
    pub static mut __apicdrivers_end: [*mut apic; 0usize];
}
extern "C" {
    pub fn wakeup_secondary_cpu_via_nmi(
        apicid: ::std::os::raw::c_int,
        start_eip: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lapic_can_unplug_cpu() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn apic_set_eoi_write(
        eoi_write: ::std::option::Option<unsafe extern "C" fn(reg: u32, v: u32)>,
    );
}
extern "C" {
    pub fn apic_ack_irq(data: *mut irq_data);
}
extern "C" {
    pub fn apic_send_IPI_self(vector: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}x2apic_extra_bits"]
    pub static mut x2apic_extra_bits: ::std::os::raw::c_int;
}
extern "C" {
    pub fn generic_bigsmp_probe();
}
extern "C" {
    #[link_name = "\u{1}x86_bios_cpu_apicid"]
    pub static mut x86_bios_cpu_apicid: ::std::os::raw::c_ushort;
}
extern "C" {
    #[link_name = "\u{1}x86_bios_cpu_apicid_early_ptr"]
    pub static mut x86_bios_cpu_apicid_early_ptr: *mut ::std::os::raw::c_ushort;
}
extern "C" {
    #[link_name = "\u{1}x86_bios_cpu_apicid_early_map"]
    pub static mut x86_bios_cpu_apicid_early_map: [::std::os::raw::c_ushort; 0usize];
}
extern "C" {
    #[link_name = "\u{1}apic_noop"]
    pub static mut apic_noop: apic;
}
extern "C" {
    pub fn default_apic_id_valid(apicid: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn default_acpi_madt_oem_check(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn default_setup_apic_routing();
}
extern "C" {
    pub fn apic_default_calc_apicid(cpu: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn apic_flat_calc_apicid(cpu: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn flat_cpu_mask_to_apicid(
        cpumask: *const cpumask,
        irqdata: *mut irq_data,
        apicid: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn default_cpu_mask_to_apicid(
        cpumask: *const cpumask,
        irqdata: *mut irq_data,
        apicid: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn default_check_apicid_used(
        map: *mut physid_mask_t,
        apicid: ::std::os::raw::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn flat_vector_allocation_domain(
        cpu: ::std::os::raw::c_int,
        retmask: *mut cpumask,
        mask: *const cpumask,
    );
}
extern "C" {
    pub fn default_vector_allocation_domain(
        cpu: ::std::os::raw::c_int,
        retmask: *mut cpumask,
        mask: *const cpumask,
    );
}
extern "C" {
    pub fn default_ioapic_phys_id_map(phys_map: *mut physid_mask_t, retmap: *mut physid_mask_t);
}
extern "C" {
    pub fn default_cpu_present_to_apicid(mps_cpu: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn default_check_phys_apicid_present(
        phys_apicid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn apic_id_is_primary_thread(id: ::std::os::raw::c_uint) -> bool_;
}
extern "C" {
    pub fn apic_id_disabled(id: ::std::os::raw::c_uint) -> bool_;
}
extern "C" {
    pub fn irq_enter();
}
extern "C" {
    pub fn irq_exit();
}
extern "C" {
    pub fn ioapic_zap_locks();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IO_APIC_reg_00 {
    pub raw: u32,
    pub bits: IO_APIC_reg_00__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct IO_APIC_reg_00__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_IO_APIC_reg_00__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<IO_APIC_reg_00__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(IO_APIC_reg_00__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<IO_APIC_reg_00__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(IO_APIC_reg_00__bindgen_ty_1))
    );
}
impl IO_APIC_reg_00__bindgen_ty_1 {
    #[inline]
    pub fn __reserved_2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn LTS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LTS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ID(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ID(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __reserved_2: u32,
        LTS: u32,
        delivery_type: u32,
        __reserved_1: u32,
        ID: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let LTS: u32 = unsafe { ::std::mem::transmute(LTS) };
            LTS as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let delivery_type: u32 = unsafe { ::std::mem::transmute(delivery_type) };
            delivery_type as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let ID: u32 = unsafe { ::std::mem::transmute(ID) };
            ID as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_IO_APIC_reg_00() {
    assert_eq!(
        ::std::mem::size_of::<IO_APIC_reg_00>(),
        4usize,
        concat!("Size of: ", stringify!(IO_APIC_reg_00))
    );
    assert_eq!(
        ::std::mem::align_of::<IO_APIC_reg_00>(),
        4usize,
        concat!("Alignment of ", stringify!(IO_APIC_reg_00))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IO_APIC_reg_00>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IO_APIC_reg_00),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IO_APIC_reg_00>())).bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IO_APIC_reg_00),
            "::",
            stringify!(bits)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IO_APIC_reg_01 {
    pub raw: u32,
    pub bits: IO_APIC_reg_01__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct IO_APIC_reg_01__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_IO_APIC_reg_01__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<IO_APIC_reg_01__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(IO_APIC_reg_01__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<IO_APIC_reg_01__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(IO_APIC_reg_01__bindgen_ty_1))
    );
}
impl IO_APIC_reg_01__bindgen_ty_1 {
    #[inline]
    pub fn version(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn PRQ(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PRQ(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn entries(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_entries(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        version: u32,
        __reserved_2: u32,
        PRQ: u32,
        entries: u32,
        __reserved_1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit.set(8usize, 7u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let PRQ: u32 = unsafe { ::std::mem::transmute(PRQ) };
            PRQ as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let entries: u32 = unsafe { ::std::mem::transmute(entries) };
            entries as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_IO_APIC_reg_01() {
    assert_eq!(
        ::std::mem::size_of::<IO_APIC_reg_01>(),
        4usize,
        concat!("Size of: ", stringify!(IO_APIC_reg_01))
    );
    assert_eq!(
        ::std::mem::align_of::<IO_APIC_reg_01>(),
        4usize,
        concat!("Alignment of ", stringify!(IO_APIC_reg_01))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IO_APIC_reg_01>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IO_APIC_reg_01),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IO_APIC_reg_01>())).bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IO_APIC_reg_01),
            "::",
            stringify!(bits)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IO_APIC_reg_02 {
    pub raw: u32,
    pub bits: IO_APIC_reg_02__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct IO_APIC_reg_02__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_IO_APIC_reg_02__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<IO_APIC_reg_02__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(IO_APIC_reg_02__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<IO_APIC_reg_02__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(IO_APIC_reg_02__bindgen_ty_1))
    );
}
impl IO_APIC_reg_02__bindgen_ty_1 {
    #[inline]
    pub fn __reserved_2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn arbitration(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_arbitration(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __reserved_2: u32,
        arbitration: u32,
        __reserved_1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let arbitration: u32 = unsafe { ::std::mem::transmute(arbitration) };
            arbitration as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_IO_APIC_reg_02() {
    assert_eq!(
        ::std::mem::size_of::<IO_APIC_reg_02>(),
        4usize,
        concat!("Size of: ", stringify!(IO_APIC_reg_02))
    );
    assert_eq!(
        ::std::mem::align_of::<IO_APIC_reg_02>(),
        4usize,
        concat!("Alignment of ", stringify!(IO_APIC_reg_02))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IO_APIC_reg_02>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IO_APIC_reg_02),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IO_APIC_reg_02>())).bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IO_APIC_reg_02),
            "::",
            stringify!(bits)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IO_APIC_reg_03 {
    pub raw: u32,
    pub bits: IO_APIC_reg_03__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct IO_APIC_reg_03__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_IO_APIC_reg_03__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<IO_APIC_reg_03__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(IO_APIC_reg_03__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<IO_APIC_reg_03__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(IO_APIC_reg_03__bindgen_ty_1))
    );
}
impl IO_APIC_reg_03__bindgen_ty_1 {
    #[inline]
    pub fn boot_DT(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_boot_DT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        boot_DT: u32,
        __reserved_1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let boot_DT: u32 = unsafe { ::std::mem::transmute(boot_DT) };
            boot_DT as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_IO_APIC_reg_03() {
    assert_eq!(
        ::std::mem::size_of::<IO_APIC_reg_03>(),
        4usize,
        concat!("Size of: ", stringify!(IO_APIC_reg_03))
    );
    assert_eq!(
        ::std::mem::align_of::<IO_APIC_reg_03>(),
        4usize,
        concat!("Alignment of ", stringify!(IO_APIC_reg_03))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IO_APIC_reg_03>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IO_APIC_reg_03),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IO_APIC_reg_03>())).bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IO_APIC_reg_03),
            "::",
            stringify!(bits)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct IO_APIC_route_entry {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u32>,
}
#[test]
fn bindgen_test_layout_IO_APIC_route_entry() {
    assert_eq!(
        ::std::mem::size_of::<IO_APIC_route_entry>(),
        8usize,
        concat!("Size of: ", stringify!(IO_APIC_route_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<IO_APIC_route_entry>(),
        1usize,
        concat!("Alignment of ", stringify!(IO_APIC_route_entry))
    );
}
impl IO_APIC_route_entry {
    #[inline]
    pub fn vector(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_mode(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_mode(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dest_mode(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dest_mode(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn polarity(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_polarity(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irr(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irr(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trigger(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_trigger(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mask(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_3(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_3(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn dest(&self) -> __u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dest(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vector: __u32,
        delivery_mode: __u32,
        dest_mode: __u32,
        delivery_status: __u32,
        polarity: __u32,
        irr: __u32,
        trigger: __u32,
        mask: __u32,
        __reserved_2: __u32,
        __reserved_3: __u32,
        dest: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let vector: u32 = unsafe { ::std::mem::transmute(vector) };
            vector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let delivery_mode: u32 = unsafe { ::std::mem::transmute(delivery_mode) };
            delivery_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let dest_mode: u32 = unsafe { ::std::mem::transmute(dest_mode) };
            dest_mode as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let delivery_status: u32 = unsafe { ::std::mem::transmute(delivery_status) };
            delivery_status as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let polarity: u32 = unsafe { ::std::mem::transmute(polarity) };
            polarity as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let irr: u32 = unsafe { ::std::mem::transmute(irr) };
            irr as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let trigger: u32 = unsafe { ::std::mem::transmute(trigger) };
            trigger as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let mask: u32 = unsafe { ::std::mem::transmute(mask) };
            mask as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 24u8, {
            let __reserved_3: u32 = unsafe { ::std::mem::transmute(__reserved_3) };
            __reserved_3 as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let dest: u32 = unsafe { ::std::mem::transmute(dest) };
            dest as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct IR_IO_APIC_route_entry {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u32>,
}
#[test]
fn bindgen_test_layout_IR_IO_APIC_route_entry() {
    assert_eq!(
        ::std::mem::size_of::<IR_IO_APIC_route_entry>(),
        8usize,
        concat!("Size of: ", stringify!(IR_IO_APIC_route_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<IR_IO_APIC_route_entry>(),
        1usize,
        concat!("Alignment of ", stringify!(IR_IO_APIC_route_entry))
    );
}
impl IR_IO_APIC_route_entry {
    #[inline]
    pub fn vector(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn zero(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_zero(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn index2(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_index2(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn polarity(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_polarity(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irr(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_irr(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trigger(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_trigger(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mask(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 31u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn format(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_format(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn index(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 15u8) as u64) }
    }
    #[inline]
    pub fn set_index(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vector: __u64,
        zero: __u64,
        index2: __u64,
        delivery_status: __u64,
        polarity: __u64,
        irr: __u64,
        trigger: __u64,
        mask: __u64,
        reserved: __u64,
        format: __u64,
        index: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let vector: u64 = unsafe { ::std::mem::transmute(vector) };
            vector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let zero: u64 = unsafe { ::std::mem::transmute(zero) };
            zero as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let index2: u64 = unsafe { ::std::mem::transmute(index2) };
            index2 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let delivery_status: u64 = unsafe { ::std::mem::transmute(delivery_status) };
            delivery_status as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let polarity: u64 = unsafe { ::std::mem::transmute(polarity) };
            polarity as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let irr: u64 = unsafe { ::std::mem::transmute(irr) };
            irr as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let trigger: u64 = unsafe { ::std::mem::transmute(trigger) };
            trigger as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let mask: u64 = unsafe { ::std::mem::transmute(mask) };
            mask as u64
        });
        __bindgen_bitfield_unit.set(17usize, 31u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(48usize, 1u8, {
            let format: u64 = unsafe { ::std::mem::transmute(format) };
            format as u64
        });
        __bindgen_bitfield_unit.set(49usize, 15u8, {
            let index: u64 = unsafe { ::std::mem::transmute(index) };
            index as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_alloc_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ioapic_domain_cfg {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}nr_ioapics"]
    pub static mut nr_ioapics: ::std::os::raw::c_int;
}
extern "C" {
    pub fn mpc_ioapic_id(ioapic: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mpc_ioapic_addr(ioapic: ::std::os::raw::c_int) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}mp_irq_entries"]
    pub static mut mp_irq_entries: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}mp_irqs"]
    pub static mut mp_irqs: [mpc_intsrc; 1024usize];
}
extern "C" {
    #[link_name = "\u{1}skip_ioapic_setup"]
    pub static mut skip_ioapic_setup: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}noioapicquirk"]
    pub static mut noioapicquirk: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}noioapicreroute"]
    pub static mut noioapicreroute: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}gsi_top"]
    pub static mut gsi_top: u32;
}
extern "C" {
    #[link_name = "\u{1}io_apic_irqs"]
    pub static mut io_apic_irqs: ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_cfg {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ioapic_insert_resources();
}
extern "C" {
    pub fn arch_early_ioapic_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn save_ioapic_entries() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mask_ioapic_entries();
}
extern "C" {
    pub fn restore_ioapic_entries() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setup_ioapic_ids_from_mpc();
}
extern "C" {
    pub fn setup_ioapic_ids_from_mpc_nocheck();
}
extern "C" {
    pub fn mp_find_ioapic(gsi: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mp_find_ioapic_pin(ioapic: ::std::os::raw::c_int, gsi: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mp_map_gsi_to_irq(
        gsi: u32,
        flags: ::std::os::raw::c_uint,
        info: *mut irq_alloc_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mp_unmap_irq(irq: ::std::os::raw::c_int);
}
extern "C" {
    pub fn mp_register_ioapic(
        id: ::std::os::raw::c_int,
        address: u32,
        gsi_base: u32,
        cfg: *mut ioapic_domain_cfg,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mp_unregister_ioapic(gsi_base: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mp_ioapic_registered(gsi_base: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ioapic_set_alloc_attr(
        info: *mut irq_alloc_info,
        node: ::std::os::raw::c_int,
        trigger: ::std::os::raw::c_int,
        polarity: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn mp_save_irq(m: *mut mpc_intsrc);
}
extern "C" {
    pub fn disable_ioapic_support();
}
extern "C" {
    pub fn io_apic_init_mappings();
}
extern "C" {
    pub fn native_io_apic_read(
        apic: ::std::os::raw::c_uint,
        reg: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn native_disable_io_apic();
}
extern "C" {
    pub fn setup_IO_APIC();
}
extern "C" {
    pub fn enable_IO_APIC();
}
extern "C" {
    pub fn disable_IO_APIC();
}
extern "C" {
    pub fn IO_APIC_get_PCI_irq_vector(
        bus: ::std::os::raw::c_int,
        devfn: ::std::os::raw::c_int,
        pin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn print_IO_APICs();
}
extern "C" {
    #[link_name = "\u{1}smp_num_siblings"]
    pub static mut smp_num_siblings: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}num_processors"]
    pub static mut num_processors: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}cpu_sibling_map"]
    pub static mut cpu_sibling_map: *mut cpumask;
}
extern "C" {
    #[link_name = "\u{1}cpu_core_map"]
    pub static mut cpu_core_map: *mut cpumask;
}
extern "C" {
    #[link_name = "\u{1}cpu_llc_shared_map"]
    pub static mut cpu_llc_shared_map: *mut cpumask;
}
extern "C" {
    #[link_name = "\u{1}cpu_llc_id"]
    pub static mut cpu_llc_id: ::std::os::raw::c_ushort;
}
extern "C" {
    #[link_name = "\u{1}cpu_number"]
    pub static mut cpu_number: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}x86_cpu_to_apicid"]
    pub static mut x86_cpu_to_apicid: ::std::os::raw::c_ushort;
}
extern "C" {
    #[link_name = "\u{1}x86_cpu_to_apicid_early_ptr"]
    pub static mut x86_cpu_to_apicid_early_ptr: *mut ::std::os::raw::c_ushort;
}
extern "C" {
    #[link_name = "\u{1}x86_cpu_to_apicid_early_map"]
    pub static mut x86_cpu_to_apicid_early_map: [::std::os::raw::c_ushort; 0usize];
}
extern "C" {
    #[link_name = "\u{1}x86_cpu_to_acpiid"]
    pub static mut x86_cpu_to_acpiid: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}x86_cpu_to_acpiid_early_ptr"]
    pub static mut x86_cpu_to_acpiid_early_ptr: *mut ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}x86_cpu_to_acpiid_early_map"]
    pub static mut x86_cpu_to_acpiid_early_map: [::std::os::raw::c_uint; 0usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct smp_ops {
    pub smp_prepare_boot_cpu: ::std::option::Option<unsafe extern "C" fn()>,
    pub smp_prepare_cpus:
        ::std::option::Option<unsafe extern "C" fn(max_cpus: ::std::os::raw::c_uint)>,
    pub smp_cpus_done:
        ::std::option::Option<unsafe extern "C" fn(max_cpus: ::std::os::raw::c_uint)>,
    pub stop_other_cpus: ::std::option::Option<unsafe extern "C" fn(wait: ::std::os::raw::c_int)>,
    pub crash_stop_other_cpus: ::std::option::Option<unsafe extern "C" fn()>,
    pub smp_send_reschedule:
        ::std::option::Option<unsafe extern "C" fn(cpu: ::std::os::raw::c_int)>,
    pub cpu_up: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: ::std::os::raw::c_uint,
            tidle: *mut task_struct,
        ) -> ::std::os::raw::c_int,
    >,
    pub cpu_disable: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub cpu_die: ::std::option::Option<unsafe extern "C" fn(cpu: ::std::os::raw::c_uint)>,
    pub play_dead: ::std::option::Option<unsafe extern "C" fn()>,
    pub send_call_func_ipi: ::std::option::Option<unsafe extern "C" fn(mask: *const cpumask)>,
    pub send_call_func_single_ipi:
        ::std::option::Option<unsafe extern "C" fn(cpu: ::std::os::raw::c_int)>,
}
#[test]
fn bindgen_test_layout_smp_ops() {
    assert_eq!(
        ::std::mem::size_of::<smp_ops>(),
        96usize,
        concat!("Size of: ", stringify!(smp_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<smp_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(smp_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).smp_prepare_boot_cpu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(smp_prepare_boot_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).smp_prepare_cpus as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(smp_prepare_cpus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).smp_cpus_done as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(smp_cpus_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).stop_other_cpus as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(stop_other_cpus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).crash_stop_other_cpus as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(crash_stop_other_cpus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).smp_send_reschedule as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(smp_send_reschedule)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).cpu_up as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(cpu_up)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).cpu_disable as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(cpu_disable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).cpu_die as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(cpu_die)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).play_dead as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(play_dead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).send_call_func_ipi as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(send_call_func_ipi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<smp_ops>())).send_call_func_single_ipi as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(send_call_func_single_ipi)
        )
    );
}
extern "C" {
    pub fn set_cpu_sibling_map(cpu: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}smp_ops"]
    pub static mut smp_ops: smp_ops;
}
extern "C" {
    pub fn cpu_disable_common();
}
extern "C" {
    pub fn native_smp_prepare_boot_cpu();
}
extern "C" {
    pub fn native_smp_prepare_cpus(max_cpus: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn calculate_max_logical_packages();
}
extern "C" {
    pub fn native_smp_cpus_done(max_cpus: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn common_cpu_up(cpunum: ::std::os::raw::c_uint, tidle: *mut task_struct);
}
extern "C" {
    pub fn native_cpu_up(
        cpunum: ::std::os::raw::c_uint,
        tidle: *mut task_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn native_cpu_disable() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn common_cpu_die(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn native_cpu_die(cpu: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hlt_play_dead();
}
extern "C" {
    pub fn native_play_dead();
}
extern "C" {
    pub fn play_dead_common();
}
extern "C" {
    pub fn wbinvd_on_cpu(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn wbinvd_on_all_cpus() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn native_send_call_func_ipi(mask: *const cpumask);
}
extern "C" {
    pub fn native_send_call_func_single_ipi(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn x86_idle_thread_init(cpu: ::std::os::raw::c_uint, idle: *mut task_struct);
}
extern "C" {
    pub fn smp_store_boot_cpu_info();
}
extern "C" {
    pub fn smp_store_cpu_info(id: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}disabled_cpus"]
    pub static mut disabled_cpus: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hard_smp_processor_id() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn first_online_pgdat() -> *mut pglist_data;
}
extern "C" {
    pub fn next_online_pgdat(pgdat: *mut pglist_data) -> *mut pglist_data;
}
extern "C" {
    pub fn next_zone(zone: *mut zone) -> *mut zone;
}
extern "C" {
    pub fn __next_zones_zonelist(
        z: *mut zoneref,
        highest_zoneidx: zone_type,
        nodes: *mut nodemask_t,
    ) -> *mut zoneref;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page_ext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mem_section {
    pub section_mem_map: ::std::os::raw::c_ulong,
    pub pageblock_flags: *mut ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_mem_section() {
    assert_eq!(
        ::std::mem::size_of::<mem_section>(),
        16usize,
        concat!("Size of: ", stringify!(mem_section))
    );
    assert_eq!(
        ::std::mem::align_of::<mem_section>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_section))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_section>())).section_mem_map as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_section),
            "::",
            stringify!(section_mem_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_section>())).pageblock_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_section),
            "::",
            stringify!(pageblock_flags)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}mem_section"]
    pub static mut mem_section: *mut *mut mem_section;
}
extern "C" {
    pub fn __section_nr(ms: *mut mem_section) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn usemap_size() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn online_mem_sections(
        start_pfn: ::std::os::raw::c_ulong,
        end_pfn: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn offline_mem_sections(
        start_pfn: ::std::os::raw::c_ulong,
        end_pfn: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    #[link_name = "\u{1}__highest_present_section_nr"]
    pub static mut __highest_present_section_nr: ::std::os::raw::c_int;
}
extern "C" {
    pub fn sparse_init();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mminit_pfnnid_cache {
    pub last_start: ::std::os::raw::c_ulong,
    pub last_end: ::std::os::raw::c_ulong,
    pub last_nid: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mminit_pfnnid_cache() {
    assert_eq!(
        ::std::mem::size_of::<mminit_pfnnid_cache>(),
        24usize,
        concat!("Size of: ", stringify!(mminit_pfnnid_cache))
    );
    assert_eq!(
        ::std::mem::align_of::<mminit_pfnnid_cache>(),
        8usize,
        concat!("Alignment of ", stringify!(mminit_pfnnid_cache))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mminit_pfnnid_cache>())).last_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mminit_pfnnid_cache),
            "::",
            stringify!(last_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mminit_pfnnid_cache>())).last_end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mminit_pfnnid_cache),
            "::",
            stringify!(last_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mminit_pfnnid_cache>())).last_nid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mminit_pfnnid_cache),
            "::",
            stringify!(last_nid)
        )
    );
}
extern "C" {
    pub fn node_memmap_size_bytes(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
pub type smp_call_func_t =
    ::std::option::Option<unsafe extern "C" fn(info: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __call_single_data {
    pub llist: llist_node,
    pub func: smp_call_func_t,
    pub info: *mut ::std::os::raw::c_void,
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___call_single_data() {
    assert_eq!(
        ::std::mem::size_of::<__call_single_data>(),
        32usize,
        concat!("Size of: ", stringify!(__call_single_data))
    );
    assert_eq!(
        ::std::mem::align_of::<__call_single_data>(),
        8usize,
        concat!("Alignment of ", stringify!(__call_single_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__call_single_data>())).llist as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_data),
            "::",
            stringify!(llist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__call_single_data>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_data),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__call_single_data>())).info as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_data),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__call_single_data>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_data),
            "::",
            stringify!(flags)
        )
    );
}
pub type call_single_data_t = __call_single_data;
extern "C" {
    #[link_name = "\u{1}total_cpus"]
    pub static mut total_cpus: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn smp_call_function_single(
        cpuid: ::std::os::raw::c_int,
        func: smp_call_func_t,
        info: *mut ::std::os::raw::c_void,
        wait: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_each_cpu(
        func: smp_call_func_t,
        info: *mut ::std::os::raw::c_void,
        wait: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_each_cpu_mask(
        mask: *const cpumask,
        func: smp_call_func_t,
        info: *mut ::std::os::raw::c_void,
        wait: bool_,
    );
}
extern "C" {
    pub fn on_each_cpu_cond(
        cond_func: ::std::option::Option<
            unsafe extern "C" fn(
                cpu: ::std::os::raw::c_int,
                info: *mut ::std::os::raw::c_void,
            ) -> bool_,
        >,
        func: smp_call_func_t,
        info: *mut ::std::os::raw::c_void,
        wait: bool_,
        gfp_flags: gfp_t,
    );
}
extern "C" {
    pub fn smp_call_function_single_async(
        cpu: ::std::os::raw::c_int,
        csd: *mut __call_single_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn smp_call_function(
        func: smp_call_func_t,
        info: *mut ::std::os::raw::c_void,
        wait: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn smp_call_function_many(
        mask: *const cpumask,
        func: smp_call_func_t,
        info: *mut ::std::os::raw::c_void,
        wait: bool_,
    );
}
extern "C" {
    pub fn smp_call_function_any(
        mask: *const cpumask,
        func: smp_call_func_t,
        info: *mut ::std::os::raw::c_void,
        wait: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kick_all_cpus_sync();
}
extern "C" {
    pub fn wake_up_all_idle_cpus();
}
extern "C" {
    pub fn call_function_init();
}
extern "C" {
    pub fn generic_smp_call_function_single_interrupt();
}
extern "C" {
    #[link_name = "\u{1}setup_max_cpus"]
    pub static mut setup_max_cpus: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn setup_nr_cpu_ids();
}
extern "C" {
    pub fn smp_init();
}
extern "C" {
    #[link_name = "\u{1}__boot_cpu_id"]
    pub static mut __boot_cpu_id: ::std::os::raw::c_int;
}
extern "C" {
    pub fn arch_disable_smp_support();
}
extern "C" {
    pub fn arch_enable_nonboot_cpus_begin();
}
extern "C" {
    pub fn arch_enable_nonboot_cpus_end();
}
extern "C" {
    pub fn smp_setup_processor_id();
}
extern "C" {
    pub fn smp_call_on_cpu(
        cpu: ::std::os::raw::c_uint,
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
        par: *mut ::std::os::raw::c_void,
        phys: bool_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn smpcfd_prepare_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn smpcfd_dead_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn smpcfd_dying_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}pcpu_base_addr"]
    pub static mut pcpu_base_addr: *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}pcpu_unit_offsets"]
    pub static mut pcpu_unit_offsets: *const ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pcpu_group_info {
    pub nr_units: ::std::os::raw::c_int,
    pub base_offset: ::std::os::raw::c_ulong,
    pub cpu_map: *mut ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pcpu_group_info() {
    assert_eq!(
        ::std::mem::size_of::<pcpu_group_info>(),
        24usize,
        concat!("Size of: ", stringify!(pcpu_group_info))
    );
    assert_eq!(
        ::std::mem::align_of::<pcpu_group_info>(),
        8usize,
        concat!("Alignment of ", stringify!(pcpu_group_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu_group_info>())).nr_units as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu_group_info),
            "::",
            stringify!(nr_units)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu_group_info>())).base_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu_group_info),
            "::",
            stringify!(base_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu_group_info>())).cpu_map as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu_group_info),
            "::",
            stringify!(cpu_map)
        )
    );
}
#[repr(C)]
pub struct pcpu_alloc_info {
    pub static_size: usize,
    pub reserved_size: usize,
    pub dyn_size: usize,
    pub unit_size: usize,
    pub atom_size: usize,
    pub alloc_size: usize,
    pub __ai_size: usize,
    pub nr_groups: ::std::os::raw::c_int,
    pub groups: __IncompleteArrayField<pcpu_group_info>,
}
#[test]
fn bindgen_test_layout_pcpu_alloc_info() {
    assert_eq!(
        ::std::mem::size_of::<pcpu_alloc_info>(),
        64usize,
        concat!("Size of: ", stringify!(pcpu_alloc_info))
    );
    assert_eq!(
        ::std::mem::align_of::<pcpu_alloc_info>(),
        8usize,
        concat!("Alignment of ", stringify!(pcpu_alloc_info))
    );
}
pub const pcpu_fc_PCPU_FC_AUTO: pcpu_fc = 0;
pub const pcpu_fc_PCPU_FC_EMBED: pcpu_fc = 1;
pub const pcpu_fc_PCPU_FC_PAGE: pcpu_fc = 2;
pub const pcpu_fc_PCPU_FC_NR: pcpu_fc = 3;
pub type pcpu_fc = u32;
extern "C" {
    #[link_name = "\u{1}pcpu_fc_names"]
    pub static mut pcpu_fc_names: [*const ::std::os::raw::c_char; 3usize];
}
extern "C" {
    #[link_name = "\u{1}pcpu_chosen_fc"]
    pub static mut pcpu_chosen_fc: pcpu_fc;
}
pub type pcpu_fc_alloc_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        cpu: ::std::os::raw::c_uint,
        size: usize,
        align: usize,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type pcpu_fc_free_fn_t =
    ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void, size: usize)>;
pub type pcpu_fc_populate_pte_fn_t =
    ::std::option::Option<unsafe extern "C" fn(addr: ::std::os::raw::c_ulong)>;
pub type pcpu_fc_cpu_distance_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        from: ::std::os::raw::c_uint,
        to: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn pcpu_alloc_alloc_info(
        nr_groups: ::std::os::raw::c_int,
        nr_units: ::std::os::raw::c_int,
    ) -> *mut pcpu_alloc_info;
}
extern "C" {
    pub fn pcpu_free_alloc_info(ai: *mut pcpu_alloc_info);
}
extern "C" {
    pub fn pcpu_setup_first_chunk(
        ai: *const pcpu_alloc_info,
        base_addr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcpu_embed_first_chunk(
        reserved_size: usize,
        dyn_size: usize,
        atom_size: usize,
        cpu_distance_fn: pcpu_fc_cpu_distance_fn_t,
        alloc_fn: pcpu_fc_alloc_fn_t,
        free_fn: pcpu_fc_free_fn_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcpu_page_first_chunk(
        reserved_size: usize,
        alloc_fn: pcpu_fc_alloc_fn_t,
        free_fn: pcpu_fc_free_fn_t,
        populate_pte_fn: pcpu_fc_populate_pte_fn_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __alloc_reserved_percpu(size: usize, align: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __is_kernel_percpu_address(
        addr: ::std::os::raw::c_ulong,
        can_addr: *mut ::std::os::raw::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn is_kernel_percpu_address(addr: ::std::os::raw::c_ulong) -> bool_;
}
extern "C" {
    pub fn __alloc_percpu_gfp(size: usize, align: usize, gfp: gfp_t)
        -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __alloc_percpu(size: usize, align: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free_percpu(__pdata: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn per_cpu_ptr_to_phys(addr: *mut ::std::os::raw::c_void) -> phys_addr_t;
}
extern "C" {
    pub fn arch_update_cpu_topology() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}numa_node"]
    pub static mut numa_node: ::std::os::raw::c_int;
}
extern "C" {
    pub fn __alloc_pages_nodemask(
        gfp_mask: gfp_t,
        order: ::std::os::raw::c_uint,
        preferred_nid: ::std::os::raw::c_int,
        nodemask: *mut nodemask_t,
    ) -> *mut page;
}
extern "C" {
    pub fn alloc_pages_current(gfp_mask: gfp_t, order: ::std::os::raw::c_uint) -> *mut page;
}
extern "C" {
    pub fn alloc_pages_vma(
        gfp_mask: gfp_t,
        order: ::std::os::raw::c_int,
        vma: *mut vm_area_struct,
        addr: ::std::os::raw::c_ulong,
        node: ::std::os::raw::c_int,
        hugepage: bool_,
    ) -> *mut page;
}
extern "C" {
    pub fn __get_free_pages(
        gfp_mask: gfp_t,
        order: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn get_zeroed_page(gfp_mask: gfp_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn alloc_pages_exact(size: usize, gfp_mask: gfp_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free_pages_exact(virt: *mut ::std::os::raw::c_void, size: usize);
}
extern "C" {
    pub fn alloc_pages_exact_nid(
        nid: ::std::os::raw::c_int,
        size: usize,
        gfp_mask: gfp_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __free_pages(page: *mut page, order: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn free_pages(addr: ::std::os::raw::c_ulong, order: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn free_unref_page(page: *mut page);
}
extern "C" {
    pub fn free_unref_page_list(list: *mut list_head);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page_frag_cache {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __page_frag_cache_drain(page: *mut page, count: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn page_frag_alloc(
        nc: *mut page_frag_cache,
        fragsz: ::std::os::raw::c_uint,
        gfp_mask: gfp_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn page_frag_free(addr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn page_alloc_init();
}
extern "C" {
    pub fn drain_zone_pages(zone: *mut zone, pcp: *mut per_cpu_pages);
}
extern "C" {
    pub fn drain_all_pages(zone: *mut zone);
}
extern "C" {
    pub fn drain_local_pages(zone: *mut zone);
}
extern "C" {
    pub fn page_alloc_init_late();
}
extern "C" {
    #[link_name = "\u{1}gfp_allowed_mask"]
    pub static mut gfp_allowed_mask: gfp_t;
}
extern "C" {
    pub fn gfp_pfmemalloc_allowed(gfp_mask: gfp_t) -> bool_;
}
extern "C" {
    pub fn pm_restrict_gfp_mask();
}
extern "C" {
    pub fn pm_restore_gfp_mask();
}
extern "C" {
    pub fn pm_suspended_storage() -> bool_;
}
extern "C" {
    pub fn alloc_contig_range(
        start: ::std::os::raw::c_ulong,
        end: ::std::os::raw::c_ulong,
        migratetype: ::std::os::raw::c_uint,
        gfp_mask: gfp_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn free_contig_range(pfn: ::std::os::raw::c_ulong, nr_pages: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn init_cma_reserved_pageblock(page: *mut page);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kmem_cache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mem_cgroup {
    _unused: [u8; 0],
}
extern "C" {
    pub fn kmem_cache_init();
}
extern "C" {
    pub fn slab_is_available() -> bool_;
}
extern "C" {
    pub fn kmem_cache_create(
        arg1: *const ::std::os::raw::c_char,
        arg2: usize,
        arg3: usize,
        arg4: slab_flags_t,
        arg5: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> *mut kmem_cache;
}
extern "C" {
    pub fn kmem_cache_destroy(arg1: *mut kmem_cache);
}
extern "C" {
    pub fn kmem_cache_shrink(arg1: *mut kmem_cache) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcg_create_kmem_cache(arg1: *mut mem_cgroup, arg2: *mut kmem_cache);
}
extern "C" {
    pub fn memcg_deactivate_kmem_caches(arg1: *mut mem_cgroup);
}
extern "C" {
    pub fn memcg_destroy_kmem_caches(arg1: *mut mem_cgroup);
}
extern "C" {
    pub fn __krealloc(
        arg1: *const ::std::os::raw::c_void,
        arg2: usize,
        arg3: gfp_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn krealloc(
        arg1: *const ::std::os::raw::c_void,
        arg2: usize,
        arg3: gfp_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kfree(arg1: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn kzfree(arg1: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn ksize(arg1: *const ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn __check_heap_object(
        ptr: *const ::std::os::raw::c_void,
        n: ::std::os::raw::c_ulong,
        page: *mut page,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}kmalloc_caches"]
    pub static mut kmalloc_caches: [*mut kmem_cache; 14usize];
}
extern "C" {
    #[link_name = "\u{1}kmalloc_dma_caches"]
    pub static mut kmalloc_dma_caches: [*mut kmem_cache; 14usize];
}
extern "C" {
    pub fn __kmalloc(size: usize, flags: gfp_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmem_cache_alloc(arg1: *mut kmem_cache, flags: gfp_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmem_cache_free(arg1: *mut kmem_cache, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn kmem_cache_free_bulk(
        arg1: *mut kmem_cache,
        arg2: usize,
        arg3: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn kmem_cache_alloc_bulk(
        arg1: *mut kmem_cache,
        arg2: gfp_t,
        arg3: usize,
        arg4: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __kmalloc_node(
        size: usize,
        flags: gfp_t,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmem_cache_alloc_node(
        arg1: *mut kmem_cache,
        flags: gfp_t,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmem_cache_alloc_trace(
        arg1: *mut kmem_cache,
        arg2: gfp_t,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmem_cache_alloc_node_trace(
        s: *mut kmem_cache,
        gfpflags: gfp_t,
        node: ::std::os::raw::c_int,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmalloc_order(
        size: usize,
        flags: gfp_t,
        order: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmalloc_order_trace(
        size: usize,
        flags: gfp_t,
        order: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
pub struct memcg_cache_array {
    pub rcu: callback_head,
    pub entries: __IncompleteArrayField<*mut kmem_cache>,
}
#[test]
fn bindgen_test_layout_memcg_cache_array() {
    assert_eq!(
        ::std::mem::size_of::<memcg_cache_array>(),
        16usize,
        concat!("Size of: ", stringify!(memcg_cache_array))
    );
    assert_eq!(
        ::std::mem::align_of::<memcg_cache_array>(),
        8usize,
        concat!("Alignment of ", stringify!(memcg_cache_array))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<memcg_cache_array>())).rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(memcg_cache_array),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<memcg_cache_array>())).entries as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(memcg_cache_array),
            "::",
            stringify!(entries)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct memcg_cache_params {
    pub root_cache: *mut kmem_cache,
    pub __bindgen_anon_1: memcg_cache_params__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union memcg_cache_params__bindgen_ty_1 {
    pub __bindgen_anon_1: memcg_cache_params__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: memcg_cache_params__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 10usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct memcg_cache_params__bindgen_ty_1__bindgen_ty_1 {
    pub memcg_caches: *mut memcg_cache_array,
    pub __root_caches_node: list_head,
    pub children: list_head,
}
#[test]
fn bindgen_test_layout_memcg_cache_params__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<memcg_cache_params__bindgen_ty_1__bindgen_ty_1>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(memcg_cache_params__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<memcg_cache_params__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(memcg_cache_params__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<memcg_cache_params__bindgen_ty_1__bindgen_ty_1>())).memcg_caches
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(memcg_cache_params__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(memcg_caches)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<memcg_cache_params__bindgen_ty_1__bindgen_ty_1>()))
                .__root_caches_node as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(memcg_cache_params__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__root_caches_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<memcg_cache_params__bindgen_ty_1__bindgen_ty_1>())).children
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(memcg_cache_params__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(children)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct memcg_cache_params__bindgen_ty_1__bindgen_ty_2 {
    pub memcg: *mut mem_cgroup,
    pub children_node: list_head,
    pub kmem_caches_node: list_head,
    pub deact_fn: ::std::option::Option<unsafe extern "C" fn(arg1: *mut kmem_cache)>,
    pub __bindgen_anon_1: memcg_cache_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union memcg_cache_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub deact_rcu_head: callback_head,
    pub deact_work: work_struct,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_memcg_cache_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<memcg_cache_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(memcg_cache_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<memcg_cache_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(memcg_cache_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<memcg_cache_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()))
                .deact_rcu_head as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(memcg_cache_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(deact_rcu_head)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<memcg_cache_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()))
                .deact_work as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(memcg_cache_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(deact_work)
        )
    );
}
#[test]
fn bindgen_test_layout_memcg_cache_params__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<memcg_cache_params__bindgen_ty_1__bindgen_ty_2>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(memcg_cache_params__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<memcg_cache_params__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(memcg_cache_params__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<memcg_cache_params__bindgen_ty_1__bindgen_ty_2>())).memcg
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(memcg_cache_params__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(memcg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<memcg_cache_params__bindgen_ty_1__bindgen_ty_2>())).children_node
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(memcg_cache_params__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(children_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<memcg_cache_params__bindgen_ty_1__bindgen_ty_2>()))
                .kmem_caches_node as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(memcg_cache_params__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(kmem_caches_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<memcg_cache_params__bindgen_ty_1__bindgen_ty_2>())).deact_fn
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(memcg_cache_params__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(deact_fn)
        )
    );
}
#[test]
fn bindgen_test_layout_memcg_cache_params__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<memcg_cache_params__bindgen_ty_1>(),
        80usize,
        concat!("Size of: ", stringify!(memcg_cache_params__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<memcg_cache_params__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(memcg_cache_params__bindgen_ty_1)
        )
    );
}
#[test]
fn bindgen_test_layout_memcg_cache_params() {
    assert_eq!(
        ::std::mem::size_of::<memcg_cache_params>(),
        88usize,
        concat!("Size of: ", stringify!(memcg_cache_params))
    );
    assert_eq!(
        ::std::mem::align_of::<memcg_cache_params>(),
        8usize,
        concat!("Alignment of ", stringify!(memcg_cache_params))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<memcg_cache_params>())).root_cache as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(memcg_cache_params),
            "::",
            stringify!(root_cache)
        )
    );
}
extern "C" {
    pub fn memcg_update_all_caches(num_memcgs: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __kmalloc_track_caller(
        arg1: usize,
        arg2: gfp_t,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __kmalloc_node_track_caller(
        arg1: usize,
        arg2: gfp_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmem_cache_size(s: *mut kmem_cache) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn kmem_cache_init_late();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timerqueue_node {
    pub node: rb_node,
    pub expires: ktime_t,
}
#[test]
fn bindgen_test_layout_timerqueue_node() {
    assert_eq!(
        ::std::mem::size_of::<timerqueue_node>(),
        32usize,
        concat!("Size of: ", stringify!(timerqueue_node))
    );
    assert_eq!(
        ::std::mem::align_of::<timerqueue_node>(),
        8usize,
        concat!("Alignment of ", stringify!(timerqueue_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timerqueue_node>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timerqueue_node),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timerqueue_node>())).expires as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(timerqueue_node),
            "::",
            stringify!(expires)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timerqueue_head {
    pub head: rb_root,
    pub next: *mut timerqueue_node,
}
#[test]
fn bindgen_test_layout_timerqueue_head() {
    assert_eq!(
        ::std::mem::size_of::<timerqueue_head>(),
        16usize,
        concat!("Size of: ", stringify!(timerqueue_head))
    );
    assert_eq!(
        ::std::mem::align_of::<timerqueue_head>(),
        8usize,
        concat!("Alignment of ", stringify!(timerqueue_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timerqueue_head>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timerqueue_head),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timerqueue_head>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timerqueue_head),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn timerqueue_add(head: *mut timerqueue_head, node: *mut timerqueue_node) -> bool_;
}
extern "C" {
    pub fn timerqueue_del(head: *mut timerqueue_head, node: *mut timerqueue_node) -> bool_;
}
extern "C" {
    pub fn timerqueue_iterate_next(node: *mut timerqueue_node) -> *mut timerqueue_node;
}
pub const hrtimer_mode_HRTIMER_MODE_ABS: hrtimer_mode = 0;
pub const hrtimer_mode_HRTIMER_MODE_REL: hrtimer_mode = 1;
pub const hrtimer_mode_HRTIMER_MODE_PINNED: hrtimer_mode = 2;
pub const hrtimer_mode_HRTIMER_MODE_ABS_PINNED: hrtimer_mode = 2;
pub const hrtimer_mode_HRTIMER_MODE_REL_PINNED: hrtimer_mode = 3;
pub type hrtimer_mode = u32;
pub const hrtimer_restart_HRTIMER_NORESTART: hrtimer_restart = 0;
pub const hrtimer_restart_HRTIMER_RESTART: hrtimer_restart = 1;
pub type hrtimer_restart = i32;
#[doc = " struct hrtimer - the basic hrtimer structure"]
#[doc = " @node:\ttimerqueue node, which also manages node.expires,"]
#[doc = "\t\tthe absolute expiry time in the hrtimers internal"]
#[doc = "\t\trepresentation. The time is related to the clock on"]
#[doc = "\t\twhich the timer is based. Is setup by adding"]
#[doc = "\t\tslack to the _softexpires value. For non range timers"]
#[doc = "\t\tidentical to _softexpires."]
#[doc = " @_softexpires: the absolute earliest expiry time of the hrtimer."]
#[doc = "\t\tThe time which was given as expiry time when the timer"]
#[doc = "\t\twas armed."]
#[doc = " @function:\ttimer expiry callback function"]
#[doc = " @base:\tpointer to the timer base (per cpu and per clock)"]
#[doc = " @state:\tstate information (See bit values above)"]
#[doc = " @is_rel:\tSet if the timer was armed relative"]
#[doc = ""]
#[doc = " The hrtimer structure must be initialized by hrtimer_init()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hrtimer {
    pub node: timerqueue_node,
    pub _softexpires: ktime_t,
    pub function:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut hrtimer) -> hrtimer_restart>,
    pub base: *mut hrtimer_clock_base,
    pub state: u8,
    pub is_rel: u8,
}
#[test]
fn bindgen_test_layout_hrtimer() {
    assert_eq!(
        ::std::mem::size_of::<hrtimer>(),
        64usize,
        concat!("Size of: ", stringify!(hrtimer))
    );
    assert_eq!(
        ::std::mem::align_of::<hrtimer>(),
        8usize,
        concat!("Alignment of ", stringify!(hrtimer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer>()))._softexpires as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(_softexpires)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer>())).function as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer>())).base as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer>())).state as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer>())).is_rel as *const _ as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(is_rel)
        )
    );
}
#[doc = " struct hrtimer_sleeper - simple sleeper structure"]
#[doc = " @timer:\tembedded timer structure"]
#[doc = " @task:\ttask to wake up"]
#[doc = ""]
#[doc = " task is set to NULL, when the timer expires."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hrtimer_sleeper {
    pub timer: hrtimer,
    pub task: *mut task_struct,
}
#[test]
fn bindgen_test_layout_hrtimer_sleeper() {
    assert_eq!(
        ::std::mem::size_of::<hrtimer_sleeper>(),
        72usize,
        concat!("Size of: ", stringify!(hrtimer_sleeper))
    );
    assert_eq!(
        ::std::mem::align_of::<hrtimer_sleeper>(),
        8usize,
        concat!("Alignment of ", stringify!(hrtimer_sleeper))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_sleeper>())).timer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_sleeper),
            "::",
            stringify!(timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_sleeper>())).task as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_sleeper),
            "::",
            stringify!(task)
        )
    );
}
#[doc = " struct hrtimer_clock_base - the timer base for a specific clock"]
#[doc = " @cpu_base:\t\tper cpu clock base"]
#[doc = " @index:\t\tclock type index for per_cpu support when moving a"]
#[doc = "\t\t\ttimer to a base on another cpu."]
#[doc = " @clockid:\t\tclock id for per_cpu support"]
#[doc = " @active:\t\tred black tree root node for the active timers"]
#[doc = " @get_time:\t\tfunction to retrieve the current time of the clock"]
#[doc = " @offset:\t\toffset of this clock to the monotonic base"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hrtimer_clock_base {
    pub cpu_base: *mut hrtimer_cpu_base,
    pub index: ::std::os::raw::c_int,
    pub clockid: clockid_t,
    pub active: timerqueue_head,
    pub get_time: ::std::option::Option<unsafe extern "C" fn() -> ktime_t>,
    pub offset: ktime_t,
    pub __bindgen_padding_0: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_hrtimer_clock_base() {
    assert_eq!(
        ::std::mem::size_of::<hrtimer_clock_base>(),
        64usize,
        concat!("Size of: ", stringify!(hrtimer_clock_base))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_clock_base>())).cpu_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(cpu_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_clock_base>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_clock_base>())).clockid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(clockid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_clock_base>())).active as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_clock_base>())).get_time as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(get_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_clock_base>())).offset as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(offset)
        )
    );
}
pub const hrtimer_base_type_HRTIMER_BASE_MONOTONIC: hrtimer_base_type = 0;
pub const hrtimer_base_type_HRTIMER_BASE_REALTIME: hrtimer_base_type = 1;
pub const hrtimer_base_type_HRTIMER_BASE_BOOTTIME: hrtimer_base_type = 2;
pub const hrtimer_base_type_HRTIMER_BASE_TAI: hrtimer_base_type = 3;
pub const hrtimer_base_type_HRTIMER_MAX_CLOCK_BASES: hrtimer_base_type = 4;
pub type hrtimer_base_type = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hrtimer_cpu_base {
    pub lock: raw_spinlock_t,
    pub seq: seqcount_t,
    pub running: *mut hrtimer,
    pub cpu: ::std::os::raw::c_uint,
    pub active_bases: ::std::os::raw::c_uint,
    pub clock_was_set_seq: ::std::os::raw::c_uint,
    pub migration_enabled: bool_,
    pub nohz_active: bool_,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub expires_next: ktime_t,
    pub next_timer: *mut hrtimer,
    pub nr_events: ::std::os::raw::c_uint,
    pub nr_retries: ::std::os::raw::c_uint,
    pub nr_hangs: ::std::os::raw::c_uint,
    pub max_hang_time: ::std::os::raw::c_uint,
    pub clock_base: [hrtimer_clock_base; 4usize],
}
#[test]
fn bindgen_test_layout_hrtimer_cpu_base() {
    assert_eq!(
        ::std::mem::size_of::<hrtimer_cpu_base>(),
        320usize,
        concat!("Size of: ", stringify!(hrtimer_cpu_base))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_cpu_base>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_cpu_base>())).seq as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_cpu_base>())).running as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(running)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_cpu_base>())).cpu as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_cpu_base>())).active_bases as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(active_bases)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hrtimer_cpu_base>())).clock_was_set_seq as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(clock_was_set_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hrtimer_cpu_base>())).migration_enabled as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(migration_enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_cpu_base>())).nohz_active as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(nohz_active)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_cpu_base>())).expires_next as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(expires_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_cpu_base>())).next_timer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(next_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_cpu_base>())).nr_events as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(nr_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_cpu_base>())).nr_retries as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(nr_retries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_cpu_base>())).nr_hangs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(nr_hangs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_cpu_base>())).max_hang_time as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(max_hang_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_cpu_base>())).clock_base as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(clock_base)
        )
    );
}
impl hrtimer_cpu_base {
    #[inline]
    pub fn in_hrtirq(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_hrtirq(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hres_active(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hres_active(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hang_detected(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hang_detected(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        in_hrtirq: ::std::os::raw::c_uint,
        hres_active: ::std::os::raw::c_uint,
        hang_detected: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let in_hrtirq: u32 = unsafe { ::std::mem::transmute(in_hrtirq) };
            in_hrtirq as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hres_active: u32 = unsafe { ::std::mem::transmute(hres_active) };
            hres_active as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hang_detected: u32 = unsafe { ::std::mem::transmute(hang_detected) };
            hang_detected as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clock_event_device {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hrtimer_interrupt(dev: *mut clock_event_device);
}
extern "C" {
    pub fn clock_was_set_delayed();
}
extern "C" {
    #[link_name = "\u{1}hrtimer_resolution"]
    pub static mut hrtimer_resolution: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clock_was_set();
}
extern "C" {
    pub fn timerfd_clock_was_set();
}
extern "C" {
    pub fn hrtimers_resume();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tick_device {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}tick_cpu_device"]
    pub static mut tick_cpu_device: tick_device;
}
extern "C" {
    pub fn hrtimer_init(timer: *mut hrtimer, which_clock: clockid_t, mode: hrtimer_mode);
}
extern "C" {
    pub fn hrtimer_start_range_ns(
        timer: *mut hrtimer,
        tim: ktime_t,
        range_ns: __u64,
        mode: hrtimer_mode,
    );
}
extern "C" {
    pub fn hrtimer_cancel(timer: *mut hrtimer) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hrtimer_try_to_cancel(timer: *mut hrtimer) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __hrtimer_get_remaining(timer: *const hrtimer, adjust: bool_) -> ktime_t;
}
extern "C" {
    pub fn hrtimer_get_next_event() -> __u64;
}
extern "C" {
    pub fn hrtimer_active(timer: *const hrtimer) -> bool_;
}
extern "C" {
    pub fn hrtimer_forward(timer: *mut hrtimer, now: ktime_t, interval: ktime_t) -> __u64;
}
extern "C" {
    pub fn nanosleep_copyout(
        arg1: *mut restart_block,
        arg2: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hrtimer_nanosleep(
        rqtp: *const timespec,
        mode: hrtimer_mode,
        clockid: clockid_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn hrtimer_init_sleeper(sl: *mut hrtimer_sleeper, tsk: *mut task_struct);
}
extern "C" {
    pub fn schedule_hrtimeout_range(
        expires: *mut ktime_t,
        delta: __u64,
        mode: hrtimer_mode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn schedule_hrtimeout_range_clock(
        expires: *mut ktime_t,
        delta: __u64,
        mode: hrtimer_mode,
        clock: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn schedule_hrtimeout(expires: *mut ktime_t, mode: hrtimer_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hrtimer_run_queues();
}
extern "C" {
    pub fn hrtimers_init();
}
extern "C" {
    pub fn sysrq_timer_list_show();
}
extern "C" {
    pub fn hrtimers_prepare_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hrtimers_dead_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clocksource {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ldt_struct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vdso_image {
    pub _address: u8,
}
